[{"name": "app.py", "content": "from shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\nfrom matplotlib import pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom urllib.request import urlopen\nfrom scipy import stats\nimport pandas as pd\nimport json\nimport re\n\n# declare variables\n# colours\nf1_red: str = '#E6002B'\nmain_bg_colour: str = '#111111'\ntext_colour: str = '#FFFFFF'\ntext_grey: str = '#AAAAAA'\ndefault_driver0_colour: str = f1_red # '#1b14e3'\ndefault_driver1_colour: str = text_colour\ndefault_driver_colour: str = '#ae89c4'\ntrack_border_colour: str = '#000000'\ntrack_grey: str = '#001010'\n# tracker_border_colour_driver1: str = text_colour\n\n# lists for drop down selections\nyears: list[str] = ['2023','2024']\nevents: list[str] = []\nsessions: list[str] = []\ndrivers: list[str] = []\n\n# selected from drop down selections\nselected_year: str = None\nselected_meeting_key: str = None\nselected_session_key: str = None\nselected_driver_number: list[str] = []\nselected_driver_colour: list[str] = []\n\n# telemetry data downloaded retrieved\ncar_data: list[pd.DataFrame] = []\nlocations: list[pd.DataFrame] = []\n\n\n# Shiny app layout\napp_ui: ui.page_sidebar = ui.page_sidebar(\n    ui.sidebar(\n        ui.card(\n            ui.input_selectize(\"year\",\"Year: \", choices = years, selected = '2024'),\n            ui.input_selectize(\"event\",\"Event:\", choices = [], selected = 0),\n            ui.input_selectize(\"session\",\"Session:\", choices = []),\n            ui.input_selectize('driver',\"Driver:\", choices = [], multiple = True),\n            ui.input_action_button('refresh','Refresh', class_ = 'btn-success', style = 'color:' + text_colour  + '; background:' + f1_red + 'border: 1px solid ' + text_colour),\n            height = 600,\n            style = 'color:' + text_colour + '; background:' + f1_red,\n        ),\n        ui.output_text('ack'), width = '320px',\n        bg = f1_red,\n        fg = text_colour,\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver0\"),height = 80, style = 'background:' + main_bg_colour)),\n        ui.column(6, ui.output_text(\"header\"),ui.output_text(\"sub_head\"), height = 80, style = 'text-align:center; line-height:2; font-size:1.6em; font-weight:bold; color:' + text_colour + '; background:' + main_bg_colour + '; border: 1px solid ' + f1_red),\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height = 80, style = 'background:' + main_bg_colour))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver0_throttle\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver0_brake\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver0_topspeed\"), height = 100, style = 'background:' + main_bg_colour),\n            height = 400,\n            style = 'background:' + main_bg_colour,\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver1_brake\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver1_topspeed\"), height = 100, style = 'background:' + main_bg_colour),\n            height = 400,\n            style = 'background:' + main_bg_colour\n            )\n        ),\n    ),\n    ui.row(\n        ui.output_plot('track_dominance_plot'),\n        height = 250,\n    ),\n    style = 'background:' + main_bg_colour\n)\n\ndef server(input, output, session):\n    def reset_variables(\n        reset_events: bool = False,\n        reset_sessions: bool = False,\n        reset_drivers: bool = False,\n        reset_selected_year:bool = False,\n        reset_selected_meeting_key:bool = False,\n        reset_selected_session_key: bool = False,\n        reset_selected_driver_number: bool = False,\n        reset_selected_driver_colour: bool = False,\n        reset_car_data:bool = False,\n        reset_locations:bool = False\n    ):\n        global events\n        global sessions\n        global drivers\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global locations\n        \n        events = [] if reset_events else events\n        sessions = [] if reset_sessions else sessions\n        drivers = [] if reset_drivers else drivers\n\n        selected_year = None if reset_selected_year else selected_year\n        selected_meeting_key = None if reset_selected_meeting_key else selected_meeting_key\n        selected_session_key = None if reset_selected_session_key else selected_session_key\n        selected_driver_number = [] if reset_selected_driver_number else selected_driver_number\n        selected_driver_colour = [] if reset_selected_driver_colour else selected_driver_colour\n\n        car_data = [] if reset_car_data else car_data\n        locations = [] if reset_locations else locations\n\n    def get_event_name(idx: int) -> str:\n        return events.event_name[idx]\n\n    def get_driver_name(idx: int) -> str:\n        return drivers.full_name[idx]\n\n    def get_driver_name_acronym(idx: int) -> str:\n        return drivers.name_acronym[idx]\n\n    def get_driver_num(idx: int) -> str:\n        return str(drivers.driver_number[idx])\n\n    def get_session_name(idx: int) -> str:\n        return sessions.session_name[idx]\n\n    def api_call(call_type: str, filters: list[str]) -> pd.DataFrame:\n        call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n        for f in filters:\n            if call_str[-1]  ==  '?':\n                call_str  +=  f\n            else:\n                call_str  +=  '&' + f\n\n        response = urlopen(call_str)\n        df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n        assert df.shape[0] > 0 and df.shape[1] > 0, \"result pd.DataFrame is empty\"        \n        return df \n\n    def format_driver_names(driver_idx: int) -> str:\n        names = get_driver_name(driver_idx).split()\n        return '\\n'.join([names[0],' '.join(names[1:])]), get_driver_name_acronym(driver_idx)\n\n    def plot_names(front_name: str, back_name: str) -> plt.figure:\n        fig, ax = plt.subplots()\n        ax.text(0, 1, back_name, verticalalignment = 'top', horizontalalignment = 'left', color = text_grey, clip_on = False, fontstyle = 'oblique', fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 36, alpha = 0.2)\n        ax.text(1, 1, front_name, verticalalignment = 'top', horizontalalignment = 'right', color = text_colour, fontstyle = 'italic', fontfamily = 'sans-serif', fontsize = 13)\n        fig.patch.set_facecolor(main_bg_colour)\n        ax.set_facecolor(main_bg_colour)\n        ax.axis('off')\n        plt.tight_layout(pad = 0)\n        return fig\n    \n    # number = index for driver in drivers\n    def driver_metric(metric_name, idx, func, minval, maxval, display_name = None) -> plt.figure:\n        fig, ax = plt.subplots()\n\n        if len(input.driver()) > 0 and len(car_data) > idx:\n            plot_data = car_data.copy()[idx]\n\n            #print(plot_data[['throttle']].mean(), selected_driver_colour[num])\n            metric = func(plot_data[[metric_name]]) #plot_data[[metric_name]].mean()\n            ax.barh(0.1, metric, color = str(selected_driver_colour[idx]), height = 0.1, align = 'center')\n            ax.text(maxval, 0.3, str(int(round(metric.iloc[0], 0))), verticalalignment = 'top', horizontalalignment = 'right', color = text_colour, fontstyle = 'oblique', fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 22)\n            display_name = metric_name if display_name is None else display_name\n            ax.text(0, 0.3, display_name, verticalalignment = 'top', horizontalalignment = 'left', color = text_colour, fontstyle = 'oblique',fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 14)\n\n        ax.axis('off')\n        ax.tick_params(axis = 'x', colors = text_colour, direction = 'in')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([])\n        ax.set_xlim(minval, maxval)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor(main_bg_colour)\n        fig.patch.set_facecolor(main_bg_colour)\n        plt.tight_layout()\n\n        return fig\n\n    @reactive.effect\n    def update_event_list_with_year() -> None:\n        global events\n        global selected_year\n\n        # updatinig event drop-drop lists\n        # reset drop-down lists\n        ui.update_selectize(\"event\",choices = [])\n        ui.update_selectize(\"session\",choices = [])\n        ui.update_selectize(\"driver\",choices = [])\n\n        # reset variables for data and what are selected in drop-down lists\n        reset_variables(reset_selected_year = None, reset_selected_meeting_key = None, reset_events = True, reset_sessions = True, reset_selected_session_key = True, reset_drivers = True, reset_selected_driver_number = True, reset_selected_driver_colour = True, reset_car_data = True, reset_locations = True )\n\n        # get year from drop-down list\n        selected_year = input.year()\n\n        # get events data\n        # update event drop-down list\n        df = api_call('meetings', ['year=' + str(selected_year)])\n        assert isinstance(df, pd.DataFrame)\n        \n        try:\n            events = pd.concat([\n                df.circuit_short_name,\n                df.location,\n                df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                df.meeting_key,],axis = 1)\\\n                .rename(columns = {'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n            ui.update_selectize(\"event\",choices = events.event_name)\n        except:\n            print(f\"Likely to be data error when retrieving event data from api_call: year={str(selected_year)}. Dataframe returned has {df.shape[0]} rows and {df.shape[1]} columns\")\n\n    @reactive.effect\n    def update_session_list_with_event() -> None:\n        global sessions\n        global selected_meeting_key\n\n        # updating session drop-down list\n        # reset drop-down lists except for year and event\n        ui.update_selectize(\"driver\", choices = [])\n        ui.update_selectize(\"session\",choices = [])\n\n        # reset variables\n        reset_variables(reset_selected_meeting_key = True, reset_sessions = True, reset_selected_session_key = True, reset_drivers = True, reset_selected_driver_colour = True, reset_selected_driver_number = True, reset_car_data = True, reset_locations = True)\n\n        # check drop-down lists year and event for values\n        # get session data\n        # update session drop-drop list\n        if len(input.year()) > 0 and len(input.event()) > 0:\n            selected_meeting_key = events.meeting_key[int(input.event())]\n\n            df = api_call('sessions', ['year=' + str(selected_year),'meeting_key=' + str(selected_meeting_key)])\n            assert isinstance(df, pd.DataFrame)\n\n            try:\n                sessions = pd.concat([\n                    df.session_key,\n                    df.date_start,\n                    df.session_type,\n                    df.session_name], axis = 1)\n\n                ui.update_selectize(\"session\",choices = sessions.session_name)\n            except:\n                print(f\"Likely to be data error when retrieving session data from api_call: year={str(selected_year)}&meeting_key={str(selected_meeting_key)}. Dataframe returned has {df.shape[0]} rows and {df.shape[1]} columns\")\n\n    @reactive.effect\n    def update_driver_list_with_session() -> None:\n        global drivers\n        global selected_session_key\n\n        # updating driver drop-down list\n        # reset drop-down lists except for year, event and session\n        ui.update_selectize(\"driver\", choices = [])\n\n        # reset variables\n        reset_variables(reset_drivers = True, reset_selected_driver_number = True, reset_selected_driver_colour = True, reset_car_data = True, reset_locations = True)\n\n        if len(input.year()) > 0 and len(input.event()) and len(input.session()) > 0:\n            selected_session_key = sessions.session_key[int(input.session())]\n\n            df = api_call('drivers', ['session_key='+str(selected_session_key)])\n            assert isinstance(df, pd.DataFrame)\n\n            try:\n                drivers = pd.concat([\n                    df.driver_number,\n                    df.name_acronym,\n                    df.full_name,\n                    df.team_name,\n                    df.team_colour,\n                    df.headshot_url,\n                    df.country_code], axis = 1)\n                drivers['team_name'] = drivers['team_name'].fillna('#NA')\n\n                ui.update_selectize(\"driver\", choices = drivers.full_name + \" (\" + drivers.team_name + \")\")\n            except:\n                print(f\"Likely to be data error when retrieving driver data from api_call: session={str(selected_session_key)}. Dataframe returned has {df.shape[0]} rows and {df.shape[1]} columns\")\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    @reactive.event(input.refresh, ignore_none = False)\n    def update_cardata_with_driver() -> None:\n        global car_data\n        global locations\n        global selected_driver_number\n        global selected_driver_colour\n\n        # helper functions to map speed to car x, y position on track and determine track dominance at each trck position\n        # get numerical attribute at specific time, e.g. speed\n        def get_attr_from_car_data_datetime(car_data: pd.DataFrame, time: pd._libs.tslibs.timedeltas.Timedelta, attr:str) -> float:\n            assert car_data[attr].dtypes in ['int64', 'float64']\n            \n            before = car_data.date - car_data.date.min() < time\n            after = car_data.date - car_data.date.min() >=  time\n            speed_before = -1 if len(car_data[before][attr])  ==  0 else car_data[before][attr].iloc[-1]\n            speed_after = -1 if len(car_data[after][attr])  ==  0 else car_data[after][attr].iloc[0]\n            return (speed_before + speed_after) / 2\n\n        # Work out track dominance at specific position x, y between two cars\n        # return 0 = first car is faster\n        # return 1 = second car is faster\n        # return -1 = same speed\n        # x and y are car0 (driver0) position coordinates\n        # compare with car1's (driver1's) speed at the closest x, y position\n        def calc_dominance(x: int, y: int, speed: float) -> int:\n            global locations\n            loc1 = locations[1].copy()\n            loc1['dist'] = abs(loc1.x - x) + abs(loc1.y - y)\n            second_car_speed = loc1[loc1.dist  ==  loc1.dist.min()].speed.iloc[0]\n            if speed > second_car_speed:\n                return 0\n            elif speed < second_car_speed:\n                return 1\n            else:\n                return -1\n\n        def get_fastest_lap(laps: pd.DataFrame) -> pd.DataFrame:\n            # shortest lap time + has a sector 3 time (finished the lap)\n            return laps[(laps.lap_duration  ==  laps.lap_duration.min()) & -laps.duration_sector_3.isna()]\n\n        def get_lap_start_time(lap: pd.DataFrame) -> str:\n            return lap.iloc[0].date_start\n\n        def get_lap_end_time(lap:pd.DataFrame) -> str:\n            lap_start = get_lap_start_time(lap)\n            lap_duration = lap.iloc[0,:].lap_duration\n            lap_end = str(pd.to_datetime(lap_start) + pd.Timedelta(seconds = lap_duration))\n            return re.sub('\\\\s', 'T', lap_end)\n\n        def map_car_data_attr_to_location_xy(location:pd.DataFrame, car_data:pd.DataFrame, attr:str) -> pd.DataFrame:\n            location[attr] = -1.0\n            for i in range(location.shape[0]):\n                time = location.iloc[i,:].date\n                location.loc[i,attr] = get_attr_from_car_data_datetime(car_data, time, 'speed')\n            return location\n\n        # smooth dominance data that are stored in locations[0] (driver0's location data\n        def smooth_dominance(smooth: int) -> None:\n            global locations\n            for i in range(locations[0].shape[0]):\n                if i + smooth < locations[0].shape[0]:\n                    locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i + smooth, 'dominance'])[0]\n\n        # Only update if 1 or 2 drivers are chosen\n        if len(input.driver()) > 0 and len(input.driver()) <=  2:\n\n            fastest_lap_start = None\n            fastest_lap_end = None\n\n            # store previously selected drivers\n            old_selected_driver_number = selected_driver_number\n\n            # update selected driver variables\n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            # assign team colour to driver or use default colour if team/team colour is none\n            selected_driver_colour = ['#' + str(drivers.team_colour[int(d)]) if drivers.team_colour[int(d)] is not None else default_driver_colour for d in input.driver()]\n\n            # if there are more than one driver and driver/team colour assigned are the same\n            # assigned driver colours to be default driver0 and driver1 colours\n            if len(input.driver()) > 1 and (selected_driver_colour[0]  ==  selected_driver_colour[1]):\n                selected_driver_colour = [default_driver0_colour, default_driver1_colour]\n\n            # get car_data and location_data\n            temp_car_data = []\n            temp_locations = []\n            for i, d in enumerate(selected_driver_number):\n                if old_selected_driver_number == [] or selected_driver_number[i] not in old_selected_driver_number:\n                    api_result_df = api_call('laps',['session_key=' + str(selected_session_key),'driver_number=' + str(selected_driver_number[i])])\n\n                    fastest_lap = get_fastest_lap(api_result_df)\n                    fastest_lap_start = get_lap_start_time(fastest_lap)\n                    fastest_lap_end = get_lap_end_time(fastest_lap)\n\n                    car_data_df = api_call('car_data',['driver_number=' + str(selected_driver_number[i]),'session_key=' + str(selected_session_key),'date>=' + str(fastest_lap_start),'date<=' + str(fastest_lap_end)])\n                    car_data_df['date'] = pd.to_datetime(car_data_df.date, format = 'mixed') - pd.to_datetime(car_data_df.date,format = 'mixed').min()\n                    temp_car_data.append(car_data_df)\n\n                    locations_df = api_call('location',['driver_number=' + str(selected_driver_number[i]),'session_key=' + str(selected_session_key),'date>=' + str(fastest_lap_start),'date<=' + str(fastest_lap_end)])\n                    locations_df['date'] = pd.to_datetime(locations_df.date, format = 'mixed') - pd.to_datetime(locations_df.date,format = 'mixed').min()\n                    start_x = locations_df[locations_df.date  ==  locations_df.date.min()].x.iloc[0]\n                    start_y = locations_df[locations_df.date  ==  locations_df.date.min()].y.iloc[0]\n                    locations_df['x'] = locations_df.x - start_x\n                    locations_df['y'] = locations_df.y - start_y\n                    temp_locations.append(locations_df)\n                else:\n                    temp_car_data.append(car_data.copy()[old_selected_driver_number.index(selected_driver_number[i])])\n                    temp_locations.append(locations.copy()[old_selected_driver_number.index(selected_driver_number[i])])\n\n            car_data = temp_car_data.copy()\n            locations = temp_locations.copy()\n\n            # initialize colour attribute in locations[0] for track dominance plotting\n            # stored track dominance information only in locations[0] (driver0's location table) plotting\n            locations[0]['colour'] = selected_driver_colour[0]\n\n            # compare if there are two cars\n            if len(locations) > 1:\n                # map speed (car_data) to x, y position (location)\n                for j in range(len(locations)):\n                    locations[j] = map_car_data_attr_to_location_xy(locations[j],car_data[j], 'speed')\n                    '''locations[j]['speed'] = -1.0\n                    for i in range(locations[j].shape[0]):\n                        time = locations[j].iloc[i,:].date\n                        locations[j].loc[i,'speed'] = get_speed_from_car_data_datetime(car_data[j], time)'''\n\n                # determine track dominance\n                locations[0]['dominance'] = -99\n                for i in range(locations[0].shape[0]):\n                    x, y, speed = locations[0].iloc[i, :].x, locations[0].iloc[i, :].y, locations[0].iloc[i, :].speed\n                    locations[0].loc[i, 'dominance'] = calc_dominance(x, y, speed)\n\n                # smooth dominance result twice\n                smooth_dominance(smooth = 12)\n                smooth_dominance(smooth = 8)\n\n                # assign driver colour to locations on track to represent track dominance\n                for i in range(locations[0].shape[0]):\n                    dominance = locations[0].loc[i, 'dominance']\n                    if dominance  ==  0:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[0]\n                    elif dominance  ==  1:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[1]\n                    else:\n                        locations[0].loc[i, 'colour'] = '#00AAAA'\n\n        print(selected_meeting_key, selected_session_key)\n\n    # header elements\n    @render.text\n    def header() -> str:\n        if input.event():\n            event_name = get_event_name(int(input.event()))\n            return input.year() + ' ' + event_name if event_name !=  None else input.year()\n\n    @render.text\n    def sub_head() -> str:\n        if input.session():\n            session_name = get_session_name(int(input.session()))\n            return session_name if session_name !=  None else ''\n\n    @render.plot\n    def driver0() -> plt.figure:\n        if input.driver():\n            front_name, back_name = format_driver_names(int(input.driver()[0]))\n            return plot_names(front_name, back_name)\n\n    @render.plot\n    def driver1() -> plt.figure:\n        if len(input.driver())  ==  2:\n            front_name, back_name = format_driver_names(int(input.driver()[1]))\n            return plot_names(front_name, back_name)\n\n    # telemetry plot\n    @render_widget\n    @reactive.event(input.refresh, ignore_none = False)\n    def tele_plot() -> go.Figure:\n        fig = go.Figure()\n\n        if input.driver() !=  '':\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = data.date.astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace = True)\n                    data['date'] = pd.to_datetime(data.date,format = '%M:%S.%f')\n                    data.dropna(inplace = True)\n\n                    dr_mask = drivers.driver_number  ==  selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<= .[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n\n                    fig.add_trace(go.Scatter(x = data.date, y = data.speed, line = (dict(color = str(selected_driver_colour[i]))) , name = list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template = 'plotly_dark',\n            plot_bgcolor = 'black',\n            showlegend = True,\n            legend = dict(yanchor = 'bottom',y = 0.01,xanchor = 'right',x = 0.99,orientation = 'h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        fig.update_yaxes(title_text = 'Speed / mph')\n        return fig\n\n    # driver metrics\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_throttle() -> plt.figure:\n        return driver_metric('throttle', 0, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_throttle() -> plt.figure:\n        return driver_metric('throttle', 1, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_brake() -> plt.figure:\n        return driver_metric('brake', 0, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_brake() -> plt.figure:\n        return driver_metric('brake', 1, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_topspeed() -> plt.figure:\n        return driver_metric('speed', 0, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_topspeed() -> plt.figure:\n        return driver_metric('speed', 1, pd.Series.max, 0, 350, 'Top speed')\n\n    # track dominance\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def track_dominance_plot() -> go.Figure:\n        global locations\n\n        fig, ax = plt.subplots()\n\n        if len(input.driver()) > 0 and len(locations) > 0:\n            plot_data = locations.copy()[0]\n\n            # draw driver0\n            ax.plot(plot_data.x + 50, plot_data.y - 250, c = text_colour, ls = '-', lw = 10, alpha = 0.15)\n            ax.plot(plot_data.x, plot_data.y, c = track_grey, ls = '-', lw = 6)\n            ax.plot(plot_data.x, plot_data.y, c = selected_driver_colour[0], ls = '-', lw = 4)\n\n            # work out segments for drawing driver1 dominant parts\n            if len(plot_data.colour.unique()) > 1:\n                current_segment = 0\n                plot_data['segment'] = -1\n                for i in range(plot_data.shape[0]):\n                    plot_data.loc[i, 'segment'] = current_segment\n                    if (i < plot_data.shape[0] - 1) and (plot_data.loc[i, 'dominance'] !=  plot_data.loc[i + 1, 'dominance']):\n                        current_segment  +=  1\n\n                # only draw driver1 dominant segments\n                plot_data_c = plot_data[plot_data.dominance  ==  1]\n                for seg in plot_data_c.segment.unique():\n                        plot_segment = plot_data_c[plot_data_c.segment  ==  seg]\n                        if plot_segment.shape[0] > 1:\n                            # ax.plot(plot_segment.x, plot_segment.y, c = tracker_border_colour_driver1, ls = '-', lw = 6)\n                            ax.plot(plot_segment.x, plot_segment.y, c = selected_driver_colour[1], ls = '-', lw = 4)\n\n            ax.plot(plot_data.x[0], plot_data.y[0], c = track_border_colour, marker = 'o', markersize = 8)\n            ax.plot(plot_data.x[0], plot_data.y[0], c = text_colour, marker = 'o', markersize = 6)\n\n        ax.axis('off')\n        ax.set_facecolor(main_bg_colour)\n\n        fig.patch.set_facecolor(main_bg_colour)\n        return fig\n    \n    @render.text\n    def ack() -> str:\n        return 'Credit to the open-sourced OpenF1.org API (https://openf1.org/) for the Formula One\u00ae telemetry data used in this dashboard'\n\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "rsconnect-python/f1_telemetry.json", "content": "{\n    \"https://api.shinyapps.io\": {\n        \"server_url\": \"https://api.shinyapps.io\",\n        \"filename\": \"/Users/kalokleung/Library/CloudStorage/OneDrive-Personal/Data Science/Shiny/f1_telemetry\",\n        \"app_url\": \"https://ka-lok-leung.shinyapps.io/f1_telemetry/\",\n        \"app_id\": 11321481,\n        \"app_guid\": null,\n        \"title\": \"F1_telemetry\",\n        \"app_mode\": \"python-shiny\",\n        \"app_store_version\": 1\n    }\n}", "type": "text"}, {"name": "find_track_segments/find_track_segments.ipynb", "content": "{\n \"cells\": [\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 115,\n   \"id\": \"e797e606-5de7-4ae7-a1d4-d6c99b65c8f1\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"from urllib.request import urlopen\\n\",\n    \"from matplotlib import pyplot as plt\\n\",\n    \"import pandas as pd\\n\",\n    \"import json\\n\",\n    \"import re\\n\",\n    \"import math\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 2,\n   \"id\": \"f1c8e6dc-d717-4113-948b-30a750af3c74\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"def api_call(call_type: str, filters: list[str]) -> pd.DataFrame:\\n\",\n    \"    call_str = 'https://api.openf1.org/v1/' + call_type + '?'\\n\",\n    \"\\n\",\n    \"    for f in filters:\\n\",\n    \"        if call_str[-1]  ==  '?':\\n\",\n    \"            call_str  +=  f\\n\",\n    \"        else:\\n\",\n    \"            call_str  +=  '&' + f\\n\",\n    \"\\n\",\n    \"    response = urlopen(call_str)\\n\",\n    \"    df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\\n\",\n    \"\\n\",\n    \"    assert df.shape[0] > 0 and df.shape[1] > 0, \\\"result pd.DataFrame is empty\\\"\\n\",\n    \"\\n\",\n    \"    return df \\n\",\n    \"\\n\",\n    \"def get_attr_from_car_data_datetime(car_data: pd.DataFrame, time: pd._libs.tslibs.timedeltas.Timedelta, attr:str) -> float:\\n\",\n    \"    assert car_data[attr].dtypes in ['int64', 'float64']\\n\",\n    \"    \\n\",\n    \"    before = car_data.date - car_data.date.min() < time\\n\",\n    \"    after = car_data.date - car_data.date.min() >=  time\\n\",\n    \"    speed_before = -1 if len(car_data[before][attr])  ==  0 else car_data[before][attr].iloc[-1]\\n\",\n    \"    speed_after = -1 if len(car_data[after][attr])  ==  0 else car_data[after][attr].iloc[0]\\n\",\n    \"    return (speed_before + speed_after) / 2\\n\",\n    \"\\n\",\n    \"def get_fastest_lap(laps: pd.DataFrame) -> pd.DataFrame:\\n\",\n    \"    # shortest lap time + has a sector 3 time (finished the lap)\\n\",\n    \"    return laps[(laps.lap_duration  ==  laps.lap_duration.min()) & -laps.duration_sector_3.isna()]\\n\",\n    \"\\n\",\n    \"def get_lap_start_time(lap: pd.DataFrame) -> str:\\n\",\n    \"    return lap.iloc[0].date_start\\n\",\n    \"\\n\",\n    \"def get_lap_end_time(lap:pd.DataFrame) -> str:\\n\",\n    \"    lap_start = get_lap_start_time(lap)\\n\",\n    \"    lap_duration = lap.iloc[0,:].lap_duration\\n\",\n    \"    lap_end = str(pd.to_datetime(lap_start) + pd.Timedelta(seconds = lap_duration))\\n\",\n    \"    return re.sub('\\\\\\\\s', 'T', lap_end)\\n\",\n    \"\\n\",\n    \"def map_car_data_attr_to_location_xy(location:pd.DataFrame, car_data:pd.DataFrame, attr:str) -> pd.DataFrame:\\n\",\n    \"    location[attr] = -1.0\\n\",\n    \"    for i in range(location.shape[0]):\\n\",\n    \"        time = location.iloc[i,:].date\\n\",\n    \"        location.loc[i,attr] = get_attr_from_car_data_datetime(car_data, time, 'speed')\\n\",\n    \"    return location\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 104,\n   \"id\": \"b4c97ca3-3f5c-4e8c-a6b1-627c3c1a6610\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"test_data = {\\n\",\n    \"    'Bahrain':{'meeting_key':'1229', 'race_session_key':'9472'},\\n\",\n    \"    'Jeddah':{'meeting_key':'1230', 'race_session_key':'9480'},\\n\",\n    \"    'Melbourne':{'meeting_key':'1231', 'race_session_key':'9481'},\\n\",\n    \"    \\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"event = 'Jeddah'\\n\",\n    \"meeting_key = test_data[event]['meeting_key']\\n\",\n    \"session_key = test_data[event]['race_session_key']\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 105,\n   \"id\": \"78b14435-13d9-4143-a4c4-33a6ba5f35ce\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"laps = api_call(\\\"laps\\\", ['meeting_key='+meeting_key,'session_key='+session_key, 'driver_number=1'])\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 106,\n   \"id\": \"394a1c23-0b8d-44e7-84dc-3f1abba6cb33\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"2024-03-09T18:23:11.113000 2024-03-09T18:24:42.886000\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"fastest_lap = get_fastest_lap(laps)\\n\",\n    \"\\n\",\n    \"fastest_lap_start = get_lap_start_time(fastest_lap)\\n\",\n    \"fastest_lap_end = get_lap_end_time(fastest_lap)\\n\",\n    \"\\n\",\n    \"print(fastest_lap_start, fastest_lap_end)\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 107,\n   \"id\": \"40143c40-05e7-43f1-8aad-88918cabcd3a\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"car_data = api_call(\\\"car_data\\\", ['meeting_key='+meeting_key,'session_key='+session_key, 'driver_number=1','date>=' + str(fastest_lap_start),'date<=' + str(fastest_lap_end)])\\n\",\n    \"car_data['date'] = pd.to_datetime(car_data.date, format = 'mixed') - pd.to_datetime(car_data.date,format = 'mixed').min()\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 108,\n   \"id\": \"5b2c32e9-4834-494c-9089-655209ddc4de\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"location = api_call(\\\"location\\\", ['meeting_key='+meeting_key,'session_key='+session_key, 'driver_number=1', 'date>=' + str(fastest_lap_start),'date<=' + str(fastest_lap_end)])\\n\",\n    \"location['date'] = pd.to_datetime(location.date, format = 'mixed') - pd.to_datetime(location.date,format = 'mixed').min()\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 109,\n   \"id\": \"7308844d-5a55-46ea-b394-d21433754697\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"location1 = map_car_data_attr_to_location_xy(location, car_data, 'speed')\\n\",\n    \"location1 = map_car_data_attr_to_location_xy(location, car_data, 'throttle')\\n\",\n    \"location1 = map_car_data_attr_to_location_xy(location, car_data, 'brake')\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"9d033884-4276-441e-ac48-dc14b189f911\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"location1['dist'] = None\\n\",\n    \"location1['angle'] = None\\n\",\n    \"\\n\",\n    \"for i in range(location1.shape[0]):\\n\",\n    \"    if 0 < i < location1.shape[0] - 1:\\n\",\n    \"        dx = (location1.loc[i+1, 'x'] - location1.loc[i, 'x']) - (location1.loc[i, 'x'] - location1.loc[i-1, 'x'])\\n\",\n    \"        dy = (location1.loc[i+1, 'y'] - location1.loc[i, 'y']) - (location1.loc[i, 'y'] - location1.loc[i-1, 'y'])\\n\",\n    \"        print(dx, dy)\\n\",\n    \"        try:\\n\",\n    \"            location1.loc[i, 'angle'] = math.atan(dx/dy)\\n\",\n    \"        except:\\n\",\n    \"            location1.loc[i, 'angle'] = 0\\n\",\n    \"        location1.loc[i, 'dist'] = dx**2 + dy**2\\n\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 182,\n   \"id\": \"3f645f5a-9065-44bb-9a51-158dd3f3e4c6\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"data\": {\n      \"text/plain\": [\n       \"array([0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\\n\",\n       \"       0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n\",\n       \"       0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0,\\n\",\n       \"       1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 2, 0, 0, 3, 3, 0, 2, 2, 0, 0,\\n\",\n       \"       0, 1, 1, 0, 1, 2, 1, 0, 2, 2, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1,\\n\",\n       \"       0, 2, 0, 1, 2, 2, 1, 2, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 2, 3, 2, 1,\\n\",\n       \"       0, 0, 0, 2, 0, 0, 3, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0,\\n\",\n       \"       1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 2, 1, 0, 0, 2, 1, 0, 0, 0, 0,\\n\",\n       \"       0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0,\\n\",\n       \"       0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n\",\n       \"       0, 0, 1, 2, 2, 0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0,\\n\",\n       \"       0, 0, 0, 2, 2, 1, 0, 0, 2, 2, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1,\\n\",\n       \"       0, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,\\n\",\n       \"       0, 2, 3, 3, 2, 2, 0, 1, 2, 0, 0, 0, 2, 0, 0, 0, 0, 1, 2, 1, 0, 1,\\n\",\n       \"       1, 1, 1, 2, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,\\n\",\n       \"       0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,\\n\",\n       \"       0, 0, 0, 0, 0, 0, 0, 0], dtype=int32)\"\n      ]\n     },\n     \"execution_count\": 182,\n     \"metadata\": {},\n     \"output_type\": \"execute_result\"\n    }\n   ],\n   \"source\": [\n    \"from sklearn.cluster import KMeans\\n\",\n    \"from sklearn.preprocessing import StandardScaler\\n\",\n    \"\\n\",\n    \"#X = location1[['throttle','brake','speed','dist','angle']].iloc[1:location1.shape[0]-1,:].to_numpy()\\n\",\n    \"X = location1[['dist','angle']].iloc[1:location1.shape[0]-1,:].to_numpy()\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"scaler = StandardScaler()\\n\",\n    \"X = scaler.fit(X).transform(X)\\n\",\n    \"\\n\",\n    \"kmeans = KMeans(n_clusters=4, random_state=0, n_init=\\\"auto\\\").fit(X)\\n\",\n    \"kmeans.labels_\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 183,\n   \"id\": \"a1b19fbe-bd17-49e8-a594-972ec074aafa\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"result = location1.iloc[1:location1.shape[0]-1,:].copy()\\n\",\n    \"result['label'] = kmeans.labels_\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 184,\n   \"id\": \"2f74691b-0b5b-476e-b1fd-ac90ace740fb\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"plot_data = result.copy()\\n\",\n    \"if len(plot_data.label.unique()) > 1:\\n\",\n    \"    current_segment = 0\\n\",\n    \"    plot_data['segment'] = -1\\n\",\n    \"    for i in range(plot_data.shape[0]):\\n\",\n    \"        plot_data.loc[i, 'segment'] = current_segment\\n\",\n    \"        if (i < plot_data.shape[0] - 1) and (plot_data.loc[i, 'label'] !=  plot_data.loc[i + 1, 'label']):\\n\",\n    \"            current_segment  +=  1\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 185,\n   \"id\": \"9daab13e-3e9a-4d29-aed1-0f6d2aeac3ba\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"data\": {\n      \"text/plain\": [\n       \"(-6086.0, 316.0, -7012.85, 23167.85)\"\n      ]\n     },\n     \"execution_count\": 185,\n     \"metadata\": {},\n     \"output_type\": \"execute_result\"\n    },\n    {\n     \"data\": {\n      \"image/png\": \"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\",\n      \"text/plain\": [\n       \"<Figure size 640x480 with 1 Axes>\"\n      ]\n     },\n     \"metadata\": {},\n     \"output_type\": \"display_data\"\n    }\n   ],\n   \"source\": [\n    \"fig, ax = plt.subplots()\\n\",\n    \"\\n\",\n    \"colours = ['#ff0000','#00ff00','#0000ff', '#00FFFF', '#ffff00', '#FFFF00', '#123456', '#654321']\\n\",\n    \"\\n\",\n    \"ax.plot(plot_data.x, plot_data.y, c='#eeeeee', ls='-')\\n\",\n    \"\\n\",\n    \"for s in plot_data.label.unique():\\n\",\n    \"    plot_data_seg = plot_data[plot_data.label == s]\\n\",\n    \"    for i, seg in enumerate(plot_data_seg.segment.unique()):\\n\",\n    \"        plot_segment = plot_data_seg[plot_data_seg.segment == seg]\\n\",\n    \"        if plot_segment.shape[0] > 1:\\n\",\n    \"            ax.plot(plot_segment.x, plot_segment.y, c=colours[int(s)], ls='-')\\n\",\n    \"\\n\",\n    \"ax.axis('off')\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 175,\n   \"id\": \"54e7cabd-1177-46f6-8800-d6c710a60a20\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# 1229 9465 # Bahrain\\n\",\n    \"# \"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"f689643c-7e18-400a-aa27-90488514a3f9\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": []\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"python-3.12-kernel\",\n   \"language\": \"python\",\n   \"name\": \"python-3.12-kernel\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.12.2\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 5\n}\n", "type": "text"}, {"name": "track dominance/track_d.ipynb", "content": "{\n \"cells\": [\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 1,\n   \"id\": \"5e102b36-f828-4cba-b53e-3b512895d52d\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"import pandas as pd\\n\",\n    \"from scipy import stats\\n\",\n    \"from urllib.request import urlopen\\n\",\n    \"import json\\n\",\n    \"import re\\n\",\n    \"\\n\",\n    \"def api_to_df(call_type, filters):\\n\",\n    \"    call_str = 'https://api.openf1.org/v1/' + call_type + '?'\\n\",\n    \"\\n\",\n    \"    for f in filters:\\n\",\n    \"        if call_str[-1] == '?':\\n\",\n    \"            call_str += f\\n\",\n    \"        else:\\n\",\n    \"            call_str += '&' + f\\n\",\n    \"\\n\",\n    \"    response = urlopen(call_str)\\n\",\n    \"    return pd.DataFrame(json.loads(response.read().decode('utf-8')))\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 2,\n   \"id\": \"ff2fdfeb-c8e1-4b2d-9c17-3bc9d4a334cf\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"selected_driver_number = [4, 81]\\n\",\n    \"selected_session_key = 9161\\n\",\n    \"\\n\",\n    \"responses = [api_to_df('laps',['session_key='+str(selected_session_key),'driver_number='+str(d)]) for d in selected_driver_number]\\n\",\n    \"\\n\",\n    \"fastest_laps = [\\n\",\n    \"                r[(r.lap_duration == r.lap_duration.min()) &\\n\",\n    \"                  -r.duration_sector_3.isna()]\\n\",\n    \"                for r in responses]\\n\",\n    \"\\n\",\n    \"car_data = []\\n\",\n    \"locations = []\\n\",\n    \"for i in range(len(fastest_laps)):\\n\",\n    \"    fastest_lap_start = fastest_laps[i].iloc[0,:].date_start\\n\",\n    \"    fastest_lap_duration = fastest_laps[i].iloc[0,:].lap_duration\\n\",\n    \"    fastest_lap_end = str(pd.to_datetime(fastest_lap_start) + pd.Timedelta(seconds=fastest_lap_duration))\\n\",\n    \"    fastest_lap_end = re.sub('\\\\\\\\s', 'T', fastest_lap_end)\\n\",\n    \"    #print(selected_driver_number[i])\\n\",\n    \"    #response = urlopen('https://api.openf1.org/v1/car_data?driver_number='+str(selected_driver_number[i])+'&session_key='+str(selected_session_key)+'&date>'+str(fastest_lap_start)+'&date<'+str(fastest_lap_end))\\n\",\n    \"    #car_data.append(pd.DataFrame(json.loads(response.read().decode('utf-8'))))\\n\",\n    \"    car_data_df = api_to_df('car_data',['driver_number='+str(selected_driver_number[i]),'session_key='+str(selected_session_key),'date>='+str(fastest_lap_start),'date<='+str(fastest_lap_end)])\\n\",\n    \"    car_data_df['date'] = pd.to_datetime(car_data_df.date, format='mixed') - pd.to_datetime(car_data_df.date,format='mixed').min()\\n\",\n    \"    car_data.append(car_data_df)\\n\",\n    \"\\n\",\n    \"    locations_df = api_to_df('location',['driver_number='+str(selected_driver_number[i]),'session_key='+str(selected_session_key),'date>='+str(fastest_lap_start),'date<='+str(fastest_lap_end)])\\n\",\n    \"    locations_df['date'] = pd.to_datetime(locations_df.date, format='mixed') - pd.to_datetime(locations_df.date,format='mixed').min()\\n\",\n    \"    start_x = locations_df[locations_df.date == locations_df.date.min()].x.iloc[0]\\n\",\n    \"    start_y = locations_df[locations_df.date == locations_df.date.min()].y.iloc[0]\\n\",\n    \"    locations_df['x'] = locations_df.x - start_x\\n\",\n    \"    locations_df['y'] = locations_df.y - start_y\\n\",\n    \"    locations.append(locations_df)\\n\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 3,\n   \"id\": \"2d106200-2712-4b94-b5fc-6692f4b1dab3\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"data\": {\n      \"text/plain\": [\n       \"Index(['x', 'y', 'z', 'driver_number', 'date', 'session_key', 'meeting_key'], dtype='object')\"\n      ]\n     },\n     \"execution_count\": 3,\n     \"metadata\": {},\n     \"output_type\": \"execute_result\"\n    }\n   ],\n   \"source\": [\n    \"locations[0].columns\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 4,\n   \"id\": \"3ce36886-84d7-40fb-b462-82b85ebd1064\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"data\": {\n      \"text/plain\": [\n       \"Index(['driver_number', 'rpm', 'speed', 'n_gear', 'throttle', 'brake', 'drs',\\n\",\n       \"       'date', 'session_key', 'meeting_key'],\\n\",\n       \"      dtype='object')\"\n      ]\n     },\n     \"execution_count\": 4,\n     \"metadata\": {},\n     \"output_type\": \"execute_result\"\n    }\n   ],\n   \"source\": [\n    \"car_data[0].columns\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 9,\n   \"id\": \"f71a46a7-15f1-4a76-9179-dfdb4a03725d\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"def get_speed_from_car_data(car_num, time):\\n\",\n    \"    global car_data\\n\",\n    \"    before = car_data[car_num].date < time\\n\",\n    \"    after = car_data[car_num].date >= time \\n\",\n    \"    speed_before = -1 if len(car_data[car_num][before].speed) == 0 else car_data[car_num][before].speed.iloc[-1]\\n\",\n    \"    speed_after = -1 if len(car_data[car_num][after].speed) == 0 else car_data[car_num][after].speed.iloc[0]\\n\",\n    \"    #print(speed_before, speed_after)\\n\",\n    \"    return (speed_before + speed_after) / 2\\n\",\n    \"\\n\",\n    \"for j in range(len(locations)):\\n\",\n    \"    locations[j]['speed'] = -1.0\\n\",\n    \"    for i in range(locations[j].shape[0]):\\n\",\n    \"        time = locations[j].iloc[i,:].date\\n\",\n    \"        #print(pt.x, pt.y, pt.date)\\n\",\n    \"        locations[j].loc[i,'speed'] = get_speed_from_car_data(j, time)\\n\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 17,\n   \"id\": \"9ecc4f6e-9bf3-46fd-9da7-14ba1d02035a\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# return 0 = first car is faster\\n\",\n    \"# return 1 = second car is faster\\n\",\n    \"# return -1 = same speed\\n\",\n    \"def calc_dominance(x, y, speed):\\n\",\n    \"    global locations\\n\",\n    \"    loc1 = locations[1].copy()\\n\",\n    \"    loc1['dist'] = abs(loc1.x - x) + abs(loc1.y - y)\\n\",\n    \"    second_car_speed = loc1[loc1.dist == loc1.dist.min()].speed.iloc[0]\\n\",\n    \"    if speed > second_car_speed:\\n\",\n    \"        return 0\\n\",\n    \"    elif speed < second_car_speed:\\n\",\n    \"        return 1\\n\",\n    \"    else:\\n\",\n    \"        return -1\\n\",\n    \"\\n\",\n    \"locations[0]['dominance'] = -99\\n\",\n    \"for i in range(locations[0].shape[0]):\\n\",\n    \"    x, y, speed = locations[0].iloc[i, :].x, locations[0].iloc[i, :].y, locations[0].iloc[i, :].speed \\n\",\n    \"    locations[0].loc[i, 'dominance'] = calc_dominance(x, y, speed)\\n\",\n    \"\\n\",\n    \"smooth = 10\\n\",\n    \"for i in range(locations[0].shape[0]):\\n\",\n    \"    if i + smooth < locations[0].shape[0]:\\n\",\n    \"        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i+10, 'dominance'])[0]\\n\",\n    \"\\n\",\n    \"smooth = 5\\n\",\n    \"for i in range(locations[0].shape[0]):\\n\",\n    \"    if i + smooth < locations[0].shape[0]:\\n\",\n    \"        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i+10, 'dominance'])[0]\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 18,\n   \"id\": \"7731595f-8762-4c43-a680-a0f09a0de25e\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"data\": {\n      \"text/plain\": [\n       \"<Axes: >\"\n      ]\n     },\n     \"execution_count\": 18,\n     \"metadata\": {},\n     \"output_type\": \"execute_result\"\n    },\n    {\n     \"data\": {\n      \"image/png\": \"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\",\n      \"text/plain\": [\n       \"<Figure size 640x480 with 1 Axes>\"\n      ]\n     },\n     \"metadata\": {},\n     \"output_type\": \"display_data\"\n    }\n   ],\n   \"source\": [\n    \"locations[0].dominance.plot()\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 19,\n   \"id\": \"8a48b20a-e8aa-4a2b-b3e0-599f60bd5eb7\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"data\": {\n      \"text/html\": [\n       \"<div>\\n\",\n       \"<style scoped>\\n\",\n       \"    .dataframe tbody tr th:only-of-type {\\n\",\n       \"        vertical-align: middle;\\n\",\n       \"    }\\n\",\n       \"\\n\",\n       \"    .dataframe tbody tr th {\\n\",\n       \"        vertical-align: top;\\n\",\n       \"    }\\n\",\n       \"\\n\",\n       \"    .dataframe thead th {\\n\",\n       \"        text-align: right;\\n\",\n       \"    }\\n\",\n       \"</style>\\n\",\n       \"<table border=\\\"1\\\" class=\\\"dataframe\\\">\\n\",\n       \"  <thead>\\n\",\n       \"    <tr style=\\\"text-align: right;\\\">\\n\",\n       \"      <th></th>\\n\",\n       \"      <th>x</th>\\n\",\n       \"      <th>y</th>\\n\",\n       \"      <th>z</th>\\n\",\n       \"      <th>driver_number</th>\\n\",\n       \"      <th>date</th>\\n\",\n       \"      <th>session_key</th>\\n\",\n       \"      <th>meeting_key</th>\\n\",\n       \"      <th>speed</th>\\n\",\n       \"      <th>dominance</th>\\n\",\n       \"      <th>segment_count</th>\\n\",\n       \"    </tr>\\n\",\n       \"  </thead>\\n\",\n       \"  <tbody>\\n\",\n       \"    <tr>\\n\",\n       \"      <th>0</th>\\n\",\n       \"      <td>0</td>\\n\",\n       \"      <td>0</td>\\n\",\n       \"      <td>188</td>\\n\",\n       \"      <td>4</td>\\n\",\n       \"      <td>0 days 00:00:00</td>\\n\",\n       \"      <td>9161</td>\\n\",\n       \"      <td>1219</td>\\n\",\n       \"      <td>134.0</td>\\n\",\n       \"      <td>0</td>\\n\",\n       \"      <td>0</td>\\n\",\n       \"    </tr>\\n\",\n       \"    <tr>\\n\",\n       \"      <th>1</th>\\n\",\n       \"      <td>-41</td>\\n\",\n       \"      <td>253</td>\\n\",\n       \"      <td>188</td>\\n\",\n       \"      <td>4</td>\\n\",\n       \"      <td>0 days 00:00:00.340000</td>\\n\",\n       \"      <td>9161</td>\\n\",\n       \"      <td>1219</td>\\n\",\n       \"      <td>274.0</td>\\n\",\n       \"      <td>0</td>\\n\",\n       \"      <td>0</td>\\n\",\n       \"    </tr>\\n\",\n       \"    <tr>\\n\",\n       \"      <th>2</th>\\n\",\n       \"      <td>-72</td>\\n\",\n       \"      <td>449</td>\\n\",\n       \"      <td>188</td>\\n\",\n       \"      <td>4</td>\\n\",\n       \"      <td>0 days 00:00:00.579000</td>\\n\",\n       \"      <td>9161</td>\\n\",\n       \"      <td>1219</td>\\n\",\n       \"      <td>277.5</td>\\n\",\n       \"      <td>0</td>\\n\",\n       \"      <td>0</td>\\n\",\n       \"    </tr>\\n\",\n       \"    <tr>\\n\",\n       \"      <th>3</th>\\n\",\n       \"      <td>-106</td>\\n\",\n       \"      <td>664</td>\\n\",\n       \"      <td>188</td>\\n\",\n       \"      <td>4</td>\\n\",\n       \"      <td>0 days 00:00:00.879000</td>\\n\",\n       \"      <td>9161</td>\\n\",\n       \"      <td>1219</td>\\n\",\n       \"      <td>281.0</td>\\n\",\n       \"      <td>0</td>\\n\",\n       \"      <td>0</td>\\n\",\n       \"    </tr>\\n\",\n       \"    <tr>\\n\",\n       \"      <th>4</th>\\n\",\n       \"      <td>-134</td>\\n\",\n       \"      <td>851</td>\\n\",\n       \"      <td>188</td>\\n\",\n       \"      <td>4</td>\\n\",\n       \"      <td>0 days 00:00:01.119000</td>\\n\",\n       \"      <td>9161</td>\\n\",\n       \"      <td>1219</td>\\n\",\n       \"      <td>285.5</td>\\n\",\n       \"      <td>0</td>\\n\",\n       \"      <td>0</td>\\n\",\n       \"    </tr>\\n\",\n       \"    <tr>\\n\",\n       \"      <th>...</th>\\n\",\n       \"      <td>...</td>\\n\",\n       \"      <td>...</td>\\n\",\n       \"      <td>...</td>\\n\",\n       \"      <td>...</td>\\n\",\n       \"      <td>...</td>\\n\",\n       \"      <td>...</td>\\n\",\n       \"      <td>...</td>\\n\",\n       \"      <td>...</td>\\n\",\n       \"      <td>...</td>\\n\",\n       \"      <td>...</td>\\n\",\n       \"    </tr>\\n\",\n       \"    <tr>\\n\",\n       \"      <th>336</th>\\n\",\n       \"      <td>129</td>\\n\",\n       \"      <td>-1067</td>\\n\",\n       \"      <td>189</td>\\n\",\n       \"      <td>4</td>\\n\",\n       \"      <td>0 days 00:01:29.779000</td>\\n\",\n       \"      <td>9161</td>\\n\",\n       \"      <td>1219</td>\\n\",\n       \"      <td>242.0</td>\\n\",\n       \"      <td>1</td>\\n\",\n       \"      <td>284</td>\\n\",\n       \"    </tr>\\n\",\n       \"    <tr>\\n\",\n       \"      <th>337</th>\\n\",\n       \"      <td>115</td>\\n\",\n       \"      <td>-749</td>\\n\",\n       \"      <td>189</td>\\n\",\n       \"      <td>4</td>\\n\",\n       \"      <td>0 days 00:01:30.079000</td>\\n\",\n       \"      <td>9161</td>\\n\",\n       \"      <td>1219</td>\\n\",\n       \"      <td>248.5</td>\\n\",\n       \"      <td>1</td>\\n\",\n       \"      <td>285</td>\\n\",\n       \"    </tr>\\n\",\n       \"    <tr>\\n\",\n       \"      <th>338</th>\\n\",\n       \"      <td>84</td>\\n\",\n       \"      <td>-506</td>\\n\",\n       \"      <td>188</td>\\n\",\n       \"      <td>4</td>\\n\",\n       \"      <td>0 days 00:01:30.460000</td>\\n\",\n       \"      <td>9161</td>\\n\",\n       \"      <td>1219</td>\\n\",\n       \"      <td>254.0</td>\\n\",\n       \"      <td>1</td>\\n\",\n       \"      <td>286</td>\\n\",\n       \"    </tr>\\n\",\n       \"    <tr>\\n\",\n       \"      <th>339</th>\\n\",\n       \"      <td>56</td>\\n\",\n       \"      <td>-335</td>\\n\",\n       \"      <td>188</td>\\n\",\n       \"      <td>4</td>\\n\",\n       \"      <td>0 days 00:01:30.800000</td>\\n\",\n       \"      <td>9161</td>\\n\",\n       \"      <td>1219</td>\\n\",\n       \"      <td>259.0</td>\\n\",\n       \"      <td>0</td>\\n\",\n       \"      <td>287</td>\\n\",\n       \"    </tr>\\n\",\n       \"    <tr>\\n\",\n       \"      <th>340</th>\\n\",\n       \"      <td>41</td>\\n\",\n       \"      <td>-245</td>\\n\",\n       \"      <td>188</td>\\n\",\n       \"      <td>4</td>\\n\",\n       \"      <td>0 days 00:01:30.960000</td>\\n\",\n       \"      <td>9161</td>\\n\",\n       \"      <td>1219</td>\\n\",\n       \"      <td>263.5</td>\\n\",\n       \"      <td>-1</td>\\n\",\n       \"      <td>288</td>\\n\",\n       \"    </tr>\\n\",\n       \"  </tbody>\\n\",\n       \"</table>\\n\",\n       \"<p>341 rows \u00d7 10 columns</p>\\n\",\n       \"</div>\"\n      ],\n      \"text/plain\": [\n       \"       x     y    z  driver_number                   date  session_key  \\\\\\n\",\n       \"0      0     0  188              4        0 days 00:00:00         9161   \\n\",\n       \"1    -41   253  188              4 0 days 00:00:00.340000         9161   \\n\",\n       \"2    -72   449  188              4 0 days 00:00:00.579000         9161   \\n\",\n       \"3   -106   664  188              4 0 days 00:00:00.879000         9161   \\n\",\n       \"4   -134   851  188              4 0 days 00:00:01.119000         9161   \\n\",\n       \"..   ...   ...  ...            ...                    ...          ...   \\n\",\n       \"336  129 -1067  189              4 0 days 00:01:29.779000         9161   \\n\",\n       \"337  115  -749  189              4 0 days 00:01:30.079000         9161   \\n\",\n       \"338   84  -506  188              4 0 days 00:01:30.460000         9161   \\n\",\n       \"339   56  -335  188              4 0 days 00:01:30.800000         9161   \\n\",\n       \"340   41  -245  188              4 0 days 00:01:30.960000         9161   \\n\",\n       \"\\n\",\n       \"     meeting_key  speed  dominance  segment_count  \\n\",\n       \"0           1219  134.0          0              0  \\n\",\n       \"1           1219  274.0          0              0  \\n\",\n       \"2           1219  277.5          0              0  \\n\",\n       \"3           1219  281.0          0              0  \\n\",\n       \"4           1219  285.5          0              0  \\n\",\n       \"..           ...    ...        ...            ...  \\n\",\n       \"336         1219  242.0          1            284  \\n\",\n       \"337         1219  248.5          1            285  \\n\",\n       \"338         1219  254.0          1            286  \\n\",\n       \"339         1219  259.0          0            287  \\n\",\n       \"340         1219  263.5         -1            288  \\n\",\n       \"\\n\",\n       \"[341 rows x 10 columns]\"\n      ]\n     },\n     \"execution_count\": 19,\n     \"metadata\": {},\n     \"output_type\": \"execute_result\"\n    }\n   ],\n   \"source\": [\n    \"locations[0]\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 23,\n   \"id\": \"927d93f0-12cd-4cfb-b1a6-de010b827e29\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"[0]\\n\",\n      \"[1]\\n\",\n      \"[2]\\n\",\n      \"[3]\\n\",\n      \"[4]\\n\",\n      \"[5]\\n\",\n      \"[6]\\n\",\n      \"[7]\\n\",\n      \"[8]\\n\",\n      \"[9]\\n\",\n      \"[10]\\n\",\n      \"[11]\\n\",\n      \"[12]\\n\",\n      \"[13]\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"plot_data = locations.copy()[0]\\n\",\n    \"\\n\",\n    \"current_segment = 0\\n\",\n    \"plot_data['segment'] = -1\\n\",\n    \"for i in range(plot_data.shape[0]):\\n\",\n    \"    plot_data.loc[i, 'segment'] = current_segment\\n\",\n    \"    if (i < plot_data.shape[0] - 1) and (plot_data.loc[i, 'dominance'] != plot_data.loc[i+1, 'dominance']):\\n\",\n    \"        current_segment += 1\\n\",\n    \"\\n\",\n    \"for seg in plot_data.segment.unique():\\n\",\n    \"    print(plot_data[plot_data.segment == seg].segment.unique())\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"2b07e436-1265-4420-ae25-9d4d323163fd\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": []\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 3 (ipykernel)\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.12.2\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 5\n}\n", "type": "text"}, {"name": "track dominance/track_d.py", "content": "import pandas as pd\nfrom urllib.request import urlopen\nimport json\nimport re\n\ndef api_to_df(call_type, filters):\n    call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n    for f in filters:\n        if call_str[-1] == '?':\n            call_str += f\n        else:\n            call_str += '&' + f\n\n    response = urlopen(call_str)\n    return pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\nresponses = [api_to_df('laps',['session_key='+str(selected_session_key),'driver_number='+str(d)]) for d in selected_driver_number]\n\nfastest_laps = [\n                r[(r.lap_duration == r.lap_duration.min()) &\n                  -r.duration_sector_3.isna()]\n                for r in responses]\n\ncar_data = []\nlocations = []\nfor i in range(len(fastest_laps)):\n    fastest_lap_start = fastest_laps[i].iloc[0,:].date_start\n    fastest_lap_duration = fastest_laps[i].iloc[0,:].lap_duration\n    fastest_lap_end = str(pd.to_datetime(fastest_lap_start) + pd.Timedelta(seconds=fastest_lap_duration))\n    fastest_lap_end = re.sub('\\s', 'T', fastest_lap_end)\n    #print(selected_driver_number[i])\n    #response = urlopen('https://api.openf1.org/v1/car_data?driver_number='+str(selected_driver_number[i])+'&session_key='+str(selected_session_key)+'&date>'+str(fastest_lap_start)+'&date<'+str(fastest_lap_end))\n    #car_data.append(pd.DataFrame(json.loads(response.read().decode('utf-8'))))\n    car_data_df = api_to_df('car_data',['driver_number='+str(selected_driver_number[i]),'session_key='+str(selected_session_key),'date>='+str(fastest_lap_start),'date<='+str(fastest_lap_end)])\n    car_data_df['date'] = pd.to_datetime(car_data_df.date, format='mixed') - pd.to_datetime(car_data_df.date,format='mixed').min()\n    car_data.append(car_data_df)\n\n    locations_df = api_to_df('location',['driver_number='+str(selected_driver_number[i]),'session_key='+str(selected_session_key),'date>='+str(fastest_lap_start),'date<='+str(fastest_lap_end)])\n    locations_df['date'] = pd.to_datetime(locations_df.date, format='mixed') - pd.to_datetime(locations_df.date,format='mixed').min()\n    start_x = locations_df[locations_df.date == locations_df.date.min()].x.iloc[0]\n    start_y = locations_df[locations_df.date == locations_df.date.min()].y.iloc[0]\n    locations_df['x'] = locations_df.x - start_x\n    locations_df['y'] = locations_df.y - start_y\n    locations.append(locations_df)\n\n", "type": "text"}, {"name": "backup/f1_telemetry_20230331_3.py", "content": "from shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\nfrom matplotlib import pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom urllib.request import urlopen\nfrom scipy import stats\nimport pandas as pd\nimport json\nimport re\n\n# declare variables\n# lists for drop down selections\nyears: list[str] = ['2023','2024']\nevents: list[str] = None\nsessions: list[str] = None\ndrivers: list[str] = None\n\n# selected from drop down selections\nselected_year: str = None\nselected_meeting_key: str = None\nselected_session_key: str = None\nselected_driver_number: list[str] = []\nselected_driver_colour: list[str] = [None, None]\n\n# telemetry data downloaded retrieved\ncar_data: list[pd.DataFrame] = []\nlocations: list[pd.DataFrame] = []\n\n# colours\nf1_red: str = '#E6002B'\nmain_bg_colour: str = '#111111'\ntext_colour: str = '#FFFFFF'\ntext_grey: str = '#AAAAAA'\ndefault_driver0_colour: str = f1_red # '#1b14e3'\ndefault_driver1_colour: str = text_colour\ndefault_driver_colour: str = '#ae89c4'\ntrack_border_colour: str = '#000000'\ntrack_grey: str = '#001010'\n# tracker_border_colour_driver1: str = text_colour\n\n# app layout\napp_ui: ui.page_sidebar = ui.page_sidebar(\n    ui.sidebar(\n        ui.card(\n            ui.input_selectize(\"year\",\"Year: \", choices = years, selected = '2024'),\n            ui.input_selectize(\"event\",\"Event:\", choices = [], selected = 0),\n            ui.input_selectize(\"session\",\"Session:\", choices = []),\n            ui.input_selectize('driver',\"Driver:\", choices = [], multiple = True),\n            ui.input_action_button('refresh','Refresh', class_ = 'btn-success', style = 'color:' + text_colour  + '; background:' + f1_red + 'border: 1px solid ' + text_colour),\n            height = 600,\n            style = 'color:' + text_colour + '; background:' + f1_red,\n        ),\n        ui.output_text('acknowledgement'), width = '320px',\n        bg = f1_red,\n        fg = text_colour,\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver0\"),height = 80, style = 'background:' + main_bg_colour)),\n        ui.column(6, ui.output_text(\"header\"),ui.output_text(\"sub_head\"), height = 80, style = 'text-align:center; line-height:2; font-size:1.6em; font-weight:bold; color:' + text_colour + '; background:' + main_bg_colour + '; border: 1px solid ' + f1_red),\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height = 80, style = 'background:' + main_bg_colour))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver0_throttle\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver0_brake\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver0_topspeed\"), height = 100, style = 'background:' + main_bg_colour),\n            height = 400,\n            style = 'background:' + main_bg_colour,\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver1_brake\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver1_topspeed\"), height = 100, style = 'background:' + main_bg_colour),\n            height = 400,\n            style = 'background:' + main_bg_colour\n            )\n        ),\n    ),\n    ui.row(\n        ui.output_plot('dominance'),\n        height = 250,\n    ),\n    style = 'background:' + main_bg_colour\n)\n\n# code for app functionalities\ndef server(input, output, session):\n    def get_event_name(idx: int) -> str:\n        return events.event_name[idx]\n\n    def get_driver_name(idx: int) -> str:\n        return drivers.full_name[idx]\n\n    def get_driver_name_acronym(idx: int) -> str:\n        return drivers.name_acronym[idx]\n\n    def get_driver_num(idx: int) -> str:\n        return str(drivers.driver_number[idx])\n\n    def get_session_name(idx: int) -> str:\n        return sessions.session_name[idx]\n\n    def api_call(call_type: str, filters: list[str]) -> pd.DataFrame:\n        call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n        for f in filters:\n            if call_str[-1]  ==  '?':\n                call_str  +=  f\n            else:\n                call_str  +=  '&' + f\n\n        response = urlopen(call_str)\n        return pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n    def format_driver_names(idx: int) -> str:\n        names = get_driver_name(idx).split()\n        return '\\n'.join([names[0],' '.join(names[1:])]), get_driver_name_acronym(idx)\n\n    def plot_names(front_name: str, back_name: str) -> plt.figure:\n        fig, ax = plt.subplots()\n        ax.text(0, 1, back_name, verticalalignment = 'top', horizontalalignment = 'left', color = text_grey, clip_on = False, fontstyle = 'oblique', fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 36, alpha = 0.2)\n        ax.text(1, 1, front_name, verticalalignment = 'top', horizontalalignment = 'right', color = text_colour, fontstyle = 'italic', fontfamily = 'sans-serif', fontsize = 13)\n        fig.patch.set_facecolor(main_bg_colour)\n        ax.set_facecolor(main_bg_colour)\n        ax.axis('off')\n        plt.tight_layout(pad = 0)\n        return fig\n\n    def plot_driver_metric(metric_name, idx, func, minval, maxval, display_name = None) -> plt.figure:\n        fig, ax = plt.subplots()\n\n        # plot / draw metric\n        if input.driver() !=  '' and len(car_data) > idx:\n            plot_data = car_data.copy()[idx]\n            metric = func(plot_data[[metric_name]])\n            display_name = metric_name if display_name is None else display_name\n\n            ax.barh(0.1, metric, color = str(selected_driver_colour[idx]), height = 0.1, align = 'center')\n            ax.text(maxval, 0.3, str(int(round(metric.iloc[0], 0))), verticalalignment = 'top', horizontalalignment = 'right', color = text_colour, fontstyle = 'oblique', fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 22)\n            ax.text(0, 0.3, display_name, verticalalignment = 'top', horizontalalignment = 'left', color = text_colour, fontstyle = 'oblique',fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 14)\n\n        # format driver metric plot\n        ax.axis('off')\n        ax.tick_params(axis = 'x', colors = text_colour, direction = 'in')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([])\n        ax.set_xlim(minval, maxval)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor(main_bg_colour)\n        fig.patch.set_facecolor(main_bg_colour)\n        plt.tight_layout()\n\n        return fig\n\n    # acknowledgement text\n    @render.text\n    def acknowledgement() -> str:\n        return 'Credit to the open-sourced OpenF1.org API (https://openf1.org/) for the Formula One\u00ae telemetry data used in this dashboard'\n\n    @reactive.effect\n    def update_event_list_with_year() -> None:\n        global events\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global location\n\n        selected_year = input.year()\n\n        df = api_call('meetings', ['year=' + str(selected_year)])\n\n        if df.shape[0] > 0:\n            events = pd.concat([\n                df.circuit_short_name,\n                df.location,\n                df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                df.meeting_key,],axis = 1)\\\n                .rename(columns = {'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n            ui.update_selectize(\"event\",choices = events.event_name)\n\n        else:\n            ui.update_selectize(\"event\",choices = [])\n\n            selected_year = None\n            events = None\n            selected_meeting_key = None\n\n        ui.update_selectize(\"session\",choices = [])\n        ui.update_selectize(\"driver\",choices = [])\n\n        sessions = None\n        selected_session_key = None\n        drivers = []\n        selected_driver_colour = []\n        selected_driver_number = []\n        car_data = []\n        locations = []\n\n    @render.text\n    def header() -> str:\n        if input.event():\n            event_name = get_event_name(int(input.event()))\n            return input.year() + ' ' + event_name if event_name !=  None else input.year()\n\n    @render.text\n    def sub_head() -> str:\n        if input.session():\n            session_name = get_session_name(int(input.session()))\n            return session_name if session_name !=  None else ''\n\n    @reactive.effect\n    def update_session_list_with_event() -> None:\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global car_data\n        global locations\n\n        if input.year() and input.event():\n            selected_meeting_key = events.meeting_key[int(input.event())]\n\n            df = api_call('sessions', ['year=' + str(selected_year),'meeting_key=' + str(selected_meeting_key)])\n\n            sessions = pd.concat([\n                df.session_key,\n                df.date_start,\n                df.session_type,\n                df.session_name], axis = 1)\n\n            ui.update_selectize(\"session\",choices = sessions.session_name)\n        else:\n            ui.update_selectize(\"session\",choices = [])\n\n            sessions = None\n            selected_session_key = None\n\n        ui.update_selectize(\"driver\", choices = [])\n        drivers = None\n        car_data = []\n        selected_driver_colour = []\n        selected_driver_number = []\n        locations = []\n\n    @reactive.effect\n    def update_driver_list_with_session() -> None:\n        global sessions\n        global drivers\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global locations\n\n        if len(input.session()) > 0:\n            selected_session_key = sessions.session_key[int(input.session())]\n\n            response = urlopen('https://api.openf1.org/v1/drivers?session_key=' + str(selected_session_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n            if df.shape[0] > 0:\n                try:\n                    global drivers\n\n                    drivers = pd.concat([\n                        df.driver_number,\n                        df.name_acronym,\n                        df.full_name,\n                        df.team_name,\n                        df.team_colour,\n                        df.headshot_url,\n                        df.country_code], axis = 1)\n\n                    drivers['team_name'] = drivers['team_name'].fillna('#NA')\n                    ui.update_selectize(\"driver\", choices = drivers.full_name + \" (\" + drivers.team_name + \")\")\n                except:\n                    pass\n            else:\n                ui.update_selectize(\"driver\", choices = [])\n\n                drivers = []\n\n            car_data = []\n            selected_driver_number = []\n            selected_driver_colour = []\n            locations = []\n\n    @render.plot\n    #@reactive.event(input.refresh, ignore_none = False)\n    def driver0() -> plt.figure:\n        if input.driver():\n            front_name, back_name = format_driver_names(int(input.driver()[0]))\n            return plot_names(front_name, back_name)\n\n    @render.plot\n    #@reactive.event(input.refresh, ignore_none = False)\n    def driver1() -> plt.figure:\n        if len(input.driver())  ==  2:\n            front_name, back_name = format_driver_names(int(input.driver()[1]))\n            return plot_names(front_name, back_name)\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    @reactive.event(input.refresh, ignore_none = False)\n    def update_cardata_with_driver() -> None:\n        global car_data\n        global locations\n        global selected_driver_number\n        global selected_driver_colour\n\n        if input.driver():\n            print(get_driver_num(int(input.driver()[0])), input.driver(), selected_driver_number)\n\n        # helper functions to map speed to car x, y position on track and determine which car is faster (dominant)\n        def get_speed_from_car_data(idx: int, time: pd._libs.tslibs.timedeltas.Timedelta) -> float:\n            global car_data\n            before = car_data[idx].date < time\n            after = car_data[idx].date >=  time\n            speed_before = -1 if len(car_data[idx][before].speed)  ==  0 else car_data[idx][before].speed.iloc[-1]\n            speed_after = -1 if len(car_data[idx][after].speed)  ==  0 else car_data[idx][after].speed.iloc[0]\n            return (speed_before + speed_after) / 2\n\n        # return 0 = first car is faster\n        # return 1 = second car is faster\n        # return -1 = same speed\n        def calc_dominance(x: int, y: int, speed: float) -> int:\n            global locations\n            loc1 = locations[1].copy()\n            loc1['dist'] = abs(loc1.x - x) + abs(loc1.y - y)\n            second_car_speed = loc1[loc1.dist  ==  loc1.dist.min()].speed.iloc[0]\n            if speed > second_car_speed:\n                return 0\n            elif speed < second_car_speed:\n                return 1\n            else:\n                return -1\n\n        if len(input.driver()) > 0 and len(input.driver()) <=  2:\n\n            fastest_lap_start = None\n            fastest_lap_end = None\n\n            old_driver_number = selected_driver_number\n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            selected_driver_colour = ['#' + str(drivers.team_colour[int(d)]) if drivers.team_colour[int(d)] is not None else default_driver_colour for d in input.driver()]\n\n            # if both driver/team colour are missing | if both driver/team colour are the same\n            if len(selected_driver_colour) > 1:\n                if  (selected_driver_colour[0]  ==  selected_driver_colour[1]): # or (selected_driver_colour[0] is None and selected_driver_colour[1] is None)\n                    selected_driver_colour = [default_driver0_colour, default_driver1_colour]\n\n            #print(selected_driver_number, selected_driver_colour)\n\n            #responses = [urlopen('https://api.openf1.org/v1/laps?session_key = ' + str(selected_session_key) + '&driver_number = ' + str(d)) for d in selected_driver_number]\n            #responses = [pd.DataFrame(json.loads(r.read().decode('utf-8'))) for r in responses]\n            responses = [api_call('laps',['session_key=' + str(selected_session_key),'driver_number=' + str(d)]) for d in selected_driver_number]\n\n            #[print(r.columns) for r in responses]\n            fastest_laps = [\n                r[(r.lap_duration  ==  r.lap_duration.min()) &\n                  -r.duration_sector_3.isna()]\n                for r in responses]\n            #print(fastest_laps)\n\n            car_data = []\n            locations = []\n            for i in range(len(fastest_laps)):\n                fastest_lap_start = fastest_laps[i].iloc[0,:].date_start\n                fastest_lap_duration = fastest_laps[i].iloc[0,:].lap_duration\n                fastest_lap_end = str(pd.to_datetime(fastest_lap_start) + pd.Timedelta(seconds = fastest_lap_duration))\n                fastest_lap_end = re.sub('\\\\s', 'T', fastest_lap_end)\n                #print(selected_driver_number[i])\n\n                car_data_df = api_call('car_data',['driver_number=' + str(selected_driver_number[i]),'session_key=' + str(selected_session_key),'date>=' + str(fastest_lap_start),'date<=' + str(fastest_lap_end)])\n                car_data_df['date'] = pd.to_datetime(car_data_df.date, format = 'mixed') - pd.to_datetime(car_data_df.date,format = 'mixed').min()\n                car_data.append(car_data_df)\n\n                locations_df = api_call('location',['driver_number=' + str(selected_driver_number[i]),'session_key=' + str(selected_session_key),'date>=' + str(fastest_lap_start),'date<=' + str(fastest_lap_end)])\n                locations_df['date'] = pd.to_datetime(locations_df.date, format = 'mixed') - pd.to_datetime(locations_df.date,format = 'mixed').min()\n                start_x = locations_df[locations_df.date  ==  locations_df.date.min()].x.iloc[0]\n                start_y = locations_df[locations_df.date  ==  locations_df.date.min()].y.iloc[0]\n                locations_df['x'] = locations_df.x - start_x\n                locations_df['y'] = locations_df.y - start_y\n                locations.append(locations_df)\n\n                locations[0]['colour'] = selected_driver_colour[0]\n\n            # compare if there are two cars\n            if len(locations) > 1:\n                # map speed (car_data) to x, y position (location)\n                for j in range(len(locations)):\n                    locations[j]['speed'] = -1.0\n                    for i in range(locations[j].shape[0]):\n                        time = locations[j].iloc[i,:].date\n                        #print(pt.x, pt.y, pt.date)\n                        locations[j].loc[i,'speed'] = get_speed_from_car_data(j, time)\n\n                # determine track dominance\n                locations[0]['dominance'] = -99\n                for i in range(locations[0].shape[0]):\n                    x, y, speed = locations[0].iloc[i, :].x, locations[0].iloc[i, :].y, locations[0].iloc[i, :].speed\n                    locations[0].loc[i, 'dominance'] = calc_dominance(x, y, speed)\n\n                # smooth twice\n                smooth = 12\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i + smooth, 'dominance'])[0]\n\n                smooth = 8\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i + smooth, 'dominance'])[0]\n\n\n                for i in range(locations[0].shape[0]):\n                    dominance = locations[0].loc[i, 'dominance']\n                    if dominance  ==  0:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[0]\n                    elif dominance  ==  1:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[1]\n                    else:\n                        locations[0].loc[i, 'colour'] = '#00AAAA'\n        else:\n            selected_driver_number = []\n            selected_driver_colour = []\n            car_data = []\n            locations = []\n\n\n        #[print(c.driver_number.unique()) for c in car_data]\n        # print(len(car_data), [c.shape for c in car_data])\n\n    @render_widget\n    @reactive.event(input.refresh, ignore_none = False)\n    def tele_plot() -> go.Figure:\n        fig = go.Figure()\n\n        if input.driver() !=  '' and len(car_data) > 0:\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = data.date.astype(str)\n                    #data['date'] = (pd.to_datetime(data.date, format = 'mixed') - pd.to_datetime(data.date,format = 'mixed').min()).astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace = True)\n                    data['date'] = pd.to_datetime(data.date,format = '%M:%S.%f')\n                    data.dropna(inplace = True)\n\n                    dr_mask = drivers.driver_number  ==  selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<= .[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n\n                    fig.add_trace(go.Scatter(x = data.date, y = data.speed, line = (dict(color = str(selected_driver_colour[i]))) , name = list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template = 'plotly_dark',\n            plot_bgcolor = 'black',\n            showlegend = True,\n            legend = dict(yanchor = 'bottom',y = 0.01,xanchor = 'right',x = 0.99,orientation = 'h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        fig.update_yaxes(title_text = 'Speed / mph')\n        return fig\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_throttle() -> plt.figure:\n        return plot_driver_metric('throttle', 0, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_throttle() -> plt.figure:\n        return plot_driver_metric('throttle', 1, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_brake() -> plt.figure:\n        return plot_driver_metric('brake', 0, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_brake() -> plt.figure:\n        return plot_driver_metric('brake', 1, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_topspeed() -> plt.figure:\n        return plot_driver_metric('speed', 0, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_topspeed() -> plt.figure:\n        return plot_driver_metric('speed', 1, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def dominance() -> go.Figure:\n        global locations\n\n        fig, ax = plt.subplots()\n\n        if input.driver() !=  '' and len(locations) > 0:\n            plot_data = locations.copy()[0]\n\n            # draw driver0\n            ax.plot(plot_data.x + 70, plot_data.y - 350, c = text_colour, ls = '-', lw = 10, alpha = 0.15)\n            ax.plot(plot_data.x, plot_data.y, c = track_grey, ls = '-', lw = 6)\n            ax.plot(plot_data.x, plot_data.y, c = selected_driver_colour[0], ls = '-', lw = 4)\n\n            # work out segments for drawing\n            if len(plot_data.colour.unique()) > 1:\n                current_segment = 0\n                plot_data['segment'] = -1\n                for i in range(plot_data.shape[0]):\n                    plot_data.loc[i, 'segment'] = current_segment\n                    if (i < plot_data.shape[0] - 1) and (plot_data.loc[i, 'dominance'] !=  plot_data.loc[i + 1, 'dominance']):\n                        current_segment  +=  1\n\n                # only draw driver1 dominant segments\n                plot_data_c = plot_data[plot_data.dominance  ==  1]\n                for seg in plot_data_c.segment.unique():\n                        plot_segment = plot_data_c[plot_data_c.segment  ==  seg]\n                        if plot_segment.shape[0] > 1:\n                            # ax.plot(plot_segment.x, plot_segment.y, c = tracker_border_colour_driver1, ls = '-', lw = 6)\n                            ax.plot(plot_segment.x, plot_segment.y, c = selected_driver_colour[1], ls = '-', lw = 4)\n\n            ax.plot(plot_data.x[0], plot_data.y[0], c = track_border_colour, marker = 'o', markersize = 8)\n            ax.plot(plot_data.x[0], plot_data.y[0], c = text_colour, marker = 'o', markersize = 6)\n\n        ax.axis('off')\n        ax.set_facecolor(main_bg_colour)\n\n        fig.patch.set_facecolor(main_bg_colour)\n        return fig\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "backup/f1_telemetry_20240329.py", "content": "from urllib.request import urlopen\nimport json\nimport re\n\nimport pandas as pd\nimport numpy as np\n\nfrom shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\n\nfrom htmltools import css\n\nevents = None\nsessions = None\ndrivers = None\ncar_data = []\nselected_year = None\nselected_meeting_key = None\nselected_session_key = None\nselected_driver_number = []\nselected_driver_colour = [None, None]\ndisplayed_drivers = set()\n\n\nf1_red = '#E6002B'\n\ndef get_event_name(idx):\n    if idx != '':\n        return events.event_name[int(idx)]\n\ndef get_driver_name(idx):\n    if idx != '':\n        return drivers.full_name[int(idx)]\n\ndef get_driver_num(idx):\n    if idx != '':\n        return str(drivers.driver_number[int(idx)])\n\ndef get_session_name(idx):\n    if idx != '':\n        return sessions.session_name[int(idx)]\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_selectize(\"year\",\"Year: \", choices=['2023','2024'], selected='2023'),\n        ui.input_selectize(\"event\",\"Event:\", choices=[], selected=0),\n        ui.input_selectize(\"session\",\"Session:\", choices=[]),\n        ui.input_selectize('driver',\"Driver:\", choices=[], multiple=True),\n        width = '320px',\n        bg=f1_red,\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height=100, style='background:#1e1e1e')),\n        ui.column(6, ui.card(ui.output_text(\"header\"),height=100, style='text-align:center; font-size:1.1em; font-weight:bold; color:#FFFFFF; background:#1e1e1e; border: 1px solid ' +f1_red)),\n        ui.column(3, ui.card(ui.output_plot(\"driver2\"),height=100, style='background:#1e1e1e'))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver1_brake\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e'\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver2_throttle\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver2_brake\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e'\n            )\n        ),\n    ),\n    style='background:#1e1e1e'\n)\n\ndef server(input, output, session):\n        \n    @reactive.effect\n    def event():\n        global events\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n\n        selected_year = input.year()\n\n        response = urlopen('https://api.openf1.org/v1/meetings?year='+selected_year)\n        df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n        if df.shape[0] > 0:\n            try:\n                events = pd.concat([\n                    df.circuit_short_name,\n                    df.location,\n                    df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                    df.meeting_key,],axis=1)\\\n                    .rename(columns={'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n                # events['event_name'] = np.where(events.event_name.isna(), events.circuit_short_name, events.event_name)\n\n                ui.update_selectize(\"event\",choices=events.event_name)\n                ui.update_selectize(\"session\",choices=[])\n                ui.update_selectize(\"driver\",choices=[])\n            except:\n                pass\n        else:\n            ui.update_selectize(\"event\",choices=[])\n            ui.update_selectize(\"session\",choices=[])\n            ui.update_selectize(\"driver\",choices=[])\n\n            events = None\n            sessions = None\n            drivers = []\n            selected_driver_colour = []\n            selected_year = None\n            selected_meeting_key = None\n            selected_session_key = None\n            selected_driver_number = []\n            car_data = []\n\n    @render.text\n    def header():\n        event_name = get_event_name(input.event())\n        session_name = get_session_name(input.session())\n\n        return input.year() + ' ' + event_name if event_name != None else input.year()\n\n    @reactive.effect\n    def session():\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global car_data\n\n        if input.event() != '':\n            selected_meeting_key = events.meeting_key[int(input.event())]\n        \n            response = urlopen('https://api.openf1.org/v1/sessions?year='+str(selected_year)+'&meeting_key='+str(selected_meeting_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n            \n            sessions = pd.concat([\n                df.session_key,\n                df.date_start,\n                df.session_type,\n                df.session_name], axis=1)\n\n            ui.update_selectize(\"session\",choices=sessions.session_name)\n\n        else:\n            ui.update_selectize(\"session\",choices=[])\n            ui.update_selectize(\"driver\", choices=[])\n\n            sessions = None\n            drivers = None\n            car_data = []\n            selected_driver_colour = []\n            selected_session_key = None\n            selected_driver_number = []\n\n    @reactive.effect\n    def update_driver_list_with_session():\n        global sessions\n        global drivers\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n\n        if input.session() != '':\n            selected_session_key = sessions.session_key[int(input.session())]\n            \n            response = urlopen('https://api.openf1.org/v1/drivers?session_key='+str(selected_session_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n            if df.shape[0] > 0:\n                try:\n                    global drivers\n\n                    drivers = pd.concat([\n                        df.driver_number,\n                        df.full_name,\n                        df.team_name,\n                        df.team_colour,\n                        df.headshot_url,\n                        df.country_code], axis=1)\n\n                    drivers['team_name'] = drivers['team_name'].fillna('#NA')\n                    ui.update_selectize(\"driver\", choices=drivers.full_name + \" (\" + drivers.team_name + \")\")\n                except:\n                    pass\n            else:\n                ui.update_selectize(\"driver\", choices=[])\n\n                drivers = []\n                car_data = []\n                selected_driver_number = []\n                selected_driver_colour = []\n\n    def split_driver_names(idx_list, driver1_2):\n        if len(idx_list) >= driver1_2:\n            names = get_driver_name(idx_list[driver1_2 - 1]).split()\n            return '\\n'.join(names), names[1]\n        else:\n            return 'Driver ' + str(driver1_2), str(driver1_2)\n\n    def plot_names(front_name, back_name):\n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n        ax.text(1, 1, back_name, verticalalignment='top', horizontalalignment='right', color='#aaaaaa', clip_on=False, fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=32, alpha = 0.2)\n        ax.text(1, 0, front_name, verticalalignment='bottom', horizontalalignment='right', color='#FFFFFF', fontstyle='italic', fontfamily='sans-serif', fontsize=13)\n        fig.patch.set_facecolor('#1e1e1e')\n        ax.set_facecolor('#1e1e1e')\n        ax.axis('off')\n        #plt.tight_layout(pad=0.01)\n        return fig\n\n    @render.plot\n    def driver1():\n        from matplotlib import pyplot as plt\n        front_name, back_name = split_driver_names(input.driver(),1)\n        return plot_names(front_name, back_name)\n\n    @render.plot\n    def driver2():\n        from matplotlib import pyplot as plt\n        front_name, back_name = split_driver_names(input.driver(),2)\n        return plot_names(front_name, back_name)\n\n    @render.text\n    def driver1_num():\n        return get_driver_num(input.driver()[0]) if len(input.driver()) > 0 is not None else ''\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    def update_cardata_with_driver():\n        global car_data\n        global displayed_drivers\n        global selected_driver_number\n        global selected_driver_colour\n\n        # print(input.driver())\n        if input.driver() != '' and len(input.driver()) <= 2:\n            \n            fastest_lap_start = None\n            fastest_lap_end = None\n\n            displayed_driver = input.driver()\n \n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            selected_driver_colour = [drivers.team_colour[int(d)] for d in input.driver()]\n\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['1b14e3','FFFFFF']\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = 'ae89c4'\n                if selected_driver_colour[1] is None:\n                    selected_driver_colour[1] = 'ae89c4'\n                if selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour[1] = 'ae89c4'\n            elif len(selected_driver_colour) == 1:\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = 'ae89c4'\n\n            print(selected_driver_number, selected_driver_colour)\n\n            responses = [urlopen('https://api.openf1.org/v1/laps?session_key='+str(selected_session_key)+'&driver_number='+str(d)) for d in selected_driver_number]\n            responses = [pd.DataFrame(json.loads(r.read().decode('utf-8'))) for r in responses]\n            #[print(r.columns) for r in responses]\n            fastest_laps = [\n                r[(r.lap_duration == r.lap_duration.min()) &\n                  -r.duration_sector_3.isna()]\n                for r in responses]\n            #print(fastest_laps)\n\n            car_data = []\n            for i in range(len(fastest_laps)):\n                fastest_lap_start = fastest_laps[i].iloc[0,:].date_start\n                fastest_lap_duration = fastest_laps[i].iloc[0,:].lap_duration\n                fastest_lap_end = str(pd.to_datetime(fastest_lap_start) + pd.Timedelta(seconds=fastest_lap_duration))\n                fastest_lap_end = re.sub('\\s', 'T', fastest_lap_end)\n                #print(selected_driver_number[i])\n                response = urlopen('https://api.openf1.org/v1/car_data?driver_number='+str(selected_driver_number[i])+'&session_key='+str(selected_session_key)+'&date>'+str(fastest_lap_start)+'&date<'+str(fastest_lap_end))\n                car_data.append(pd.DataFrame(json.loads(response.read().decode('utf-8'))))\n\n        else:\n            selected_driver_number = []\n            selected_driver_colour = []\n            car_data = []\n            displayed_driver = set()\n\n\n        #[print(c.driver_number.unique()) for c in car_data]\n        # print(len(car_data), [c.shape for c in car_data])\n\n    @render_widget\n    def tele_plot():\n        import plotly.express as px\n        import plotly.graph_objects as go\n        \n        fig = go.Figure()\n\n        if input.driver() != '' and len(car_data) > 0:\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = (pd.to_datetime(data.date, format='mixed') - pd.to_datetime(data.date,format='mixed').min()).astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace=True)\n                    data['date'] = pd.to_datetime(data.date,format='%M:%S.%f')\n                    data.dropna(inplace=True)\n                    \n                    dr_mask = drivers.driver_number == selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<=.[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n                    \n                    fig.add_trace(go.Scatter(x=data.date, y=data.speed, line=(dict(color='#'+str(selected_driver_colour[i]))) , name=list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template='plotly_dark',\n            plot_bgcolor='black',\n            showlegend=True,\n            legend=dict(yanchor='bottom',y=0.01,xanchor='right',x=0.99,orientation='h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        return fig\n\n    # number = index for driver in drivers\n    def driver_metric(metric_name, num):\n        from  matplotlib import pyplot as plt\n\n        fig, ax = plt.subplots()\n\n        if input.driver() != '' and len(car_data) > num:\n            plot_data = car_data.copy()[num]\n\n            #print(plot_data[['throttle']].mean(), selected_driver_colour[num])\n            mu_throttle = plot_data[[metric_name]].mean()\n            ax.barh(0.1, mu_throttle, color='#'+str(selected_driver_colour[num]), height = 0.1, align='center')\n            ax.text(100, 0.3, str(int(round(mu_throttle.iloc[0], 0))), verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontweight='bold', fontfamily='sans-serif', fontsize=22)\n            ax.text(0, 0.3, metric_name, verticalalignment='top', horizontalalignment='left', color='#FFFFFF', fontstyle='oblique',fontweight='bold', fontfamily='sans-serif', fontsize=14)\n\n\n        ax.spines['top'].set_visible(False)\n        ax.spines['left'].set_visible(False)\n        ax.spines['right'].set_visible(False)\n        ax.spines['bottom'].set_color('#FFFFFF')\n        ax.tick_params(axis='x', colors='#FFFFFF')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([0,100])\n        ax.set_xlim(0,100)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor('#1e1e1e')\n        fig.patch.set_facecolor('#1e1e1e')\n        \n        return fig\n\n    @render.plot\n    def driver1_throttle():\n        return driver_metric('throttle', 0)\n\n    @render.plot\n    def driver2_throttle():\n        return driver_metric('throttle',1)\n\n    @render.plot\n    def driver1_brake():\n        return driver_metric('brake',0)\n\n    @render.plot\n    def driver2_brake():\n        return driver_metric('brake',1)\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "backup/f1_telemetry_20240329_1.py", "content": "from urllib.request import urlopen\nimport json\nimport re\n\nimport pandas as pd\nimport numpy as np\n\nfrom shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\n\nfrom htmltools import css\n\nevents = None\nsessions = None\ndrivers = None\ncar_data = []\nselected_year = None\nselected_meeting_key = None\nselected_session_key = None\nselected_driver_number = []\nselected_driver_colour = [None, None]\ndisplayed_drivers = set()\n\n\nf1_red = '#E6002B'\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_selectize(\"year\",\"Year: \", choices=['2023','2024'], selected='2023'),\n        ui.input_selectize(\"event\",\"Event:\", choices=[], selected=0),\n        ui.input_selectize(\"session\",\"Session:\", choices=[]),\n        ui.input_selectize('driver',\"Driver:\", choices=[], multiple=True),\n        width = '320px',\n        bg=f1_red,\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height=100, style='background:#1e1e1e')),\n        ui.column(6, ui.card(ui.output_text(\"header\"),height=100, style='text-align:center; font-size:1.1em; font-weight:bold; color:#FFFFFF; background:#1e1e1e; border: 1px solid ' + f1_red)),\n        ui.column(3, ui.card(ui.output_plot(\"driver2\"),height=100, style='background:#1e1e1e'))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height=100, style='background:#1e1e1e;'),\n                ui.card(ui.output_plot(\"driver1_brake\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver1_topspeed\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e',\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver2_throttle\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver2_brake\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver2_topspeed\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e'\n            )\n        ),\n    ),\n    style='background:#1e1e1e'\n)\n\ndef server(input, output, session):\n    def get_event_name(idx):\n        if idx != '':\n            return events.event_name[int(idx)]\n\n    def get_driver_name(idx):\n        if idx != '':\n            return drivers.full_name[int(idx)]\n\n    def get_driver_num(idx):\n        if idx != '':\n            return str(drivers.driver_number[int(idx)])\n\n    def get_session_name(idx):\n        if idx != '':\n            return sessions.session_name[int(idx)]\n\n    def api_to_df(call_type, filters):\n        call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n        for f in filters:\n            if call_str[-1] == '?':\n                call_str += f\n            else:\n                call_str += '&' + f\n\n        response = urlopen(call_str)\n        return pd.DataFrame(json.loads(response.read().decode('utf-8')))\n    \n    @reactive.effect\n    def event():\n        global events\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n\n        selected_year = input.year()\n\n        #response = urlopen('https://api.openf1.org/v1/meetings?year='+selected_year)\n        #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n        df = api_to_df('meetings', ['year='+str(selected_year)])\n\n        if df.shape[0] > 0:\n            try:\n                events = pd.concat([\n                    df.circuit_short_name,\n                    df.location,\n                    df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                    df.meeting_key,],axis=1)\\\n                    .rename(columns={'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n                # events['event_name'] = np.where(events.event_name.isna(), events.circuit_short_name, events.event_name)\n\n                ui.update_selectize(\"event\",choices=events.event_name)\n                ui.update_selectize(\"session\",choices=[])\n                ui.update_selectize(\"driver\",choices=[])\n            except:\n                pass\n        else:\n            ui.update_selectize(\"event\",choices=[])\n            ui.update_selectize(\"session\",choices=[])\n            ui.update_selectize(\"driver\",choices=[])\n\n            events = None\n            sessions = None\n            drivers = []\n            selected_driver_colour = []\n            selected_year = None\n            selected_meeting_key = None\n            selected_session_key = None\n            selected_driver_number = []\n            car_data = []\n\n    @render.text\n    def header():\n        event_name = get_event_name(input.event())\n        session_name = get_session_name(input.session())\n\n        return input.year() + ' ' + event_name if event_name != None else input.year()\n\n    @reactive.effect\n    def session():\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global car_data\n\n        if input.event() != '':\n            selected_meeting_key = events.meeting_key[int(input.event())]\n        \n            #response = urlopen('https://api.openf1.org/v1/sessions?year='+str(selected_year)+'&meeting_key='+str(selected_meeting_key))\n            #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n            df = api_to_df('sessions', ['year='+str(selected_year),'meeting_key='+str(selected_meeting_key)])\n            \n            sessions = pd.concat([\n                df.session_key,\n                df.date_start,\n                df.session_type,\n                df.session_name], axis=1)\n\n            ui.update_selectize(\"session\",choices=sessions.session_name)\n\n        else:\n            ui.update_selectize(\"session\",choices=[])\n            ui.update_selectize(\"driver\", choices=[])\n\n            sessions = None\n            drivers = None\n            car_data = []\n            selected_driver_colour = []\n            selected_session_key = None\n            selected_driver_number = []\n\n    @reactive.effect\n    def update_driver_list_with_session():\n        global sessions\n        global drivers\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n\n        if input.session() != '':\n            selected_session_key = sessions.session_key[int(input.session())]\n            \n            response = urlopen('https://api.openf1.org/v1/drivers?session_key='+str(selected_session_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n            if df.shape[0] > 0:\n                try:\n                    global drivers\n\n                    drivers = pd.concat([\n                        df.driver_number,\n                        df.full_name,\n                        df.team_name,\n                        df.team_colour,\n                        df.headshot_url,\n                        df.country_code], axis=1)\n\n                    drivers['team_name'] = drivers['team_name'].fillna('#NA')\n                    ui.update_selectize(\"driver\", choices=drivers.full_name + \" (\" + drivers.team_name + \")\")\n                except:\n                    pass\n            else:\n                ui.update_selectize(\"driver\", choices=[])\n\n                drivers = []\n                car_data = []\n                selected_driver_number = []\n                selected_driver_colour = []\n\n    def split_driver_names(idx_list, driver1_2):\n        if len(idx_list) >= driver1_2:\n            names = get_driver_name(idx_list[driver1_2 - 1]).split()\n            return '\\n'.join(names), names[1]\n        else:\n            return 'Driver ' + str(driver1_2), str(driver1_2)\n\n    def plot_names(front_name, back_name):\n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n        ax.text(1, 1, back_name, verticalalignment='top', horizontalalignment='right', color='#aaaaaa', clip_on=False, fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=32, alpha = 0.2)\n        ax.text(1, 0, front_name, verticalalignment='bottom', horizontalalignment='right', color='#FFFFFF', fontstyle='italic', fontfamily='sans-serif', fontsize=13)\n        fig.patch.set_facecolor('#1e1e1e')\n        ax.set_facecolor('#1e1e1e')\n        ax.axis('off')\n        #plt.tight_layout(pad=0.01)\n        return fig\n\n    @render.plot\n    def driver1():\n        from matplotlib import pyplot as plt\n        front_name, back_name = split_driver_names(input.driver(),1)\n        return plot_names(front_name, back_name)\n\n    @render.plot\n    def driver2():\n        from matplotlib import pyplot as plt\n        front_name, back_name = split_driver_names(input.driver(),2)\n        return plot_names(front_name, back_name)\n\n    @render.text\n    def driver1_num():\n        return get_driver_num(input.driver()[0]) if len(input.driver()) > 0 is not None else ''\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    def update_cardata_with_driver():\n        global car_data\n        global displayed_drivers\n        global selected_driver_number\n        global selected_driver_colour\n\n        # print(input.driver())\n        if input.driver() != '' and len(input.driver()) <= 2:\n            \n            fastest_lap_start = None\n            fastest_lap_end = None\n\n            displayed_driver = input.driver()\n \n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            selected_driver_colour = ['#' + drivers.team_colour[int(d)] for d in input.driver()]\n\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['#1b14e3','#FFFFFF']\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n                if selected_driver_colour[1] is None:\n                    selected_driver_colour[1] = '#ae89c4'\n                if selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour[1] = '#ae89c4'\n            elif len(selected_driver_colour) == 1:\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n\n            print(selected_driver_number, selected_driver_colour)\n\n            responses = [urlopen('https://api.openf1.org/v1/laps?session_key='+str(selected_session_key)+'&driver_number='+str(d)) for d in selected_driver_number]\n            responses = [pd.DataFrame(json.loads(r.read().decode('utf-8'))) for r in responses]\n            #[print(r.columns) for r in responses]\n            fastest_laps = [\n                r[(r.lap_duration == r.lap_duration.min()) &\n                  -r.duration_sector_3.isna()]\n                for r in responses]\n            #print(fastest_laps)\n\n            car_data = []\n            for i in range(len(fastest_laps)):\n                fastest_lap_start = fastest_laps[i].iloc[0,:].date_start\n                fastest_lap_duration = fastest_laps[i].iloc[0,:].lap_duration\n                fastest_lap_end = str(pd.to_datetime(fastest_lap_start) + pd.Timedelta(seconds=fastest_lap_duration))\n                fastest_lap_end = re.sub('\\s', 'T', fastest_lap_end)\n                #print(selected_driver_number[i])\n                response = urlopen('https://api.openf1.org/v1/car_data?driver_number='+str(selected_driver_number[i])+'&session_key='+str(selected_session_key)+'&date>'+str(fastest_lap_start)+'&date<'+str(fastest_lap_end))\n                car_data.append(pd.DataFrame(json.loads(response.read().decode('utf-8'))))\n\n        else:\n            selected_driver_number = []\n            selected_driver_colour = []\n            car_data = []\n            displayed_driver = set()\n\n\n        #[print(c.driver_number.unique()) for c in car_data]\n        # print(len(car_data), [c.shape for c in car_data])\n\n    @render_widget\n    def tele_plot():\n        import plotly.express as px\n        import plotly.graph_objects as go\n        \n        fig = go.Figure()\n\n        if input.driver() != '' and len(car_data) > 0:\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = (pd.to_datetime(data.date, format='mixed') - pd.to_datetime(data.date,format='mixed').min()).astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace=True)\n                    data['date'] = pd.to_datetime(data.date,format='%M:%S.%f')\n                    data.dropna(inplace=True)\n                    \n                    dr_mask = drivers.driver_number == selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<=.[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n                    \n                    fig.add_trace(go.Scatter(x=data.date, y=data.speed, line=(dict(color=str(selected_driver_colour[i]))) , name=list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template='plotly_dark',\n            plot_bgcolor='black',\n            showlegend=True,\n            legend=dict(yanchor='bottom',y=0.01,xanchor='right',x=0.99,orientation='h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        return fig\n\n    # number = index for driver in drivers\n    def driver_metric(metric_name, num, func, minval, maxval):\n        from  matplotlib import pyplot as plt\n\n        fig, ax = plt.subplots()\n\n        if input.driver() != '' and len(car_data) > num:\n            plot_data = car_data.copy()[num]\n\n            #print(plot_data[['throttle']].mean(), selected_driver_colour[num])\n            metric = func(plot_data[[metric_name]]) #plot_data[[metric_name]].mean()\n            ax.barh(0.1, metric, color=str(selected_driver_colour[num]), height = 0.1, align='center')\n            ax.text(maxval, 0.3, str(int(round(metric.iloc[0], 0))), verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontweight='bold', fontfamily='sans-serif', fontsize=22)\n            ax.text(0, 0.3, metric_name, verticalalignment='top', horizontalalignment='left', color='#FFFFFF', fontstyle='oblique',fontweight='bold', fontfamily='sans-serif', fontsize=14)\n\n\n        ax.spines['top'].set_visible(False)\n        ax.spines['left'].set_visible(False)\n        ax.spines['right'].set_visible(False)\n        ax.spines['bottom'].set_color('#FFFFFF')\n        ax.tick_params(axis='x', colors='#FFFFFF', direction='in')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([])\n        ax.set_xlim(minval, maxval)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor('#1e1e1e')\n        fig.patch.set_facecolor('#1e1e1e')\n        plt.tight_layout()\n        \n        return fig\n\n    @render.plot\n    def driver1_throttle():\n        return driver_metric('throttle', 0, pd.Series.mean, 0, 100)\n    \n    @render.plot\n    def driver2_throttle():\n        return driver_metric('throttle', 1, pd.Series.mean, 0, 100)\n\n    @render.plot\n    def driver1_brake():\n        return driver_metric('brake', 0, pd.Series.mean, 0, 100)\n\n    @render.plot\n    def driver2_brake():\n        return driver_metric('brake', 1, pd.Series.mean, 0, 100)\n\n    @render.plot\n    def driver1_topspeed():\n        return driver_metric('speed', 0, pd.Series.max, 0, 350)\n\n    @render.plot\n    def driver2_topspeed():\n        return driver_metric('speed', 1, pd.Series.max, 0, 350)\n\n    \n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "backup/f1_telemetry_20240329_2.py", "content": "from urllib.request import urlopen\nimport json\nimport re\n\nimport pandas as pd\nimport numpy as np\n\nfrom shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\n\nevents = None\nsessions = None\ndrivers = None\ncar_data = []\nselected_year = None\nselected_meeting_key = None\nselected_session_key = None\nselected_driver_number = []\nselected_driver_colour = [None, None]\ndisplayed_drivers = set()\n\ncircuit = None\n\n\nf1_red = '#E6002B'\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_selectize(\"year\",\"Year: \", choices=['2023','2024'], selected='2023'),\n        ui.input_selectize(\"event\",\"Event:\", choices=[], selected=0),\n        ui.input_selectize(\"session\",\"Session:\", choices=[]),\n        ui.input_selectize('driver',\"Driver:\", choices=[], multiple=True),\n        width = '320px',\n        bg=f1_red,\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height=100, style='background:#1e1e1e')),\n        ui.column(6, ui.card(ui.output_text(\"header\"),height=100, style='text-align:center; font-size:1.1em; font-weight:bold; color:#FFFFFF; background:#1e1e1e; border: 1px solid ' + f1_red)),\n        ui.column(3, ui.card(ui.output_plot(\"driver2\"),height=100, style='background:#1e1e1e'))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height=100, style='background:#1e1e1e;'),\n                ui.card(ui.output_plot(\"driver1_brake\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver1_topspeed\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e',\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver2_throttle\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver2_brake\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver2_topspeed\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e'\n            )\n        ),\n    ),\n    style='background:#1e1e1e'\n)\n\ndef server(input, output, session):\n    def get_event_name(idx):\n        if idx != '':\n            return events.event_name[int(idx)]\n\n    def get_driver_name(idx):\n        if idx != '':\n            return drivers.full_name[int(idx)]\n\n    def get_driver_name_acronym(idx):\n        if idx != '':\n            return drivers.name_acronym[int(idx)]\n\n    def get_driver_num(idx):\n        if idx != '':\n            return str(drivers.driver_number[int(idx)])\n\n    def get_session_name(idx):\n        if idx != '':\n            return sessions.session_name[int(idx)]\n\n    def api_to_df(call_type, filters):\n        call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n        for f in filters:\n            if call_str[-1] == '?':\n                call_str += f\n            else:\n                call_str += '&' + f\n\n        response = urlopen(call_str)\n        return pd.DataFrame(json.loads(response.read().decode('utf-8')))\n    \n    @reactive.effect\n    def update_event_list_with_year():\n        global events\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n\n        selected_year = input.year()\n\n        #response = urlopen('https://api.openf1.org/v1/meetings?year='+selected_year)\n        #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n        df = api_to_df('meetings', ['year='+str(selected_year)])\n\n        if df.shape[0] > 0:\n            try:\n                events = pd.concat([\n                    df.circuit_short_name,\n                    df.location,\n                    df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                    df.meeting_key,],axis=1)\\\n                    .rename(columns={'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n                # events['event_name'] = np.where(events.event_name.isna(), events.circuit_short_name, events.event_name)\n\n                ui.update_selectize(\"event\",choices=events.event_name)\n                ui.update_selectize(\"session\",choices=[])\n                ui.update_selectize(\"driver\",choices=[])\n            except:\n                pass\n        else:\n            ui.update_selectize(\"event\",choices=[])\n            ui.update_selectize(\"session\",choices=[])\n            ui.update_selectize(\"driver\",choices=[])\n\n            selected_year = None\n            events = None\n            sessions = None\n            selected_meeting_key = None\n            selected_session_key = None\n\n        drivers = []\n        selected_driver_colour = []\n        selected_driver_number = []\n        car_data = []\n\n    @render.text\n    def header():\n        event_name = get_event_name(input.event())\n        session_name = get_session_name(input.session())\n\n        return input.year() + ' ' + event_name if event_name != None else input.year()\n\n    @reactive.effect\n    def update_session_list_with_event():\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global car_data\n\n        if input.event() != '':\n            selected_meeting_key = events.meeting_key[int(input.event())]\n        \n            #response = urlopen('https://api.openf1.org/v1/sessions?year='+str(selected_year)+'&meeting_key='+str(selected_meeting_key))\n            #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n            df = api_to_df('sessions', ['year='+str(selected_year),'meeting_key='+str(selected_meeting_key)])\n            \n            sessions = pd.concat([\n                df.session_key,\n                df.date_start,\n                df.session_type,\n                df.session_name], axis=1)\n\n            ui.update_selectize(\"session\",choices=sessions.session_name)\n\n        else:\n            ui.update_selectize(\"session\",choices=[])\n            ui.update_selectize(\"driver\", choices=[])\n\n            sessions = None\n            drivers = None\n            car_data = []\n            selected_driver_colour = []\n            selected_session_key = None\n            selected_driver_number = []\n\n    @reactive.effect\n    def update_driver_list_with_session():\n        global sessions\n        global drivers\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n\n        if input.session() != '':\n            selected_session_key = sessions.session_key[int(input.session())]\n            \n            response = urlopen('https://api.openf1.org/v1/drivers?session_key='+str(selected_session_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n            if df.shape[0] > 0:\n                try:\n                    global drivers\n\n                    drivers = pd.concat([\n                        df.driver_number,\n                        df.name_acronym,\n                        df.full_name,\n                        df.team_name,\n                        df.team_colour,\n                        df.headshot_url,\n                        df.country_code], axis=1)\n\n                    drivers['team_name'] = drivers['team_name'].fillna('#NA')\n                    ui.update_selectize(\"driver\", choices=drivers.full_name + \" (\" + drivers.team_name + \")\")\n                except:\n                    pass\n            else:\n                ui.update_selectize(\"driver\", choices=[])\n\n                drivers = []\n                car_data = []\n                selected_driver_number = []\n                selected_driver_colour = []\n\n    def format_driver_names(idx_list, driver1_2):\n        if len(idx_list) >= driver1_2:\n            names = get_driver_name(idx_list[driver1_2 - 1]).split()\n            return '\\n'.join(names), get_driver_name_acronym(idx_list[driver1_2-1])\n        else:\n            return 'Driver ' + str(driver1_2), str(driver1_2)\n\n    def plot_names(front_name, back_name):\n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n        ax.text(0, 1, back_name, verticalalignment='top', horizontalalignment='left', color='#aaaaaa', clip_on=False, fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=48, alpha = 0.2)\n        ax.text(1, 1, front_name, verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontstyle='italic', fontfamily='sans-serif', fontsize=13)\n        fig.patch.set_facecolor('#1e1e1e')\n        ax.set_facecolor('#1e1e1e')\n        ax.axis('off')\n        #plt.tight_layout(pad=0.01)\n        return fig\n\n    @render.plot\n    def driver1():\n        from matplotlib import pyplot as plt\n        front_name, back_name = format_driver_names(input.driver(),1)\n        return plot_names(front_name, back_name)\n\n    @render.plot\n    def driver2():\n        from matplotlib import pyplot as plt\n        front_name, back_name = format_driver_names(input.driver(),2)\n        return plot_names(front_name, back_name)\n\n    @render.text\n    def driver1_num():\n        return get_driver_num(input.driver()[0]) if len(input.driver()) > 0 is not None else ''\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    def update_cardata_with_driver():\n        global car_data\n        global displayed_drivers\n        global selected_driver_number\n        global selected_driver_colour\n\n        # print(input.driver())\n        if input.driver() != '' and len(input.driver()) <= 2:\n            \n            fastest_lap_start = None\n            fastest_lap_end = None\n\n            displayed_driver = input.driver()\n \n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            selected_driver_colour = ['#' + drivers.team_colour[int(d)] for d in input.driver()]\n\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['#1b14e3','#FFFFFF']\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n                if selected_driver_colour[1] is None:\n                    selected_driver_colour[1] = '#ae89c4'\n                if selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour[1] = '#ae89c4'\n            elif len(selected_driver_colour) == 1:\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n\n            print(selected_driver_number, selected_driver_colour)\n\n            responses = [urlopen('https://api.openf1.org/v1/laps?session_key='+str(selected_session_key)+'&driver_number='+str(d)) for d in selected_driver_number]\n            responses = [pd.DataFrame(json.loads(r.read().decode('utf-8'))) for r in responses]\n            #[print(r.columns) for r in responses]\n            fastest_laps = [\n                r[(r.lap_duration == r.lap_duration.min()) &\n                  -r.duration_sector_3.isna()]\n                for r in responses]\n            #print(fastest_laps)\n\n            car_data = []\n            for i in range(len(fastest_laps)):\n                fastest_lap_start = fastest_laps[i].iloc[0,:].date_start\n                fastest_lap_duration = fastest_laps[i].iloc[0,:].lap_duration\n                fastest_lap_end = str(pd.to_datetime(fastest_lap_start) + pd.Timedelta(seconds=fastest_lap_duration))\n                fastest_lap_end = re.sub('\\s', 'T', fastest_lap_end)\n                #print(selected_driver_number[i])\n                response = urlopen('https://api.openf1.org/v1/car_data?driver_number='+str(selected_driver_number[i])+'&session_key='+str(selected_session_key)+'&date>'+str(fastest_lap_start)+'&date<'+str(fastest_lap_end))\n                car_data.append(pd.DataFrame(json.loads(response.read().decode('utf-8'))))\n\n        else:\n            selected_driver_number = []\n            selected_driver_colour = []\n            car_data = []\n            displayed_driver = set()\n\n\n        #[print(c.driver_number.unique()) for c in car_data]\n        # print(len(car_data), [c.shape for c in car_data])\n\n    @render_widget\n    def tele_plot():\n        import plotly.express as px\n        import plotly.graph_objects as go\n        \n        fig = go.Figure()\n\n        if input.driver() != '' and len(car_data) > 0:\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = (pd.to_datetime(data.date, format='mixed') - pd.to_datetime(data.date,format='mixed').min()).astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace=True)\n                    data['date'] = pd.to_datetime(data.date,format='%M:%S.%f')\n                    data.dropna(inplace=True)\n                    \n                    dr_mask = drivers.driver_number == selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<=.[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n                    \n                    fig.add_trace(go.Scatter(x=data.date, y=data.speed, line=(dict(color=str(selected_driver_colour[i]))) , name=list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template='plotly_dark',\n            plot_bgcolor='black',\n            showlegend=True,\n            legend=dict(yanchor='bottom',y=0.01,xanchor='right',x=0.99,orientation='h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        return fig\n\n    # number = index for driver in drivers\n    def driver_metric(metric_name, num, func, minval, maxval):\n        from  matplotlib import pyplot as plt\n\n        fig, ax = plt.subplots()\n\n        if input.driver() != '' and len(car_data) > num:\n            plot_data = car_data.copy()[num]\n\n            #print(plot_data[['throttle']].mean(), selected_driver_colour[num])\n            metric = func(plot_data[[metric_name]]) #plot_data[[metric_name]].mean()\n            ax.barh(0.1, metric, color=str(selected_driver_colour[num]), height = 0.1, align='center')\n            ax.text(maxval, 0.3, str(int(round(metric.iloc[0], 0))), verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=22)\n            ax.text(0, 0.3, metric_name, verticalalignment='top', horizontalalignment='left', color='#FFFFFF', fontstyle='oblique',fontweight='bold', fontfamily='sans-serif', fontsize=14)\n\n\n        #ax.spines['top'].set_visible(False)\n        #ax.spines['left'].set_visible(False)\n        #ax.spines['right'].set_visible(False)\n        #ax.spines['bottom'].set_color('#FFFFFF')\n        ax.axis('off')\n        ax.tick_params(axis='x', colors='#FFFFFF', direction='in')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([])\n        ax.set_xlim(minval, maxval)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor('#1e1e1e')\n        fig.patch.set_facecolor('#1e1e1e')\n        plt.tight_layout()\n        \n        return fig\n\n    @render.plot\n    def driver1_throttle():\n        return driver_metric('throttle', 0, pd.Series.mean, 0, 100)\n    \n    @render.plot\n    def driver2_throttle():\n        return driver_metric('throttle', 1, pd.Series.mean, 0, 100)\n\n    @render.plot\n    def driver1_brake():\n        return driver_metric('brake', 0, pd.Series.mean, 0, 100)\n\n    @render.plot\n    def driver2_brake():\n        return driver_metric('brake', 1, pd.Series.mean, 0, 100)\n\n    @render.plot\n    def driver1_topspeed():\n        return driver_metric('speed', 0, pd.Series.max, 0, 350)\n\n    @render.plot\n    def driver2_topspeed():\n        return driver_metric('speed', 1, pd.Series.max, 0, 350)\n\n    \n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "backup/f1_telemetry_20240329_3.py", "content": "from urllib.request import urlopen\nimport json\nimport re\n\nimport pandas as pd\nimport numpy as np\n\nfrom shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\n\n\nevents = None\nsessions = None\ndrivers = None\ncar_data = []\nselected_year = None\nselected_meeting_key = None\nselected_session_key = None\nselected_driver_number = []\nselected_driver_colour = [None, None]\ndisplayed_drivers = set()\n\ncircuit = None\n\n\nf1_red = '#E6002B'\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_selectize(\"year\",\"Year: \", choices=['2023','2024'], selected='2023'),\n        ui.input_selectize(\"event\",\"Event:\", choices=[], selected=0),\n        ui.input_selectize(\"session\",\"Session:\", choices=[]),\n        ui.input_selectize('driver',\"Driver:\", choices=[], multiple=True),\n        width = '320px',\n        bg=f1_red,\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height=100, style='background:#1e1e1e')),\n        ui.column(6, ui.card(ui.output_text(\"header\"),height=100, style='text-align:center; font-size:1.1em; font-weight:bold; color:#FFFFFF; background:#1e1e1e; border: 1px solid ' + f1_red)),\n        ui.column(3, ui.card(ui.output_plot(\"driver2\"),height=100, style='background:#1e1e1e'))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height=100, style='background:#1e1e1e;'),\n                ui.card(ui.output_plot(\"driver1_brake\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver1_topspeed\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e',\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver2_throttle\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver2_brake\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver2_topspeed\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e'\n            )\n        ),\n    ),\n    style='background:#1e1e1e'\n)\n\ndef server(input, output, session):\n    def get_event_name(idx):\n        if idx != '':\n            return events.event_name[int(idx)]\n\n    def get_driver_name(idx):\n        if idx != '':\n            return drivers.full_name[int(idx)]\n\n    def get_driver_name_acronym(idx):\n        if idx != '':\n            return drivers.name_acronym[int(idx)]\n\n    def get_driver_num(idx):\n        if idx != '':\n            return str(drivers.driver_number[int(idx)])\n\n    def get_session_name(idx):\n        if idx != '':\n            return sessions.session_name[int(idx)]\n\n    def api_to_df(call_type, filters):\n        call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n        for f in filters:\n            if call_str[-1] == '?':\n                call_str += f\n            else:\n                call_str += '&' + f\n\n        response = urlopen(call_str)\n        return pd.DataFrame(json.loads(response.read().decode('utf-8')))\n    \n    @reactive.effect\n    def update_event_list_with_year():\n        global events\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n\n        selected_year = input.year()\n\n        #response = urlopen('https://api.openf1.org/v1/meetings?year='+selected_year)\n        #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n        df = api_to_df('meetings', ['year='+str(selected_year)])\n\n        if df.shape[0] > 0:\n            try:\n                events = pd.concat([\n                    df.circuit_short_name,\n                    df.location,\n                    df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                    df.meeting_key,],axis=1)\\\n                    .rename(columns={'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n                # events['event_name'] = np.where(events.event_name.isna(), events.circuit_short_name, events.event_name)\n\n                ui.update_selectize(\"event\",choices=events.event_name)\n                ui.update_selectize(\"session\",choices=[])\n                ui.update_selectize(\"driver\",choices=[])\n            except:\n                pass\n        else:\n            ui.update_selectize(\"event\",choices=[])\n            ui.update_selectize(\"session\",choices=[])\n            ui.update_selectize(\"driver\",choices=[])\n\n            selected_year = None\n            events = None\n            sessions = None\n            selected_meeting_key = None\n            selected_session_key = None\n\n        drivers = []\n        selected_driver_colour = []\n        selected_driver_number = []\n        car_data = []\n\n    @render.text\n    def header():\n        event_name = get_event_name(input.event())\n        session_name = get_session_name(input.session())\n\n        return input.year() + ' ' + event_name if event_name != None else input.year()\n\n    @reactive.effect\n    def update_session_list_with_event():\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global car_data\n\n        if input.event() != '':\n            selected_meeting_key = events.meeting_key[int(input.event())]\n        \n            #response = urlopen('https://api.openf1.org/v1/sessions?year='+str(selected_year)+'&meeting_key='+str(selected_meeting_key))\n            #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n            df = api_to_df('sessions', ['year='+str(selected_year),'meeting_key='+str(selected_meeting_key)])\n            \n            sessions = pd.concat([\n                df.session_key,\n                df.date_start,\n                df.session_type,\n                df.session_name], axis=1)\n\n            ui.update_selectize(\"session\",choices=sessions.session_name)\n\n        else:\n            ui.update_selectize(\"session\",choices=[])\n            ui.update_selectize(\"driver\", choices=[])\n\n            sessions = None\n            drivers = None\n            car_data = []\n            selected_driver_colour = []\n            selected_session_key = None\n            selected_driver_number = []\n\n    @reactive.effect\n    def update_driver_list_with_session():\n        global sessions\n        global drivers\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n\n        if input.session() != '':\n            selected_session_key = sessions.session_key[int(input.session())]\n            \n            response = urlopen('https://api.openf1.org/v1/drivers?session_key='+str(selected_session_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n            if df.shape[0] > 0:\n                try:\n                    global drivers\n\n                    drivers = pd.concat([\n                        df.driver_number,\n                        df.name_acronym,\n                        df.full_name,\n                        df.team_name,\n                        df.team_colour,\n                        df.headshot_url,\n                        df.country_code], axis=1)\n\n                    drivers['team_name'] = drivers['team_name'].fillna('#NA')\n                    ui.update_selectize(\"driver\", choices=drivers.full_name + \" (\" + drivers.team_name + \")\")\n                except:\n                    pass\n            else:\n                ui.update_selectize(\"driver\", choices=[])\n\n                drivers = []\n                car_data = []\n                selected_driver_number = []\n                selected_driver_colour = []\n\n    def format_driver_names(idx_list, driver1_2):\n        if len(idx_list) >= driver1_2:\n            names = get_driver_name(idx_list[driver1_2 - 1]).split()\n            return '\\n'.join(names), get_driver_name_acronym(idx_list[driver1_2-1])\n        else:\n            return 'Driver ' + str(driver1_2), str(driver1_2)\n\n    def plot_names(front_name, back_name):\n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n        ax.text(0, 1, back_name, verticalalignment='top', horizontalalignment='left', color='#aaaaaa', clip_on=False, fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=48, alpha = 0.2)\n        ax.text(1, 1, front_name, verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontstyle='italic', fontfamily='sans-serif', fontsize=13)\n        fig.patch.set_facecolor('#1e1e1e')\n        ax.set_facecolor('#1e1e1e')\n        ax.axis('off')\n        #plt.tight_layout(pad=0.01)\n        return fig\n\n    @render.plot\n    def driver1():\n        from matplotlib import pyplot as plt\n        front_name, back_name = format_driver_names(input.driver(),1)\n        return plot_names(front_name, back_name)\n\n    @render.plot\n    def driver2():\n        from matplotlib import pyplot as plt\n        front_name, back_name = format_driver_names(input.driver(),2)\n        return plot_names(front_name, back_name)\n\n    @render.text\n    def driver1_num():\n        return get_driver_num(input.driver()[0]) if len(input.driver()) > 0 is not None else ''\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    def update_cardata_with_driver():\n        global car_data\n        global displayed_drivers\n        global selected_driver_number\n        global selected_driver_colour\n\n        # print(input.driver())\n        if input.driver() != '' and len(input.driver()) <= 2:\n            \n            fastest_lap_start = None\n            fastest_lap_end = None\n\n            displayed_driver = input.driver()\n \n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            selected_driver_colour = ['#' + drivers.team_colour[int(d)] if drivers.team_colour[int(d)] is not None else '#ae89c4' for d in input.driver()]\n\n            # if both driver/team colour are missing | if both driver/team colour are the same\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['#1b14e3','#FFFFFF']\n                elif selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour = [f1_red, '#FFFFFF']\n            '''\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['#1b14e3','#FFFFFF']\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n                if selected_driver_colour[1] is None:\n                    selected_driver_colour[1] = '#ae89c4'\n                if selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour[1] = '#ae89c4'\n            elif len(selected_driver_colour) == 1:\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n            '''\n                            \n\n            print(selected_driver_number, selected_driver_colour)\n\n            #responses = [urlopen('https://api.openf1.org/v1/laps?session_key='+str(selected_session_key)+'&driver_number='+str(d)) for d in selected_driver_number]\n            #responses = [pd.DataFrame(json.loads(r.read().decode('utf-8'))) for r in responses]\n            responses = [api_to_df('laps',['session_key='+str(selected_session_key),'driver_number='+str(d)]) for d in selected_driver_number]\n            #[print(r.columns) for r in responses]\n            fastest_laps = [\n                r[(r.lap_duration == r.lap_duration.min()) &\n                  -r.duration_sector_3.isna()]\n                for r in responses]\n            #print(fastest_laps)\n\n            car_data = []\n            for i in range(len(fastest_laps)):\n                fastest_lap_start = fastest_laps[i].iloc[0,:].date_start\n                fastest_lap_duration = fastest_laps[i].iloc[0,:].lap_duration\n                fastest_lap_end = str(pd.to_datetime(fastest_lap_start) + pd.Timedelta(seconds=fastest_lap_duration))\n                fastest_lap_end = re.sub('\\s', 'T', fastest_lap_end)\n                #print(selected_driver_number[i])\n                response = urlopen('https://api.openf1.org/v1/car_data?driver_number='+str(selected_driver_number[i])+'&session_key='+str(selected_session_key)+'&date>'+str(fastest_lap_start)+'&date<'+str(fastest_lap_end))\n                car_data.append(pd.DataFrame(json.loads(response.read().decode('utf-8'))))\n\n        else:\n            selected_driver_number = []\n            selected_driver_colour = []\n            car_data = []\n            displayed_driver = set()\n\n\n        #[print(c.driver_number.unique()) for c in car_data]\n        # print(len(car_data), [c.shape for c in car_data])\n\n    @render_widget\n    def tele_plot():\n        import plotly.express as px\n        import plotly.graph_objects as go\n        \n        fig = go.Figure()\n\n        if input.driver() != '' and len(car_data) > 0:\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = (pd.to_datetime(data.date, format='mixed') - pd.to_datetime(data.date,format='mixed').min()).astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace=True)\n                    data['date'] = pd.to_datetime(data.date,format='%M:%S.%f')\n                    data.dropna(inplace=True)\n                    \n                    dr_mask = drivers.driver_number == selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<=.[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n                    \n                    fig.add_trace(go.Scatter(x=data.date, y=data.speed, line=(dict(color=str(selected_driver_colour[i]))) , name=list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template='plotly_dark',\n            plot_bgcolor='black',\n            showlegend=True,\n            legend=dict(yanchor='bottom',y=0.01,xanchor='right',x=0.99,orientation='h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        return fig\n\n    # number = index for driver in drivers\n    def driver_metric(metric_name, num, func, minval, maxval):\n        from  matplotlib import pyplot as plt\n\n        fig, ax = plt.subplots()\n\n        if input.driver() != '' and len(car_data) > num:\n            plot_data = car_data.copy()[num]\n\n            #print(plot_data[['throttle']].mean(), selected_driver_colour[num])\n            metric = func(plot_data[[metric_name]]) #plot_data[[metric_name]].mean()\n            ax.barh(0.1, metric, color=str(selected_driver_colour[num]), height = 0.1, align='center')\n            ax.text(maxval, 0.3, str(int(round(metric.iloc[0], 0))), verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=22)\n            ax.text(0, 0.3, metric_name, verticalalignment='top', horizontalalignment='left', color='#FFFFFF', fontstyle='oblique',fontweight='bold', fontfamily='sans-serif', fontsize=14)\n\n\n        #ax.spines['top'].set_visible(False)\n        #ax.spines['left'].set_visible(False)\n        #ax.spines['right'].set_visible(False)\n        #ax.spines['bottom'].set_color('#FFFFFF')\n        ax.axis('off')\n        ax.tick_params(axis='x', colors='#FFFFFF', direction='in')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([])\n        ax.set_xlim(minval, maxval)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor('#1e1e1e')\n        fig.patch.set_facecolor('#1e1e1e')\n        plt.tight_layout()\n        \n        return fig\n\n    @render.plot\n    def driver1_throttle():\n        return driver_metric('throttle', 0, pd.Series.mean, 0, 100)\n    \n    @render.plot\n    def driver2_throttle():\n        return driver_metric('throttle', 1, pd.Series.mean, 0, 100)\n\n    @render.plot\n    def driver1_brake():\n        return driver_metric('brake', 0, pd.Series.mean, 0, 100)\n\n    @render.plot\n    def driver2_brake():\n        return driver_metric('brake', 1, pd.Series.mean, 0, 100)\n\n    @render.plot\n    def driver1_topspeed():\n        return driver_metric('speed', 0, pd.Series.max, 0, 350)\n\n    @render.plot\n    def driver2_topspeed():\n        return driver_metric('speed', 1, pd.Series.max, 0, 350)\n\n    \n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "backup/f1_telemetry_20240329_4.py", "content": "from urllib.request import urlopen\nimport json\nimport re\n\nimport pandas as pd\nimport numpy as np\n\nfrom shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\n\n\nevents = None\nsessions = None\ndrivers = None\ncar_data = []\nselected_year = None\nselected_meeting_key = None\nselected_session_key = None\nselected_driver_number = []\nselected_driver_colour = [None, None]\n\nlocations = []\n\n\nf1_red = '#E6002B'\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_selectize(\"year\",\"Year: \", choices=['2023','2024'], selected='2023'),\n        ui.input_selectize(\"event\",\"Event:\", choices=[], selected=0),\n        ui.input_selectize(\"session\",\"Session:\", choices=[]),\n        ui.input_selectize('driver',\"Driver:\", choices=[], multiple=True),\n        width = '320px',\n        bg=f1_red,\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height=100, style='background:#1e1e1e')),\n        ui.column(6, ui.card(ui.output_text(\"header\"),height=100, style='text-align:center; font-size:1.1em; font-weight:bold; color:#FFFFFF; background:#1e1e1e; border: 1px solid ' + f1_red)),\n        ui.column(3, ui.card(ui.output_plot(\"driver2\"),height=100, style='background:#1e1e1e'))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height=100, style='background:#1e1e1e;'),\n                ui.card(ui.output_plot(\"driver1_brake\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver1_topspeed\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e',\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver2_throttle\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver2_brake\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver2_topspeed\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e'\n            )\n        ),\n    ),\n    ui.row(\n        ui.output_plot('dominance'),\n    ),\n    style='background:#1e1e1e'\n)\n\ndef server(input, output, session):\n    def get_event_name(idx):\n        if idx != '':\n            return events.event_name[int(idx)]\n\n    def get_driver_name(idx):\n        if idx != '':\n            return drivers.full_name[int(idx)]\n\n    def get_driver_name_acronym(idx):\n        if idx != '':\n            return drivers.name_acronym[int(idx)]\n\n    def get_driver_num(idx):\n        if idx != '':\n            return str(drivers.driver_number[int(idx)])\n\n    def get_session_name(idx):\n        if idx != '':\n            return sessions.session_name[int(idx)]\n\n    def api_to_df(call_type, filters):\n        call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n        for f in filters:\n            if call_str[-1] == '?':\n                call_str += f\n            else:\n                call_str += '&' + f\n\n        response = urlopen(call_str)\n        return pd.DataFrame(json.loads(response.read().decode('utf-8')))\n    \n    @reactive.effect\n    def update_event_list_with_year():\n        global events\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global location\n\n        selected_year = input.year()\n\n        #response = urlopen('https://api.openf1.org/v1/meetings?year='+selected_year)\n        #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n        df = api_to_df('meetings', ['year='+str(selected_year)])\n\n        if df.shape[0] > 0:\n            try:\n                events = pd.concat([\n                    df.circuit_short_name,\n                    df.location,\n                    df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                    df.meeting_key,],axis=1)\\\n                    .rename(columns={'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n                # events['event_name'] = np.where(events.event_name.isna(), events.circuit_short_name, events.event_name)\n\n                ui.update_selectize(\"event\",choices=events.event_name)\n                ui.update_selectize(\"session\",choices=[])\n                ui.update_selectize(\"driver\",choices=[])\n            except:\n                pass\n        else:\n            ui.update_selectize(\"event\",choices=[])\n            ui.update_selectize(\"session\",choices=[])\n            ui.update_selectize(\"driver\",choices=[])\n\n            selected_year = None\n            events = None\n            sessions = None\n            selected_meeting_key = None\n            selected_session_key = None\n\n        drivers = []\n        selected_driver_colour = []\n        selected_driver_number = []\n        car_data = []\n        locations = []\n\n    @render.text\n    def header():\n        event_name = get_event_name(input.event())\n        session_name = get_session_name(input.session())\n\n        return input.year() + ' ' + event_name if event_name != None else input.year()\n\n    @reactive.effect\n    def update_session_list_with_event():\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global car_data\n        global locations\n\n        if input.event() != '':\n            selected_meeting_key = events.meeting_key[int(input.event())]\n        \n            #response = urlopen('https://api.openf1.org/v1/sessions?year='+str(selected_year)+'&meeting_key='+str(selected_meeting_key))\n            #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n            df = api_to_df('sessions', ['year='+str(selected_year),'meeting_key='+str(selected_meeting_key)])\n            \n            sessions = pd.concat([\n                df.session_key,\n                df.date_start,\n                df.session_type,\n                df.session_name], axis=1)\n\n            ui.update_selectize(\"session\",choices=sessions.session_name)\n\n        else:\n            ui.update_selectize(\"session\",choices=[])\n            ui.update_selectize(\"driver\", choices=[])\n\n            sessions = None\n            selected_session_key = None\n\n        drivers = None\n        car_data = []\n        selected_driver_colour = []            \n        selected_driver_number = []\n        locations = []\n\n    @reactive.effect\n    def update_driver_list_with_session():\n        global sessions\n        global drivers\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global locations\n\n        if input.session() != '':\n            selected_session_key = sessions.session_key[int(input.session())]\n            \n            response = urlopen('https://api.openf1.org/v1/drivers?session_key='+str(selected_session_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n            if df.shape[0] > 0:\n                try:\n                    global drivers\n\n                    drivers = pd.concat([\n                        df.driver_number,\n                        df.name_acronym,\n                        df.full_name,\n                        df.team_name,\n                        df.team_colour,\n                        df.headshot_url,\n                        df.country_code], axis=1)\n\n                    drivers['team_name'] = drivers['team_name'].fillna('#NA')\n                    ui.update_selectize(\"driver\", choices=drivers.full_name + \" (\" + drivers.team_name + \")\")\n                except:\n                    pass\n            else:\n                ui.update_selectize(\"driver\", choices=[])\n\n                drivers = []\n\n            car_data = []\n            selected_driver_number = []\n            selected_driver_colour = []\n            locations = []\n\n    def format_driver_names(idx_list, driver1_2):\n        if len(idx_list) >= driver1_2:\n            names = get_driver_name(idx_list[driver1_2 - 1]).split()\n            return '\\n'.join(names), get_driver_name_acronym(idx_list[driver1_2-1])\n        else:\n            return 'Driver ' + str(driver1_2), str(driver1_2)\n\n    def plot_names(front_name, back_name):\n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n        ax.text(0, 1, back_name, verticalalignment='top', horizontalalignment='left', color='#aaaaaa', clip_on=False, fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=48, alpha = 0.2)\n        ax.text(1, 1, front_name, verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontstyle='italic', fontfamily='sans-serif', fontsize=13)\n        fig.patch.set_facecolor('#1e1e1e')\n        ax.set_facecolor('#1e1e1e')\n        ax.axis('off')\n        #plt.tight_layout(pad=0.01)\n        return fig\n\n    @render.plot\n    def driver1():\n        from matplotlib import pyplot as plt\n        front_name, back_name = format_driver_names(input.driver(),1)\n        return plot_names(front_name, back_name)\n\n    @render.plot\n    def driver2():\n        from matplotlib import pyplot as plt\n        front_name, back_name = format_driver_names(input.driver(),2)\n        return plot_names(front_name, back_name)\n\n    @render.text\n    def driver1_num():\n        return get_driver_num(input.driver()[0]) if len(input.driver()) > 0 is not None else ''\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    def update_cardata_with_driver():\n        global car_data\n        global locations\n        global selected_driver_number\n        global selected_driver_colour\n\n        # print(input.driver())\n        if input.driver() != '' and len(input.driver()) <= 2:\n            \n            fastest_lap_start = None\n            fastest_lap_end = None\n \n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            selected_driver_colour = ['#' + drivers.team_colour[int(d)] if drivers.team_colour[int(d)] is not None else '#ae89c4' for d in input.driver()]\n\n            # if both driver/team colour are missing | if both driver/team colour are the same\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['#1b14e3','#FFFFFF']\n                elif selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour = [f1_red, '#FFFFFF']\n            '''\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['#1b14e3','#FFFFFF']\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n                if selected_driver_colour[1] is None:\n                    selected_driver_colour[1] = '#ae89c4'\n                if selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour[1] = '#ae89c4'\n            elif len(selected_driver_colour) == 1:\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n            '''\n                            \n\n            #print(selected_driver_number, selected_driver_colour)\n\n            #responses = [urlopen('https://api.openf1.org/v1/laps?session_key='+str(selected_session_key)+'&driver_number='+str(d)) for d in selected_driver_number]\n            #responses = [pd.DataFrame(json.loads(r.read().decode('utf-8'))) for r in responses]\n            responses = [api_to_df('laps',['session_key='+str(selected_session_key),'driver_number='+str(d)]) for d in selected_driver_number]\n\n            #[print(r.columns) for r in responses]\n            fastest_laps = [\n                r[(r.lap_duration == r.lap_duration.min()) &\n                  -r.duration_sector_3.isna()]\n                for r in responses]\n            #print(fastest_laps)\n\n            car_data = []\n            location = []\n            for i in range(len(fastest_laps)):\n                fastest_lap_start = fastest_laps[i].iloc[0,:].date_start\n                fastest_lap_duration = fastest_laps[i].iloc[0,:].lap_duration\n                fastest_lap_end = str(pd.to_datetime(fastest_lap_start) + pd.Timedelta(seconds=fastest_lap_duration))\n                fastest_lap_end = re.sub('\\s', 'T', fastest_lap_end)\n                #print(selected_driver_number[i])\n                #response = urlopen('https://api.openf1.org/v1/car_data?driver_number='+str(selected_driver_number[i])+'&session_key='+str(selected_session_key)+'&date>'+str(fastest_lap_start)+'&date<'+str(fastest_lap_end))\n                #car_data.append(pd.DataFrame(json.loads(response.read().decode('utf-8'))))\n                car_data.append(api_to_df('car_data',['driver_number='+str(selected_driver_number[i]),'session_key='+str(selected_session_key),'date>='+str(fastest_lap_start),'date<='+str(fastest_lap_end)]))\n                locations.append(api_to_df('location',['driver_number='+str(selected_driver_number[i]),'session_key='+str(selected_session_key),'date>='+str(fastest_lap_start),'date<='+str(fastest_lap_end)]))\n                \n        else:\n            selected_driver_number = []\n            selected_driver_colour = []\n            car_data = []\n            locations = []\n\n\n\n        #[print(c.driver_number.unique()) for c in car_data]\n        # print(len(car_data), [c.shape for c in car_data])\n\n    @render_widget\n    def tele_plot():\n        import plotly.express as px\n        import plotly.graph_objects as go\n        \n        fig = go.Figure()\n\n        if input.driver() != '' and len(car_data) > 0:\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = (pd.to_datetime(data.date, format='mixed') - pd.to_datetime(data.date,format='mixed').min()).astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace=True)\n                    data['date'] = pd.to_datetime(data.date,format='%M:%S.%f')\n                    data.dropna(inplace=True)\n                    \n                    dr_mask = drivers.driver_number == selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<=.[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n                    \n                    fig.add_trace(go.Scatter(x=data.date, y=data.speed, line=(dict(color=str(selected_driver_colour[i]))) , name=list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template='plotly_dark',\n            plot_bgcolor='black',\n            showlegend=True,\n            legend=dict(yanchor='bottom',y=0.01,xanchor='right',x=0.99,orientation='h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        return fig\n\n    # number = index for driver in drivers\n    def driver_metric(metric_name, num, func, minval, maxval, display_name = None):\n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n\n        if input.driver() != '' and len(car_data) > num:\n            plot_data = car_data.copy()[num]\n\n            #print(plot_data[['throttle']].mean(), selected_driver_colour[num])\n            metric = func(plot_data[[metric_name]]) #plot_data[[metric_name]].mean()\n            ax.barh(0.1, metric, color=str(selected_driver_colour[num]), height = 0.1, align='center')\n            ax.text(maxval, 0.3, str(int(round(metric.iloc[0], 0))), verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=22)\n            display_name = metric_name if display_name is None else display_name\n            ax.text(0, 0.3, display_name, verticalalignment='top', horizontalalignment='left', color='#FFFFFF', fontstyle='oblique',fontweight='bold', fontfamily='sans-serif', fontsize=14)\n\n\n        #ax.spines['top'].set_visible(False)\n        #ax.spines['left'].set_visible(False)\n        #ax.spines['right'].set_visible(False)\n        #ax.spines['bottom'].set_color('#FFFFFF')\n        ax.axis('off')\n        ax.tick_params(axis='x', colors='#FFFFFF', direction='in')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([])\n        ax.set_xlim(minval, maxval)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor('#1e1e1e')\n        fig.patch.set_facecolor('#1e1e1e')\n        plt.tight_layout()\n        \n        return fig\n\n    @render.plot\n    def driver1_throttle():\n        return driver_metric('throttle', 0, pd.Series.mean, 0, 100, 'Throttle')\n    \n    @render.plot\n    def driver2_throttle():\n        return driver_metric('throttle', 1, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    def driver1_brake():\n        return driver_metric('brake', 0, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    def driver2_brake():\n        return driver_metric('brake', 1, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    def driver1_topspeed():\n        return driver_metric('speed', 0, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    def driver2_topspeed():\n        return driver_metric('speed', 1, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    def dominance():\n        global locations\n        \n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n\n        if input.driver() != '' and len(locations) > 0:\n            plot_data = locations.copy()[0]\n            ax.scatter(plot_data.x, plot_data.y)\n\n        return fig\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "backup/f1_telemetry_20240329_5.py", "content": "from urllib.request import urlopen\nimport json\nimport re\n\nimport pandas as pd\nimport numpy as np\n\nfrom shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\n\n\nevents = None\nsessions = None\ndrivers = None\ncar_data = []\nselected_year = None\nselected_meeting_key = None\nselected_session_key = None\nselected_driver_number = []\nselected_driver_colour = [None, None]\n\nlocations = []\n\n\nf1_red = '#E6002B'\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_selectize(\"year\",\"Year: \", choices=['2023','2024'], selected='2023'),\n        ui.input_selectize(\"event\",\"Event:\", choices=[], selected=0),\n        ui.input_selectize(\"session\",\"Session:\", choices=[]),\n        ui.input_selectize('driver',\"Driver:\", choices=[], multiple=True),\n        width = '320px',\n        bg=f1_red,\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver0\"),height=100, style='background:#1e1e1e')),\n        ui.column(6, ui.card(ui.output_text(\"header\"),height=100, style='text-align:center; font-size:1.1em; font-weight:bold; color:#FFFFFF; background:#1e1e1e; border: 1px solid ' + f1_red)),\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height=100, style='background:#1e1e1e'))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver0_throttle\"), height=100, style='background:#1e1e1e;'),\n                ui.card(ui.output_plot(\"driver0_brake\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver0_topspeed\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e',\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver1_brake\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver1_topspeed\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e'\n            )\n        ),\n    ),\n    ui.row(\n        ui.output_plot('dominance'),\n    ),\n    style='background:#1e1e1e'\n)\n\ndef server(input, output, session):\n    def get_event_name(idx):\n        if idx != '':\n            return events.event_name[int(idx)]\n\n    def get_driver_name(idx):\n        if idx != '':\n            return drivers.full_name[int(idx)]\n\n    def get_driver_name_acronym(idx):\n        if idx != '':\n            return drivers.name_acronym[int(idx)]\n\n    def get_driver_num(idx):\n        if idx != '':\n            return str(drivers.driver_number[int(idx)])\n\n    def get_session_name(idx):\n        if idx != '':\n            return sessions.session_name[int(idx)]\n\n    def api_to_df(call_type, filters):\n        call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n        for f in filters:\n            if call_str[-1] == '?':\n                call_str += f\n            else:\n                call_str += '&' + f\n\n        response = urlopen(call_str)\n        return pd.DataFrame(json.loads(response.read().decode('utf-8')))\n    \n    @reactive.effect\n    def update_event_list_with_year():\n        global events\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global location\n\n        selected_year = input.year()\n\n        #response = urlopen('https://api.openf1.org/v1/meetings?year='+selected_year)\n        #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n        df = api_to_df('meetings', ['year='+str(selected_year)])\n\n        if df.shape[0] > 0:\n            try:\n                events = pd.concat([\n                    df.circuit_short_name,\n                    df.location,\n                    df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                    df.meeting_key,],axis=1)\\\n                    .rename(columns={'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n                # events['event_name'] = np.where(events.event_name.isna(), events.circuit_short_name, events.event_name)\n\n                ui.update_selectize(\"event\",choices=events.event_name)\n\n            except:\n                pass\n        else:\n            ui.update_selectize(\"event\",choices=[])\n            \n            selected_year = None\n            events = None\n            selected_meeting_key = None\n\n        ui.update_selectize(\"session\",choices=[])\n        ui.update_selectize(\"driver\",choices=[])\n        \n        sessions = None\n        selected_session_key = None\n        drivers = []\n        selected_driver_colour = []\n        selected_driver_number = []\n        car_data = []\n        locations = []\n\n    @render.text\n    def header():\n        event_name = get_event_name(input.event())\n        session_name = get_session_name(input.session())\n\n        return input.year() + ' ' + event_name if event_name != None else input.year()\n\n    @reactive.effect\n    def update_session_list_with_event():\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global car_data\n        global locations\n\n        if len(input.event()) > 0:\n            selected_meeting_key = events.meeting_key[int(input.event())]\n        \n            #response = urlopen('https://api.openf1.org/v1/sessions?year='+str(selected_year)+'&meeting_key='+str(selected_meeting_key))\n            #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n            df = api_to_df('sessions', ['year='+str(selected_year),'meeting_key='+str(selected_meeting_key)])\n            \n            sessions = pd.concat([\n                df.session_key,\n                df.date_start,\n                df.session_type,\n                df.session_name], axis=1)\n\n            ui.update_selectize(\"session\",choices=sessions.session_name)\n        else:\n            ui.update_selectize(\"session\",choices=[])\n\n            sessions = None\n            selected_session_key = None\n\n        ui.update_selectize(\"driver\", choices=[])\n        drivers = None\n        car_data = []\n        selected_driver_colour = []            \n        selected_driver_number = []\n        locations = []\n\n    @reactive.effect\n    def update_driver_list_with_session():\n        global sessions\n        global drivers\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global locations\n\n        if len(input.session()) > 0:\n            selected_session_key = sessions.session_key[int(input.session())]\n            \n            response = urlopen('https://api.openf1.org/v1/drivers?session_key='+str(selected_session_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n            if df.shape[0] > 0:\n                try:\n                    global drivers\n\n                    drivers = pd.concat([\n                        df.driver_number,\n                        df.name_acronym,\n                        df.full_name,\n                        df.team_name,\n                        df.team_colour,\n                        df.headshot_url,\n                        df.country_code], axis=1)\n\n                    drivers['team_name'] = drivers['team_name'].fillna('#NA')\n                    ui.update_selectize(\"driver\", choices=drivers.full_name + \" (\" + drivers.team_name + \")\")\n                except:\n                    pass\n            else:\n                ui.update_selectize(\"driver\", choices=[])\n\n                drivers = []\n\n            car_data = []\n            selected_driver_number = []\n            selected_driver_colour = []\n            locations = []\n\n    def format_driver_names(idx_list, driver0_or_1):\n        if len(idx_list) > driver0_or_1:\n            names = get_driver_name(idx_list[driver0_or_1]).split()\n            return '\\n'.join(names), get_driver_name_acronym(idx_list[driver0_or_1])\n        else:\n            return 'Driver ' + str(driver0_or_1 + 1), str(driver0_or_1 + 1)\n\n    def plot_names(front_name, back_name):\n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n        ax.text(0, 1, back_name, verticalalignment='top', horizontalalignment='left', color='#aaaaaa', clip_on=False, fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=48, alpha = 0.2)\n        ax.text(1, 1, front_name, verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontstyle='italic', fontfamily='sans-serif', fontsize=13)\n        fig.patch.set_facecolor('#1e1e1e')\n        ax.set_facecolor('#1e1e1e')\n        ax.axis('off')\n        #plt.tight_layout(pad=0.01)\n        return fig\n\n    @render.plot\n    def driver0():\n        from matplotlib import pyplot as plt\n        front_name, back_name = format_driver_names(input.driver(),0)\n        return plot_names(front_name, back_name)\n\n    @render.plot\n    def driver1():\n        from matplotlib import pyplot as plt\n        front_name, back_name = format_driver_names(input.driver(),1)\n        return plot_names(front_name, back_name)\n\n    @render.text\n    def driver0_num():\n        return get_driver_num(input.driver()[0]) if len(input.driver()) > 0 is not None else ''\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    def update_cardata_with_driver():\n        global car_data\n        global locations\n        global selected_driver_number\n        global selected_driver_colour\n\n        # print(input.driver())\n        if len(input.driver()) > 0 and len(input.driver()) <= 2:\n\n            fastest_lap_start = None\n            fastest_lap_end = None\n \n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            selected_driver_colour = ['#' + drivers.team_colour[int(d)] if drivers.team_colour[int(d)] is not None else '#ae89c4' for d in input.driver()]\n\n            # if both driver/team colour are missing | if both driver/team colour are the same\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['#1b14e3','#FFFFFF']\n                elif selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour = [f1_red, '#FFFFFF']\n            '''\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['#1b14e3','#FFFFFF']\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n                if selected_driver_colour[1] is None:\n                    selected_driver_colour[1] = '#ae89c4'\n                if selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour[1] = '#ae89c4'\n            elif len(selected_driver_colour) == 1:\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n            '''\n                            \n\n            #print(selected_driver_number, selected_driver_colour)\n\n            #responses = [urlopen('https://api.openf1.org/v1/laps?session_key='+str(selected_session_key)+'&driver_number='+str(d)) for d in selected_driver_number]\n            #responses = [pd.DataFrame(json.loads(r.read().decode('utf-8'))) for r in responses]\n            responses = [api_to_df('laps',['session_key='+str(selected_session_key),'driver_number='+str(d)]) for d in selected_driver_number]\n\n            #[print(r.columns) for r in responses]\n            fastest_laps = [\n                r[(r.lap_duration == r.lap_duration.min()) &\n                  -r.duration_sector_3.isna()]\n                for r in responses]\n            #print(fastest_laps)\n\n            car_data = []\n            locations = []\n            for i in range(len(fastest_laps)):\n                fastest_lap_start = fastest_laps[i].iloc[0,:].date_start\n                fastest_lap_duration = fastest_laps[i].iloc[0,:].lap_duration\n                fastest_lap_end = str(pd.to_datetime(fastest_lap_start) + pd.Timedelta(seconds=fastest_lap_duration))\n                fastest_lap_end = re.sub('\\\\s', 'T', fastest_lap_end)\n                #print(selected_driver_number[i])\n                #response = urlopen('https://api.openf1.org/v1/car_data?driver_number='+str(selected_driver_number[i])+'&session_key='+str(selected_session_key)+'&date>'+str(fastest_lap_start)+'&date<'+str(fastest_lap_end))\n                #car_data.append(pd.DataFrame(json.loads(response.read().decode('utf-8'))))\n                car_data_df = api_to_df('car_data',['driver_number='+str(selected_driver_number[i]),'session_key='+str(selected_session_key),'date>='+str(fastest_lap_start),'date<='+str(fastest_lap_end)])\n                car_data_df['date'] = pd.to_datetime(car_data_df.date, format='mixed') - pd.to_datetime(car_data_df.date,format='mixed').min()\n                car_data.append(car_data_df)\n\n                locations_df = api_to_df('location',['driver_number='+str(selected_driver_number[i]),'session_key='+str(selected_session_key),'date>='+str(fastest_lap_start),'date<='+str(fastest_lap_end)])\n                locations_df['date'] = pd.to_datetime(locations_df.date, format='mixed') - pd.to_datetime(locations_df.date,format='mixed').min()\n                start_x = locations_df[locations_df.date == locations_df.date.min()].x.iloc[0]\n                start_y = locations_df[locations_df.date == locations_df.date.min()].y.iloc[0]\n                locations_df['x'] = locations_df.x - start_x\n                locations_df['y'] = locations_df.y - start_y\n                locations.append(locations_df)\n\n        else:\n            selected_driver_number = []\n            selected_driver_colour = []\n            car_data = []\n            locations = []\n\n\n        #[print(c.driver_number.unique()) for c in car_data]\n        # print(len(car_data), [c.shape for c in car_data])\n\n    @render_widget\n    def tele_plot():\n        import plotly.express as px\n        import plotly.graph_objects as go\n        \n        fig = go.Figure()\n\n        if input.driver() != '' and len(car_data) > 0:\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = data.date.astype(str)\n                    #data['date'] = (pd.to_datetime(data.date, format='mixed') - pd.to_datetime(data.date,format='mixed').min()).astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace=True)\n                    data['date'] = pd.to_datetime(data.date,format='%M:%S.%f')\n                    data.dropna(inplace=True)\n                    \n                    dr_mask = drivers.driver_number == selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<=.[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n                    \n                    fig.add_trace(go.Scatter(x=data.date, y=data.speed, line=(dict(color=str(selected_driver_colour[i]))) , name=list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template='plotly_dark',\n            plot_bgcolor='black',\n            showlegend=True,\n            legend=dict(yanchor='bottom',y=0.01,xanchor='right',x=0.99,orientation='h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        return fig\n\n    # number = index for driver in drivers\n    def driver_metric(metric_name, num, func, minval, maxval, display_name = None):\n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n\n        if input.driver() != '' and len(car_data) > num:\n            plot_data = car_data.copy()[num]\n\n            #print(plot_data[['throttle']].mean(), selected_driver_colour[num])\n            metric = func(plot_data[[metric_name]]) #plot_data[[metric_name]].mean()\n            ax.barh(0.1, metric, color=str(selected_driver_colour[num]), height = 0.1, align='center')\n            ax.text(maxval, 0.3, str(int(round(metric.iloc[0], 0))), verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=22)\n            display_name = metric_name if display_name is None else display_name\n            ax.text(0, 0.3, display_name, verticalalignment='top', horizontalalignment='left', color='#FFFFFF', fontstyle='oblique',fontweight='bold', fontfamily='sans-serif', fontsize=14)\n\n\n        #ax.spines['top'].set_visible(False)\n        #ax.spines['left'].set_visible(False)\n        #ax.spines['right'].set_visible(False)\n        #ax.spines['bottom'].set_color('#FFFFFF')\n        ax.axis('off')\n        ax.tick_params(axis='x', colors='#FFFFFF', direction='in')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([])\n        ax.set_xlim(minval, maxval)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor('#1e1e1e')\n        fig.patch.set_facecolor('#1e1e1e')\n        plt.tight_layout()\n        \n        return fig\n\n    @render.plot\n    def driver0_throttle():\n        return driver_metric('throttle', 0, pd.Series.mean, 0, 100, 'Throttle')\n    \n    @render.plot\n    def driver1_throttle():\n        return driver_metric('throttle', 1, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    def driver0_brake():\n        return driver_metric('brake', 0, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    def driver1_brake():\n        return driver_metric('brake', 1, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    def driver0_topspeed():\n        return driver_metric('speed', 0, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    def driver1_topspeed():\n        return driver_metric('speed', 1, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    def dominance():\n        global locations\n        \n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n\n        if input.driver() != '' and len(locations) > 0:\n            plot_data = locations.copy()[0]\n            ax.scatter(plot_data.x, plot_data.y)\n\n        return fig\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "backup/f1_telemetry_20240329_6.py", "content": "from urllib.request import urlopen\nimport json\nimport re\n\nimport pandas as pd\nfrom scipy import stats\n\nfrom shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\n\n\nevents = None\nsessions = None\ndrivers = None\ncar_data = []\nselected_year = None\nselected_meeting_key = None\nselected_session_key = None\nselected_driver_number = []\nselected_driver_colour = [None, None]\n\nlocations = []\n\n\nf1_red = '#E6002B'\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_selectize(\"year\",\"Year: \", choices=['2023','2024'], selected='2023'),\n        ui.input_selectize(\"event\",\"Event:\", choices=[], selected=0),\n        ui.input_selectize(\"session\",\"Session:\", choices=[]),\n        ui.input_selectize('driver',\"Driver:\", choices=[], multiple=True),\n        width = '320px',\n        bg=f1_red,\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver0\"),height=100, style='background:#1e1e1e')),\n        ui.column(6, ui.card(ui.output_text(\"header\"),height=100, style='text-align:center; font-size:1.1em; font-weight:bold; color:#FFFFFF; background:#1e1e1e; border: 1px solid ' + f1_red)),\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height=100, style='background:#1e1e1e'))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver0_throttle\"), height=100, style='background:#1e1e1e;'),\n                ui.card(ui.output_plot(\"driver0_brake\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver0_topspeed\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e',\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver1_brake\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver1_topspeed\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e'\n            )\n        ),\n    ),\n    ui.row(\n        ui.output_plot('dominance'),\n    ),\n    style='background:#1e1e1e'\n)\n\ndef server(input, output, session):\n    def get_event_name(idx):\n        if idx != '':\n            return events.event_name[int(idx)]\n\n    def get_driver_name(idx):\n        if idx != '':\n            return drivers.full_name[int(idx)]\n\n    def get_driver_name_acronym(idx):\n        if idx != '':\n            return drivers.name_acronym[int(idx)]\n\n    def get_driver_num(idx):\n        if idx != '':\n            return str(drivers.driver_number[int(idx)])\n\n    def get_session_name(idx):\n        if idx != '':\n            return sessions.session_name[int(idx)]\n\n    def api_to_df(call_type, filters):\n        call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n        for f in filters:\n            if call_str[-1] == '?':\n                call_str += f\n            else:\n                call_str += '&' + f\n\n        response = urlopen(call_str)\n        return pd.DataFrame(json.loads(response.read().decode('utf-8')))\n    \n    @reactive.effect\n    def update_event_list_with_year():\n        global events\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global location\n\n        selected_year = input.year()\n\n        #response = urlopen('https://api.openf1.org/v1/meetings?year='+selected_year)\n        #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n        df = api_to_df('meetings', ['year='+str(selected_year)])\n\n        if df.shape[0] > 0:\n            try:\n                events = pd.concat([\n                    df.circuit_short_name,\n                    df.location,\n                    df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                    df.meeting_key,],axis=1)\\\n                    .rename(columns={'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n                ui.update_selectize(\"event\",choices=events.event_name)\n\n            except:\n                pass\n        else:\n            ui.update_selectize(\"event\",choices=[])\n            \n            selected_year = None\n            events = None\n            selected_meeting_key = None\n\n        ui.update_selectize(\"session\",choices=[])\n        ui.update_selectize(\"driver\",choices=[])\n        \n        sessions = None\n        selected_session_key = None\n        drivers = []\n        selected_driver_colour = []\n        selected_driver_number = []\n        car_data = []\n        locations = []\n\n    @render.text\n    def header():\n        event_name = get_event_name(input.event())\n        session_name = get_session_name(input.session())\n\n        return input.year() + ' ' + event_name if event_name != None else input.year()\n\n    @reactive.effect\n    def update_session_list_with_event():\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global car_data\n        global locations\n\n        if len(input.event()) > 0:\n            selected_meeting_key = events.meeting_key[int(input.event())]\n        \n            #response = urlopen('https://api.openf1.org/v1/sessions?year='+str(selected_year)+'&meeting_key='+str(selected_meeting_key))\n            #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n            df = api_to_df('sessions', ['year='+str(selected_year),'meeting_key='+str(selected_meeting_key)])\n            \n            sessions = pd.concat([\n                df.session_key,\n                df.date_start,\n                df.session_type,\n                df.session_name], axis=1)\n\n            ui.update_selectize(\"session\",choices=sessions.session_name)\n        else:\n            ui.update_selectize(\"session\",choices=[])\n\n            sessions = None\n            selected_session_key = None\n\n        ui.update_selectize(\"driver\", choices=[])\n        drivers = None\n        car_data = []\n        selected_driver_colour = []            \n        selected_driver_number = []\n        locations = []\n\n    @reactive.effect\n    def update_driver_list_with_session():\n        global sessions\n        global drivers\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global locations\n\n        if len(input.session()) > 0:\n            selected_session_key = sessions.session_key[int(input.session())]\n            \n            response = urlopen('https://api.openf1.org/v1/drivers?session_key='+str(selected_session_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n            if df.shape[0] > 0:\n                try:\n                    global drivers\n\n                    drivers = pd.concat([\n                        df.driver_number,\n                        df.name_acronym,\n                        df.full_name,\n                        df.team_name,\n                        df.team_colour,\n                        df.headshot_url,\n                        df.country_code], axis=1)\n\n                    drivers['team_name'] = drivers['team_name'].fillna('#NA')\n                    ui.update_selectize(\"driver\", choices=drivers.full_name + \" (\" + drivers.team_name + \")\")\n                except:\n                    pass\n            else:\n                ui.update_selectize(\"driver\", choices=[])\n\n                drivers = []\n\n            car_data = []\n            selected_driver_number = []\n            selected_driver_colour = []\n            locations = []\n\n    def format_driver_names(idx_list, driver0_or_1):\n        if len(idx_list) > driver0_or_1:\n            names = get_driver_name(idx_list[driver0_or_1]).split()\n            return '\\n'.join(names), get_driver_name_acronym(idx_list[driver0_or_1])\n        else:\n            return 'Driver ' + str(driver0_or_1 + 1), str(driver0_or_1 + 1)\n\n    def plot_names(front_name, back_name):\n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n        ax.text(0, 1, back_name, verticalalignment='top', horizontalalignment='left', color='#aaaaaa', clip_on=False, fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=48, alpha = 0.2)\n        ax.text(1, 1, front_name, verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontstyle='italic', fontfamily='sans-serif', fontsize=13)\n        fig.patch.set_facecolor('#1e1e1e')\n        ax.set_facecolor('#1e1e1e')\n        ax.axis('off')\n        #plt.tight_layout(pad=0.01)\n        return fig\n\n    @render.plot\n    def driver0():\n        from matplotlib import pyplot as plt\n        front_name, back_name = format_driver_names(input.driver(),0)\n        return plot_names(front_name, back_name)\n\n    @render.plot\n    def driver1():\n        from matplotlib import pyplot as plt\n        front_name, back_name = format_driver_names(input.driver(),1)\n        return plot_names(front_name, back_name)\n\n    @render.text\n    def driver0_num():\n        return get_driver_num(input.driver()[0]) if len(input.driver()) > 0 is not None else ''\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    def update_cardata_with_driver():\n        # helper functions to map speed to car x, y position on track and determine which car is faster (dominant)\n        def get_speed_from_car_data(car_num, time):\n            global car_data\n            before = car_data[car_num].date < time\n            after = car_data[car_num].date >= time \n            speed_before = -1 if len(car_data[car_num][before].speed) == 0 else car_data[car_num][before].speed.iloc[-1]\n            speed_after = -1 if len(car_data[car_num][after].speed) == 0 else car_data[car_num][after].speed.iloc[0]\n            return (speed_before + speed_after) / 2\n\n        # return 0 = first car is faster\n        # return 1 = second car is faster\n        # return -1 = same speed\n        def calc_dominance(x, y, speed):\n            global locations\n            loc1 = locations[1].copy()\n            loc1['dist'] = abs(loc1.x - x) + abs(loc1.y - y)\n            second_car_speed = loc1[loc1.dist == loc1.dist.min()].speed.iloc[0]\n            if speed > second_car_speed:\n                return 0\n            elif speed < second_car_speed:\n                return 1\n            else:\n                return -1\n\n        global car_data\n        global locations\n        global selected_driver_number\n        global selected_driver_colour\n\n        # print(input.driver())\n        if len(input.driver()) > 0 and len(input.driver()) <= 2:\n\n            fastest_lap_start = None\n            fastest_lap_end = None\n \n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            selected_driver_colour = ['#' + drivers.team_colour[int(d)] if drivers.team_colour[int(d)] is not None else '#ae89c4' for d in input.driver()]\n\n            # if both driver/team colour are missing | if both driver/team colour are the same\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['#1b14e3','#FFFFFF']\n                elif selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour = [f1_red, '#FFFFFF']\n            '''\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['#1b14e3','#FFFFFF']\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n                if selected_driver_colour[1] is None:\n                    selected_driver_colour[1] = '#ae89c4'\n                if selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour[1] = '#ae89c4'\n            elif len(selected_driver_colour) == 1:\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n            '''\n                            \n\n            #print(selected_driver_number, selected_driver_colour)\n\n            #responses = [urlopen('https://api.openf1.org/v1/laps?session_key='+str(selected_session_key)+'&driver_number='+str(d)) for d in selected_driver_number]\n            #responses = [pd.DataFrame(json.loads(r.read().decode('utf-8'))) for r in responses]\n            responses = [api_to_df('laps',['session_key='+str(selected_session_key),'driver_number='+str(d)]) for d in selected_driver_number]\n\n            #[print(r.columns) for r in responses]\n            fastest_laps = [\n                r[(r.lap_duration == r.lap_duration.min()) &\n                  -r.duration_sector_3.isna()]\n                for r in responses]\n            #print(fastest_laps)\n\n            car_data = []\n            locations = []\n            for i in range(len(fastest_laps)):\n                fastest_lap_start = fastest_laps[i].iloc[0,:].date_start\n                fastest_lap_duration = fastest_laps[i].iloc[0,:].lap_duration\n                fastest_lap_end = str(pd.to_datetime(fastest_lap_start) + pd.Timedelta(seconds=fastest_lap_duration))\n                fastest_lap_end = re.sub('\\\\s', 'T', fastest_lap_end)\n                #print(selected_driver_number[i])\n\n                car_data_df = api_to_df('car_data',['driver_number='+str(selected_driver_number[i]),'session_key='+str(selected_session_key),'date>='+str(fastest_lap_start),'date<='+str(fastest_lap_end)])\n                car_data_df['date'] = pd.to_datetime(car_data_df.date, format='mixed') - pd.to_datetime(car_data_df.date,format='mixed').min()\n                car_data.append(car_data_df)\n\n                locations_df = api_to_df('location',['driver_number='+str(selected_driver_number[i]),'session_key='+str(selected_session_key),'date>='+str(fastest_lap_start),'date<='+str(fastest_lap_end)])\n                locations_df['date'] = pd.to_datetime(locations_df.date, format='mixed') - pd.to_datetime(locations_df.date,format='mixed').min()\n                start_x = locations_df[locations_df.date == locations_df.date.min()].x.iloc[0]\n                start_y = locations_df[locations_df.date == locations_df.date.min()].y.iloc[0]\n                locations_df['x'] = locations_df.x - start_x\n                locations_df['y'] = locations_df.y - start_y\n                locations.append(locations_df)\n\n                locations[0]['colour'] = selected_driver_colour[0]\n\n            # compare if there are two cars\n            if len(locations) > 1:\n                # map speed (car_data) to x, y position (location)\n                for j in range(len(locations)):\n                    locations[j]['speed'] = -1.0\n                    for i in range(locations[j].shape[0]):\n                        time = locations[j].iloc[i,:].date\n                        #print(pt.x, pt.y, pt.date)\n                        locations[j].loc[i,'speed'] = get_speed_from_car_data(0, time)\n\n                # determine track dominance\n                locations[0]['dominance'] = -99\n                for i in range(locations[0].shape[0]):\n                    x, y, speed = locations[0].iloc[i, :].x, locations[0].iloc[i, :].y, locations[0].iloc[i, :].speed \n                    locations[0].loc[i, 'dominance'] = calc_dominance(x, y, speed)\n\n                # smooth twice\n                smooth = 10\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i+10, 'dominance'])[0]\n\n                smooth = 5\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i+10, 'dominance'])[0]\n\n                for i in range(locations[0].shape[0]):\n                    dominance = locations[0].loc[i, 'dominance']\n                    if dominance == 0:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[0]\n                    elif dominance == 1:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[1]\n                    else:\n                        locations[0].loc[i, 'colour'] = '#00AAAA'\n        else:\n            selected_driver_number = []\n            selected_driver_colour = []\n            car_data = []\n            locations = []\n\n\n        #[print(c.driver_number.unique()) for c in car_data]\n        # print(len(car_data), [c.shape for c in car_data])\n\n    @render_widget\n    def tele_plot():\n        import plotly.express as px\n        import plotly.graph_objects as go\n        \n        fig = go.Figure()\n\n        if input.driver() != '' and len(car_data) > 0:\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = data.date.astype(str)\n                    #data['date'] = (pd.to_datetime(data.date, format='mixed') - pd.to_datetime(data.date,format='mixed').min()).astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace=True)\n                    data['date'] = pd.to_datetime(data.date,format='%M:%S.%f')\n                    data.dropna(inplace=True)\n                    \n                    dr_mask = drivers.driver_number == selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<=.[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n                    \n                    fig.add_trace(go.Scatter(x=data.date, y=data.speed, line=(dict(color=str(selected_driver_colour[i]))) , name=list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template='plotly_dark',\n            plot_bgcolor='black',\n            showlegend=True,\n            legend=dict(yanchor='bottom',y=0.01,xanchor='right',x=0.99,orientation='h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        return fig\n\n    # number = index for driver in drivers\n    def driver_metric(metric_name, num, func, minval, maxval, display_name = None):\n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n\n        if input.driver() != '' and len(car_data) > num:\n            plot_data = car_data.copy()[num]\n\n            #print(plot_data[['throttle']].mean(), selected_driver_colour[num])\n            metric = func(plot_data[[metric_name]]) #plot_data[[metric_name]].mean()\n            ax.barh(0.1, metric, color=str(selected_driver_colour[num]), height = 0.1, align='center')\n            ax.text(maxval, 0.3, str(int(round(metric.iloc[0], 0))), verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=22)\n            display_name = metric_name if display_name is None else display_name\n            ax.text(0, 0.3, display_name, verticalalignment='top', horizontalalignment='left', color='#FFFFFF', fontstyle='oblique',fontweight='bold', fontfamily='sans-serif', fontsize=14)\n\n\n        #ax.spines['top'].set_visible(False)\n        #ax.spines['left'].set_visible(False)\n        #ax.spines['right'].set_visible(False)\n        #ax.spines['bottom'].set_color('#FFFFFF')\n        ax.axis('off')\n        ax.tick_params(axis='x', colors='#FFFFFF', direction='in')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([])\n        ax.set_xlim(minval, maxval)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor('#1e1e1e')\n        fig.patch.set_facecolor('#1e1e1e')\n        plt.tight_layout()\n        \n        return fig\n\n    @render.plot\n    def driver0_throttle():\n        return driver_metric('throttle', 0, pd.Series.mean, 0, 100, 'Throttle')\n    \n    @render.plot\n    def driver1_throttle():\n        return driver_metric('throttle', 1, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    def driver0_brake():\n        return driver_metric('brake', 0, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    def driver1_brake():\n        return driver_metric('brake', 1, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    def driver0_topspeed():\n        return driver_metric('speed', 0, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    def driver1_topspeed():\n        return driver_metric('speed', 1, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    def dominance():\n        global locations\n        \n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n\n        if input.driver() != '' and len(locations) > 0:\n            plot_data = locations.copy()[0]\n            ax.scatter(plot_data.x, plot_data.y, c=plot_data.colour)\n            ax.axis('off')\n\n        return fig\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "backup/f1_telemetry_20240330_1.py", "content": "from urllib.request import urlopen\nimport json\nimport re\n\nimport pandas as pd\nfrom scipy import stats\n\nfrom shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\n\n\nevents = None\nsessions = None\ndrivers = None\ncar_data = []\nselected_year = None\nselected_meeting_key = None\nselected_session_key = None\nselected_driver_number = []\nselected_driver_colour = [None, None]\n\nlocations = []\n\n\nf1_red = '#E6002B'\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_selectize(\"year\",\"Year: \", choices=['2023','2024'], selected='2024'),\n        ui.input_selectize(\"event\",\"Event:\", choices=[], selected=0),\n        ui.input_selectize(\"session\",\"Session:\", choices=[]),\n        ui.input_selectize('driver',\"Driver:\", choices=[], multiple=True),\n        width = '320px',\n        bg=f1_red,\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver0\"),height=100, style='background:#1e1e1e')),\n        ui.column(6, ui.card(ui.output_text(\"header\"),ui.output_text(\"sub_head\"), height=100, style='text-align:center; font-size:1.1em; font-weight:bold; color:#FFFFFF; background:#1e1e1e; border: 1px solid ' + f1_red)),\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height=100, style='background:#1e1e1e'))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver0_throttle\"), height=100, style='background:#1e1e1e;'),\n                ui.card(ui.output_plot(\"driver0_brake\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver0_topspeed\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e',\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver1_brake\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver1_topspeed\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e'\n            )\n        ),\n    ),\n    ui.row(\n        ui.output_plot('dominance'),\n        height = 250,\n    ),\n    style='background:#1e1e1e'\n)\n\ndef server(input, output, session):\n    def get_event_name(idx):\n        if idx != '':\n            return events.event_name[int(idx)]\n\n    def get_driver_name(idx):\n        if idx != '':\n            return drivers.full_name[int(idx)]\n\n    def get_driver_name_acronym(idx):\n        if idx != '':\n            return drivers.name_acronym[int(idx)]\n\n    def get_driver_num(idx):\n        if idx != '':\n            return str(drivers.driver_number[int(idx)])\n\n    def get_session_name(idx):\n        if idx != '':\n            return sessions.session_name[int(idx)]\n\n    def api_to_df(call_type, filters):\n        call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n        for f in filters:\n            if call_str[-1] == '?':\n                call_str += f\n            else:\n                call_str += '&' + f\n\n        response = urlopen(call_str)\n        return pd.DataFrame(json.loads(response.read().decode('utf-8')))\n    \n    @reactive.effect\n    def update_event_list_with_year():\n        global events\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global location\n\n        selected_year = input.year()\n\n        #response = urlopen('https://api.openf1.org/v1/meetings?year='+selected_year)\n        #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n        df = api_to_df('meetings', ['year='+str(selected_year)])\n\n        if df.shape[0] > 0:\n            try:\n                events = pd.concat([\n                    df.circuit_short_name,\n                    df.location,\n                    df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                    df.meeting_key,],axis=1)\\\n                    .rename(columns={'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n                ui.update_selectize(\"event\",choices=events.event_name)\n\n            except:\n                pass\n        else:\n            ui.update_selectize(\"event\",choices=[])\n            \n            selected_year = None\n            events = None\n            selected_meeting_key = None\n\n        ui.update_selectize(\"session\",choices=[])\n        ui.update_selectize(\"driver\",choices=[])\n        \n        sessions = None\n        selected_session_key = None\n        drivers = []\n        selected_driver_colour = []\n        selected_driver_number = []\n        car_data = []\n        locations = []\n\n    @render.text\n    def header():\n        event_name = get_event_name(input.event())\n        return input.year() + ' ' + event_name if event_name != None else input.year()\n\n    @render.text\n    def sub_head():\n        session_name = get_session_name(input.session())\n        return session_name if session_name != None else ''\n\n    @reactive.effect\n    def update_session_list_with_event():\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global car_data\n        global locations\n\n        if len(input.event()) > 0:\n            selected_meeting_key = events.meeting_key[int(input.event())]\n        \n            #response = urlopen('https://api.openf1.org/v1/sessions?year='+str(selected_year)+'&meeting_key='+str(selected_meeting_key))\n            #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n            df = api_to_df('sessions', ['year='+str(selected_year),'meeting_key='+str(selected_meeting_key)])\n            \n            sessions = pd.concat([\n                df.session_key,\n                df.date_start,\n                df.session_type,\n                df.session_name], axis=1)\n\n            ui.update_selectize(\"session\",choices=sessions.session_name)\n        else:\n            ui.update_selectize(\"session\",choices=[])\n\n            sessions = None\n            selected_session_key = None\n\n        ui.update_selectize(\"driver\", choices=[])\n        drivers = None\n        car_data = []\n        selected_driver_colour = []            \n        selected_driver_number = []\n        locations = []\n\n    @reactive.effect\n    def update_driver_list_with_session():\n        global sessions\n        global drivers\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global locations\n\n        if len(input.session()) > 0:\n            selected_session_key = sessions.session_key[int(input.session())]\n            \n            response = urlopen('https://api.openf1.org/v1/drivers?session_key='+str(selected_session_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n            if df.shape[0] > 0:\n                try:\n                    global drivers\n\n                    drivers = pd.concat([\n                        df.driver_number,\n                        df.name_acronym,\n                        df.full_name,\n                        df.team_name,\n                        df.team_colour,\n                        df.headshot_url,\n                        df.country_code], axis=1)\n\n                    drivers['team_name'] = drivers['team_name'].fillna('#NA')\n                    ui.update_selectize(\"driver\", choices=drivers.full_name + \" (\" + drivers.team_name + \")\")\n                except:\n                    pass\n            else:\n                ui.update_selectize(\"driver\", choices=[])\n\n                drivers = []\n\n            car_data = []\n            selected_driver_number = []\n            selected_driver_colour = []\n            locations = []\n\n    def format_driver_names(idx_list, driver0_or_1):\n        if len(idx_list) > driver0_or_1:\n            names = get_driver_name(idx_list[driver0_or_1]).split()\n            return '\\n'.join(names), get_driver_name_acronym(idx_list[driver0_or_1])\n        else:\n            return 'Driver ' + str(driver0_or_1 + 1), str(driver0_or_1 + 1)\n\n    def plot_names(front_name, back_name):\n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n        ax.text(0, 1, back_name, verticalalignment='top', horizontalalignment='left', color='#aaaaaa', clip_on=False, fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=48, alpha = 0.2)\n        ax.text(1, 1, front_name, verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontstyle='italic', fontfamily='sans-serif', fontsize=13)\n        fig.patch.set_facecolor('#1e1e1e')\n        ax.set_facecolor('#1e1e1e')\n        ax.axis('off')\n        #plt.tight_layout(pad=0.01)\n        return fig\n\n    @render.plot\n    def driver0():\n        from matplotlib import pyplot as plt\n        front_name, back_name = format_driver_names(input.driver(),0)\n        return plot_names(front_name, back_name)\n\n    @render.plot\n    def driver1():\n        from matplotlib import pyplot as plt\n        front_name, back_name = format_driver_names(input.driver(),1)\n        return plot_names(front_name, back_name)\n\n    @render.text\n    def driver0_num():\n        return get_driver_num(input.driver()[0]) if len(input.driver()) > 0 is not None else ''\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    def update_cardata_with_driver():\n        # helper functions to map speed to car x, y position on track and determine which car is faster (dominant)\n        def get_speed_from_car_data(car_num, time):\n            global car_data\n            before = car_data[car_num].date < time\n            after = car_data[car_num].date >= time \n            speed_before = -1 if len(car_data[car_num][before].speed) == 0 else car_data[car_num][before].speed.iloc[-1]\n            speed_after = -1 if len(car_data[car_num][after].speed) == 0 else car_data[car_num][after].speed.iloc[0]\n            return (speed_before + speed_after) / 2\n\n        # return 0 = first car is faster\n        # return 1 = second car is faster\n        # return -1 = same speed\n        def calc_dominance(x, y, speed):\n            global locations\n            loc1 = locations[1].copy()\n            loc1['dist'] = abs(loc1.x - x) + abs(loc1.y - y)\n            second_car_speed = loc1[loc1.dist == loc1.dist.min()].speed.iloc[0]\n            if speed > second_car_speed:\n                return 0\n            elif speed < second_car_speed:\n                return 1\n            else:\n                return -1\n\n        global car_data\n        global locations\n        global selected_driver_number\n        global selected_driver_colour\n\n        # print(input.driver())\n        if len(input.driver()) > 0 and len(input.driver()) <= 2:\n\n            fastest_lap_start = None\n            fastest_lap_end = None\n \n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            selected_driver_colour = ['#' + drivers.team_colour[int(d)] if drivers.team_colour[int(d)] is not None else '#ae89c4' for d in input.driver()]\n\n            # if both driver/team colour are missing | if both driver/team colour are the same\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['#1b14e3','#FFFFFF']\n                elif selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour = [f1_red, '#FFFFFF']\n            '''\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['#1b14e3','#FFFFFF']\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n                if selected_driver_colour[1] is None:\n                    selected_driver_colour[1] = '#ae89c4'\n                if selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour[1] = '#ae89c4'\n            elif len(selected_driver_colour) == 1:\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n            '''\n                            \n\n            #print(selected_driver_number, selected_driver_colour)\n\n            #responses = [urlopen('https://api.openf1.org/v1/laps?session_key='+str(selected_session_key)+'&driver_number='+str(d)) for d in selected_driver_number]\n            #responses = [pd.DataFrame(json.loads(r.read().decode('utf-8'))) for r in responses]\n            responses = [api_to_df('laps',['session_key='+str(selected_session_key),'driver_number='+str(d)]) for d in selected_driver_number]\n\n            #[print(r.columns) for r in responses]\n            fastest_laps = [\n                r[(r.lap_duration == r.lap_duration.min()) &\n                  -r.duration_sector_3.isna()]\n                for r in responses]\n            #print(fastest_laps)\n\n            car_data = []\n            locations = []\n            for i in range(len(fastest_laps)):\n                fastest_lap_start = fastest_laps[i].iloc[0,:].date_start\n                fastest_lap_duration = fastest_laps[i].iloc[0,:].lap_duration\n                fastest_lap_end = str(pd.to_datetime(fastest_lap_start) + pd.Timedelta(seconds=fastest_lap_duration))\n                fastest_lap_end = re.sub('\\\\s', 'T', fastest_lap_end)\n                #print(selected_driver_number[i])\n\n                car_data_df = api_to_df('car_data',['driver_number='+str(selected_driver_number[i]),'session_key='+str(selected_session_key),'date>='+str(fastest_lap_start),'date<='+str(fastest_lap_end)])\n                car_data_df['date'] = pd.to_datetime(car_data_df.date, format='mixed') - pd.to_datetime(car_data_df.date,format='mixed').min()\n                car_data.append(car_data_df)\n\n                locations_df = api_to_df('location',['driver_number='+str(selected_driver_number[i]),'session_key='+str(selected_session_key),'date>='+str(fastest_lap_start),'date<='+str(fastest_lap_end)])\n                locations_df['date'] = pd.to_datetime(locations_df.date, format='mixed') - pd.to_datetime(locations_df.date,format='mixed').min()\n                start_x = locations_df[locations_df.date == locations_df.date.min()].x.iloc[0]\n                start_y = locations_df[locations_df.date == locations_df.date.min()].y.iloc[0]\n                locations_df['x'] = locations_df.x - start_x\n                locations_df['y'] = locations_df.y - start_y\n                locations.append(locations_df)\n\n                locations[0]['colour'] = selected_driver_colour[0]\n\n            # compare if there are two cars\n            if len(locations) > 1:\n                # map speed (car_data) to x, y position (location)\n                for j in range(len(locations)):\n                    locations[j]['speed'] = -1.0\n                    for i in range(locations[j].shape[0]):\n                        time = locations[j].iloc[i,:].date\n                        #print(pt.x, pt.y, pt.date)\n                        locations[j].loc[i,'speed'] = get_speed_from_car_data(j, time)\n\n                # determine track dominance\n                locations[0]['dominance'] = -99\n                for i in range(locations[0].shape[0]):\n                    x, y, speed = locations[0].iloc[i, :].x, locations[0].iloc[i, :].y, locations[0].iloc[i, :].speed \n                    locations[0].loc[i, 'dominance'] = calc_dominance(x, y, speed)\n\n                # smooth twice\n                smooth = 10\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i+10, 'dominance'])[0]\n\n                smooth = 5\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i+10, 'dominance'])[0]\n\n                for i in range(locations[0].shape[0]):\n                    dominance = locations[0].loc[i, 'dominance']\n                    if dominance == 0:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[0]\n                    elif dominance == 1:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[1]\n                    else:\n                        locations[0].loc[i, 'colour'] = '#00AAAA'\n        else:\n            selected_driver_number = []\n            selected_driver_colour = []\n            car_data = []\n            locations = []\n\n\n        #[print(c.driver_number.unique()) for c in car_data]\n        # print(len(car_data), [c.shape for c in car_data])\n\n    @render_widget\n    def tele_plot():\n        import plotly.express as px\n        import plotly.graph_objects as go\n        \n        fig = go.Figure()\n\n        if input.driver() != '' and len(car_data) > 0:\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = data.date.astype(str)\n                    #data['date'] = (pd.to_datetime(data.date, format='mixed') - pd.to_datetime(data.date,format='mixed').min()).astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace=True)\n                    data['date'] = pd.to_datetime(data.date,format='%M:%S.%f')\n                    data.dropna(inplace=True)\n                    \n                    dr_mask = drivers.driver_number == selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<=.[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n                    \n                    fig.add_trace(go.Scatter(x=data.date, y=data.speed, line=(dict(color=str(selected_driver_colour[i]))) , name=list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template='plotly_dark',\n            plot_bgcolor='black',\n            showlegend=True,\n            legend=dict(yanchor='bottom',y=0.01,xanchor='right',x=0.99,orientation='h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        fig.update_yaxes(title_text='Speed / mph')\n        return fig\n\n    # number = index for driver in drivers\n    def driver_metric(metric_name, num, func, minval, maxval, display_name = None):\n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n\n        if input.driver() != '' and len(car_data) > num:\n            plot_data = car_data.copy()[num]\n\n            #print(plot_data[['throttle']].mean(), selected_driver_colour[num])\n            metric = func(plot_data[[metric_name]]) #plot_data[[metric_name]].mean()\n            ax.barh(0.1, metric, color=str(selected_driver_colour[num]), height = 0.1, align='center')\n            ax.text(maxval, 0.3, str(int(round(metric.iloc[0], 0))), verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=22)\n            display_name = metric_name if display_name is None else display_name\n            ax.text(0, 0.3, display_name, verticalalignment='top', horizontalalignment='left', color='#FFFFFF', fontstyle='oblique',fontweight='bold', fontfamily='sans-serif', fontsize=14)\n\n\n        #ax.spines['top'].set_visible(False)\n        #ax.spines['left'].set_visible(False)\n        #ax.spines['right'].set_visible(False)\n        #ax.spines['bottom'].set_color('#FFFFFF')\n        ax.axis('off')\n        ax.tick_params(axis='x', colors='#FFFFFF', direction='in')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([])\n        ax.set_xlim(minval, maxval)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor('#1e1e1e')\n        fig.patch.set_facecolor('#1e1e1e')\n        plt.tight_layout()\n        \n        return fig\n\n    @render.plot\n    def driver0_throttle():\n        return driver_metric('throttle', 0, pd.Series.mean, 0, 100, 'Throttle')\n    \n    @render.plot\n    def driver1_throttle():\n        return driver_metric('throttle', 1, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    def driver0_brake():\n        return driver_metric('brake', 0, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    def driver1_brake():\n        return driver_metric('brake', 1, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    def driver0_topspeed():\n        return driver_metric('speed', 0, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    def driver1_topspeed():\n        return driver_metric('speed', 1, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    def dominance():\n        global locations\n        \n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n\n        if input.driver() != '' and len(locations) > 0:\n            plot_data = locations.copy()[0]\n            \n            if len(plot_data.colour.unique()) == 1:\n                ax.plot(plot_data.x, plot_data.y, c=plot_data.colour.iloc[0], ls='-', lw=15)\n                ax.plot(plot_data.x + 100, plot_data.y - 100, c=plot_data.colour.iloc[0], ls='-', lw=8, alpha=0.15)\n            else:\n                current_segment = 0\n                plot_data['segment'] = -1\n                for i in range(plot_data.shape[0]):\n                    plot_data.loc[i, 'segment'] = current_segment\n                    if (i < plot_data.shape[0] - 1) and (plot_data.loc[i, 'dominance'] != plot_data.loc[i+1, 'dominance']):\n                        current_segment += 1\n\n                ax.plot(plot_data.x + 100, plot_data.y - 100, c='#FFFFFF', ls='-', lw=15, alpha=0.15)\n\n                for c in plot_data.colour.unique():\n                    plot_data_c = plot_data[plot_data.colour == c]\n                    for seg in plot_data_c.segment.unique():\n                        plot_segment = plot_data_c[plot_data_c.segment == seg]\n                        if plot_segment.shape[0] > 1:\n                            if seg == -1:\n                                lw = 10\n                            else:\n                                lw = 15\n                            ax.plot(\n                                plot_segment.x,\n                                plot_segment.y,\n                                c=plot_segment.colour.iloc[0],\n                                marker='o',\n                                ls='-',lw=lw)\n                #ax.text(0, ax.get_ylim()[1]+600, 'Track Dominance', verticalalignment='top', horizontalalignment='left', color='#FFFFFF', fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=22)\n        ax.axis('off')\n        ax.set_facecolor('#1e1e1e')\n\n        fig.patch.set_facecolor('#1e1e1e')\n        return fig\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "backup/f1_telemetry_20240330_2.py", "content": "from urllib.request import urlopen\nimport json\nimport re\n\nimport pandas as pd\nfrom scipy import stats\n\nfrom shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\n\n\nevents = None\nsessions = None\ndrivers = None\ncar_data = []\nselected_year = None\nselected_meeting_key = None\nselected_session_key = None\nselected_driver_number = []\nselected_driver_colour = [None, None]\n\nlocations = []\n\n\nf1_red = '#E6002B'\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_selectize(\"year\",\"Year: \", choices=['2023','2024'], selected='2024'),\n        ui.input_selectize(\"event\",\"Event:\", choices=[], selected=0),\n        ui.input_selectize(\"session\",\"Session:\", choices=[]),\n        ui.input_selectize('driver',\"Driver:\", choices=[], multiple=True),\n        width = '320px',\n        bg=f1_red,\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver0\"),height=100, style='background:#1e1e1e')),\n        ui.column(6, ui.card(ui.output_text(\"header\"),ui.output_text(\"sub_head\"), height=100, style='text-align:center; font-size:1.1em; font-weight:bold; color:#FFFFFF; background:#1e1e1e; border: 1px solid ' + f1_red)),\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height=100, style='background:#1e1e1e'))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver0_throttle\"), height=100, style='background:#1e1e1e;'),\n                ui.card(ui.output_plot(\"driver0_brake\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver0_topspeed\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e',\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver1_brake\"), height=100, style='background:#1e1e1e'),\n                ui.card(ui.output_plot(\"driver1_topspeed\"), height=100, style='background:#1e1e1e'),\n            height = 400,\n            style='background:#1e1e1e'\n            )\n        ),\n    ),\n    ui.row(\n        ui.output_plot('dominance'),\n        height = 250,\n    ),\n    style='background:#1e1e1e'\n)\n\ndef server(input, output, session):\n    def get_event_name(idx):\n        if idx != '':\n            return events.event_name[int(idx)]\n\n    def get_driver_name(idx):\n        if idx != '':\n            return drivers.full_name[int(idx)]\n\n    def get_driver_name_acronym(idx):\n        if idx != '':\n            return drivers.name_acronym[int(idx)]\n\n    def get_driver_num(idx):\n        if idx != '':\n            return str(drivers.driver_number[int(idx)])\n\n    def get_session_name(idx):\n        if idx != '':\n            return sessions.session_name[int(idx)]\n\n    def api_to_df(call_type, filters):\n        call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n        for f in filters:\n            if call_str[-1] == '?':\n                call_str += f\n            else:\n                call_str += '&' + f\n\n        response = urlopen(call_str)\n        return pd.DataFrame(json.loads(response.read().decode('utf-8')))\n    \n    @reactive.effect\n    def update_event_list_with_year():\n        global events\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global location\n\n        selected_year = input.year()\n\n        #response = urlopen('https://api.openf1.org/v1/meetings?year='+selected_year)\n        #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n        df = api_to_df('meetings', ['year='+str(selected_year)])\n\n        if df.shape[0] > 0:\n            try:\n                events = pd.concat([\n                    df.circuit_short_name,\n                    df.location,\n                    df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                    df.meeting_key,],axis=1)\\\n                    .rename(columns={'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n                ui.update_selectize(\"event\",choices=events.event_name)\n\n            except:\n                pass\n        else:\n            ui.update_selectize(\"event\",choices=[])\n            \n            selected_year = None\n            events = None\n            selected_meeting_key = None\n\n        ui.update_selectize(\"session\",choices=[])\n        ui.update_selectize(\"driver\",choices=[])\n        \n        sessions = None\n        selected_session_key = None\n        drivers = []\n        selected_driver_colour = []\n        selected_driver_number = []\n        car_data = []\n        locations = []\n\n    @render.text\n    def header():\n        event_name = get_event_name(input.event())\n        return input.year() + ' ' + event_name if event_name != None else input.year()\n\n    @render.text\n    def sub_head():\n        session_name = get_session_name(input.session())\n        return session_name if session_name != None else ''\n\n    @reactive.effect\n    def update_session_list_with_event():\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global car_data\n        global locations\n\n        if len(input.event()) > 0:\n            selected_meeting_key = events.meeting_key[int(input.event())]\n        \n            #response = urlopen('https://api.openf1.org/v1/sessions?year='+str(selected_year)+'&meeting_key='+str(selected_meeting_key))\n            #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n            df = api_to_df('sessions', ['year='+str(selected_year),'meeting_key='+str(selected_meeting_key)])\n            \n            sessions = pd.concat([\n                df.session_key,\n                df.date_start,\n                df.session_type,\n                df.session_name], axis=1)\n\n            ui.update_selectize(\"session\",choices=sessions.session_name)\n        else:\n            ui.update_selectize(\"session\",choices=[])\n\n            sessions = None\n            selected_session_key = None\n\n        ui.update_selectize(\"driver\", choices=[])\n        drivers = None\n        car_data = []\n        selected_driver_colour = []            \n        selected_driver_number = []\n        locations = []\n\n    @reactive.effect\n    def update_driver_list_with_session():\n        global sessions\n        global drivers\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global locations\n\n        if len(input.session()) > 0:\n            selected_session_key = sessions.session_key[int(input.session())]\n            \n            response = urlopen('https://api.openf1.org/v1/drivers?session_key='+str(selected_session_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n            if df.shape[0] > 0:\n                try:\n                    global drivers\n\n                    drivers = pd.concat([\n                        df.driver_number,\n                        df.name_acronym,\n                        df.full_name,\n                        df.team_name,\n                        df.team_colour,\n                        df.headshot_url,\n                        df.country_code], axis=1)\n\n                    drivers['team_name'] = drivers['team_name'].fillna('#NA')\n                    ui.update_selectize(\"driver\", choices=drivers.full_name + \" (\" + drivers.team_name + \")\")\n                except:\n                    pass\n            else:\n                ui.update_selectize(\"driver\", choices=[])\n\n                drivers = []\n\n            car_data = []\n            selected_driver_number = []\n            selected_driver_colour = []\n            locations = []\n\n    def format_driver_names(idx_list, driver0_or_1):\n        if len(idx_list) > driver0_or_1:\n            names = get_driver_name(idx_list[driver0_or_1]).split()\n            return '\\n'.join(names), get_driver_name_acronym(idx_list[driver0_or_1])\n        else:\n            return 'Driver ' + str(driver0_or_1 + 1), str(driver0_or_1 + 1)\n\n    def plot_names(front_name, back_name):\n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n        ax.text(0, 1, back_name, verticalalignment='top', horizontalalignment='left', color='#aaaaaa', clip_on=False, fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=48, alpha = 0.2)\n        ax.text(1, 1, front_name, verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontstyle='italic', fontfamily='sans-serif', fontsize=13)\n        fig.patch.set_facecolor('#1e1e1e')\n        ax.set_facecolor('#1e1e1e')\n        ax.axis('off')\n        #plt.tight_layout(pad=0.01)\n        return fig\n\n    @render.plot\n    def driver0():\n        from matplotlib import pyplot as plt\n        front_name, back_name = format_driver_names(input.driver(),0)\n        return plot_names(front_name, back_name)\n\n    @render.plot\n    def driver1():\n        from matplotlib import pyplot as plt\n        front_name, back_name = format_driver_names(input.driver(),1)\n        return plot_names(front_name, back_name)\n\n    @render.text\n    def driver0_num():\n        return get_driver_num(input.driver()[0]) if len(input.driver()) > 0 is not None else ''\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    def update_cardata_with_driver():\n        # helper functions to map speed to car x, y position on track and determine which car is faster (dominant)\n        def get_speed_from_car_data(car_num, time):\n            global car_data\n            before = car_data[car_num].date < time\n            after = car_data[car_num].date >= time \n            speed_before = -1 if len(car_data[car_num][before].speed) == 0 else car_data[car_num][before].speed.iloc[-1]\n            speed_after = -1 if len(car_data[car_num][after].speed) == 0 else car_data[car_num][after].speed.iloc[0]\n            return (speed_before + speed_after) / 2\n\n        # return 0 = first car is faster\n        # return 1 = second car is faster\n        # return -1 = same speed\n        def calc_dominance(x, y, speed):\n            global locations\n            loc1 = locations[1].copy()\n            loc1['dist'] = abs(loc1.x - x) + abs(loc1.y - y)\n            second_car_speed = loc1[loc1.dist == loc1.dist.min()].speed.iloc[0]\n            if speed > second_car_speed:\n                return 0\n            elif speed < second_car_speed:\n                return 1\n            else:\n                return -1\n\n        global car_data\n        global locations\n        global selected_driver_number\n        global selected_driver_colour\n\n        # print(input.driver())\n        if len(input.driver()) > 0 and len(input.driver()) <= 2:\n\n            fastest_lap_start = None\n            fastest_lap_end = None\n \n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            selected_driver_colour = ['#' + str(drivers.team_colour[int(d)]) if drivers.team_colour[int(d)] is not None else '#ae89c4' for d in input.driver()]\n\n            # if both driver/team colour are missing | if both driver/team colour are the same\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['#1b14e3','#FFFFFF']\n                elif selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour = [f1_red, '#FFFFFF']\n            '''\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['#1b14e3','#FFFFFF']\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n                if selected_driver_colour[1] is None:\n                    selected_driver_colour[1] = '#ae89c4'\n                if selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour[1] = '#ae89c4'\n            elif len(selected_driver_colour) == 1:\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n            '''\n                            \n\n            #print(selected_driver_number, selected_driver_colour)\n\n            #responses = [urlopen('https://api.openf1.org/v1/laps?session_key='+str(selected_session_key)+'&driver_number='+str(d)) for d in selected_driver_number]\n            #responses = [pd.DataFrame(json.loads(r.read().decode('utf-8'))) for r in responses]\n            responses = [api_to_df('laps',['session_key='+str(selected_session_key),'driver_number='+str(d)]) for d in selected_driver_number]\n\n            #[print(r.columns) for r in responses]\n            fastest_laps = [\n                r[(r.lap_duration == r.lap_duration.min()) &\n                  -r.duration_sector_3.isna()]\n                for r in responses]\n            #print(fastest_laps)\n\n            car_data = []\n            locations = []\n            for i in range(len(fastest_laps)):\n                fastest_lap_start = fastest_laps[i].iloc[0,:].date_start\n                fastest_lap_duration = fastest_laps[i].iloc[0,:].lap_duration\n                fastest_lap_end = str(pd.to_datetime(fastest_lap_start) + pd.Timedelta(seconds=fastest_lap_duration))\n                fastest_lap_end = re.sub('\\\\s', 'T', fastest_lap_end)\n                #print(selected_driver_number[i])\n\n                car_data_df = api_to_df('car_data',['driver_number='+str(selected_driver_number[i]),'session_key='+str(selected_session_key),'date>='+str(fastest_lap_start),'date<='+str(fastest_lap_end)])\n                car_data_df['date'] = pd.to_datetime(car_data_df.date, format='mixed') - pd.to_datetime(car_data_df.date,format='mixed').min()\n                car_data.append(car_data_df)\n\n                locations_df = api_to_df('location',['driver_number='+str(selected_driver_number[i]),'session_key='+str(selected_session_key),'date>='+str(fastest_lap_start),'date<='+str(fastest_lap_end)])\n                locations_df['date'] = pd.to_datetime(locations_df.date, format='mixed') - pd.to_datetime(locations_df.date,format='mixed').min()\n                start_x = locations_df[locations_df.date == locations_df.date.min()].x.iloc[0]\n                start_y = locations_df[locations_df.date == locations_df.date.min()].y.iloc[0]\n                locations_df['x'] = locations_df.x - start_x\n                locations_df['y'] = locations_df.y - start_y\n                locations.append(locations_df)\n\n                locations[0]['colour'] = selected_driver_colour[0]\n\n            # compare if there are two cars\n            if len(locations) > 1:\n                # map speed (car_data) to x, y position (location)\n                for j in range(len(locations)):\n                    locations[j]['speed'] = -1.0\n                    for i in range(locations[j].shape[0]):\n                        time = locations[j].iloc[i,:].date\n                        #print(pt.x, pt.y, pt.date)\n                        locations[j].loc[i,'speed'] = get_speed_from_car_data(j, time)\n\n                # determine track dominance\n                locations[0]['dominance'] = -99\n                for i in range(locations[0].shape[0]):\n                    x, y, speed = locations[0].iloc[i, :].x, locations[0].iloc[i, :].y, locations[0].iloc[i, :].speed \n                    locations[0].loc[i, 'dominance'] = calc_dominance(x, y, speed)\n\n                # smooth twice\n                smooth = 12\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i+smooth, 'dominance'])[0]\n\n                smooth = 8\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i+smooth, 'dominance'])[0]\n\n\n                for i in range(locations[0].shape[0]):\n                    dominance = locations[0].loc[i, 'dominance']\n                    if dominance == 0:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[0]\n                    elif dominance == 1:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[1]\n                    else:\n                        locations[0].loc[i, 'colour'] = '#00AAAA'\n        else:\n            selected_driver_number = []\n            selected_driver_colour = []\n            car_data = []\n            locations = []\n\n\n        #[print(c.driver_number.unique()) for c in car_data]\n        # print(len(car_data), [c.shape for c in car_data])\n\n    @render_widget\n    def tele_plot():\n        import plotly.express as px\n        import plotly.graph_objects as go\n        \n        fig = go.Figure()\n\n        if input.driver() != '' and len(car_data) > 0:\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = data.date.astype(str)\n                    #data['date'] = (pd.to_datetime(data.date, format='mixed') - pd.to_datetime(data.date,format='mixed').min()).astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace=True)\n                    data['date'] = pd.to_datetime(data.date,format='%M:%S.%f')\n                    data.dropna(inplace=True)\n                    \n                    dr_mask = drivers.driver_number == selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<=.[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n                    \n                    fig.add_trace(go.Scatter(x=data.date, y=data.speed, line=(dict(color=str(selected_driver_colour[i]))) , name=list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template='plotly_dark',\n            plot_bgcolor='black',\n            showlegend=True,\n            legend=dict(yanchor='bottom',y=0.01,xanchor='right',x=0.99,orientation='h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        fig.update_yaxes(title_text='Speed / mph')\n        return fig\n\n    # number = index for driver in drivers\n    def driver_metric(metric_name, num, func, minval, maxval, display_name = None):\n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n\n        if input.driver() != '' and len(car_data) > num:\n            plot_data = car_data.copy()[num]\n\n            #print(plot_data[['throttle']].mean(), selected_driver_colour[num])\n            metric = func(plot_data[[metric_name]]) #plot_data[[metric_name]].mean()\n            ax.barh(0.1, metric, color=str(selected_driver_colour[num]), height = 0.1, align='center')\n            ax.text(maxval, 0.3, str(int(round(metric.iloc[0], 0))), verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=22)\n            display_name = metric_name if display_name is None else display_name\n            ax.text(0, 0.3, display_name, verticalalignment='top', horizontalalignment='left', color='#FFFFFF', fontstyle='oblique',fontweight='bold', fontfamily='sans-serif', fontsize=14)\n\n\n        #ax.spines['top'].set_visible(False)\n        #ax.spines['left'].set_visible(False)\n        #ax.spines['right'].set_visible(False)\n        #ax.spines['bottom'].set_color('#FFFFFF')\n        ax.axis('off')\n        ax.tick_params(axis='x', colors='#FFFFFF', direction='in')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([])\n        ax.set_xlim(minval, maxval)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor('#1e1e1e')\n        fig.patch.set_facecolor('#1e1e1e')\n        plt.tight_layout()\n        \n        return fig\n\n    @render.plot\n    def driver0_throttle():\n        return driver_metric('throttle', 0, pd.Series.mean, 0, 100, 'Throttle')\n    \n    @render.plot\n    def driver1_throttle():\n        return driver_metric('throttle', 1, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    def driver0_brake():\n        return driver_metric('brake', 0, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    def driver1_brake():\n        return driver_metric('brake', 1, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    def driver0_topspeed():\n        return driver_metric('speed', 0, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    def driver1_topspeed():\n        return driver_metric('speed', 1, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    def dominance():\n        global locations\n        \n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n\n        if input.driver() != '' and len(locations) > 0:\n            plot_data = locations.copy()[0]\n            \n            # draw driver0\n            ax.plot(plot_data.x + 100, plot_data.y - 450, c='#FFFFFF', ls='-', lw=30, alpha=0.15)\n            #ax.plot(plot_data.x + 150, plot_data.y - 500, c='#FFFFFF', ls='-', lw=10, alpha=0.2)\n            ax.plot(plot_data.x, plot_data.y, c=selected_driver_colour[0], ls='-', lw=18)\n\n            # work out segments for drawing\n            if len(plot_data.colour.unique()) > 1:\n                current_segment = 0\n                plot_data['segment'] = -1\n                for i in range(plot_data.shape[0]):\n                    plot_data.loc[i, 'segment'] = current_segment\n                    if (i < plot_data.shape[0] - 1) and (plot_data.loc[i, 'dominance'] != plot_data.loc[i+1, 'dominance']):\n                        current_segment += 1\n\n                # only draw driver1 dominant segments\n                plot_data_c = plot_data[plot_data.dominance == 1]\n                for seg in plot_data_c.segment.unique():\n                        plot_segment = plot_data_c[plot_data_c.segment == seg]\n                        if plot_segment.shape[0] > 1:\n                            ax.plot(\n                                plot_segment.x,\n                                plot_segment.y,\n                                c=selected_driver_colour[1],\n                                marker='o',\n                                ls='-',lw=8)\n        ax.axis('off')\n        ax.set_facecolor('#1e1e1e')\n\n        fig.patch.set_facecolor('#1e1e1e')\n        return fig\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "backup/f1_telemetry_20240331.py", "content": "from urllib.request import urlopen\nimport json\nimport re\n\nimport pandas as pd\nfrom scipy import stats\n\nfrom shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\n\n\nevents = None\nsessions = None\ndrivers = None\ncar_data = []\nselected_year = None\nselected_meeting_key = None\nselected_session_key = None\nselected_driver_number = []\nselected_driver_colour = [None, None]\n\nlocations = []\n\n\nf1_red = '#E6002B'\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.card(\n            ui.input_selectize(\"year\",\"Year: \", choices=['2023','2024'], selected='2024'),\n            ui.input_selectize(\"event\",\"Event:\", choices=[], selected=0),\n            ui.input_selectize(\"session\",\"Session:\", choices=[]),\n            ui.input_selectize('driver',\"Driver:\", choices=[], multiple=True),\n            height = 600,\n            style='background:'+f1_red,\n        ),\n        ui.output_text('ack'),\n        width = '320px',\n        bg=f1_red,\n        fg='#FFFFFF',\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver0\"),height=80, style='background:#111111')),\n        ui.column(6, ui.output_text(\"header\"),ui.output_text(\"sub_head\"), height=80, style='text-align:center; line-height:2; font-size:1.6em; font-weight:bold; color:#FFFFFF; background:#111111; border: 1px solid ' + f1_red),\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height=80, style='background:#111111'))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver0_throttle\"), height=100, style='background:#111111;'),\n                ui.card(ui.output_plot(\"driver0_brake\"), height=100, style='background:#111111'),\n                ui.card(ui.output_plot(\"driver0_topspeed\"), height=100, style='background:#111111'),\n            height = 400,\n            style='background:#111111',\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height=100, style='background:#111111'),\n                ui.card(ui.output_plot(\"driver1_brake\"), height=100, style='background:#111111'),\n                ui.card(ui.output_plot(\"driver1_topspeed\"), height=100, style='background:#111111'),\n            height = 400,\n            style='background:#111111'\n            )\n        ),\n    ),\n    ui.row(\n        ui.output_plot('dominance'),\n        height = 250,\n    ),\n    style='background:#111111'\n)\n\ndef server(input, output, session):\n    def get_event_name(idx):\n        if idx != '':\n            return events.event_name[int(idx)]\n\n    def get_driver_name(idx):\n        if idx != '':\n            return drivers.full_name[int(idx)]\n\n    def get_driver_name_acronym(idx):\n        if idx != '':\n            return drivers.name_acronym[int(idx)]\n\n    def get_driver_num(idx):\n        if idx != '':\n            return str(drivers.driver_number[int(idx)])\n\n    def get_session_name(idx):\n        if idx != '':\n            return sessions.session_name[int(idx)]\n\n    def api_to_df(call_type, filters):\n        call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n        for f in filters:\n            if call_str[-1] == '?':\n                call_str += f\n            else:\n                call_str += '&' + f\n\n        response = urlopen(call_str)\n        return pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n    @render.text\n    def ack():\n        return 'Credit to the open-sourced OpenF1.org API (https://openf1.org/) for the Formula One\u00ae telemetry data used in this dashboard'\n        \n    \n    @reactive.effect\n    def update_event_list_with_year():\n        global events\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global location\n\n        selected_year = input.year()\n\n        #response = urlopen('https://api.openf1.org/v1/meetings?year='+selected_year)\n        #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n        df = api_to_df('meetings', ['year='+str(selected_year)])\n\n        if df.shape[0] > 0:\n            try:\n                events = pd.concat([\n                    df.circuit_short_name,\n                    df.location,\n                    df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                    df.meeting_key,],axis=1)\\\n                    .rename(columns={'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n                ui.update_selectize(\"event\",choices=events.event_name)\n\n            except:\n                pass\n        else:\n            ui.update_selectize(\"event\",choices=[])\n            \n            selected_year = None\n            events = None\n            selected_meeting_key = None\n\n        ui.update_selectize(\"session\",choices=[])\n        ui.update_selectize(\"driver\",choices=[])\n        \n        sessions = None\n        selected_session_key = None\n        drivers = []\n        selected_driver_colour = []\n        selected_driver_number = []\n        car_data = []\n        locations = []\n\n    @render.text\n    def header():\n        event_name = get_event_name(input.event())\n        return input.year() + ' ' + event_name if event_name != None else input.year()\n\n    @render.text\n    def sub_head():\n        session_name = get_session_name(input.session())\n        return session_name if session_name != None else ''\n\n    @reactive.effect\n    def update_session_list_with_event():\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global car_data\n        global locations\n\n        if len(input.event()) > 0:\n            selected_meeting_key = events.meeting_key[int(input.event())]\n        \n            #response = urlopen('https://api.openf1.org/v1/sessions?year='+str(selected_year)+'&meeting_key='+str(selected_meeting_key))\n            #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n            df = api_to_df('sessions', ['year='+str(selected_year),'meeting_key='+str(selected_meeting_key)])\n            \n            sessions = pd.concat([\n                df.session_key,\n                df.date_start,\n                df.session_type,\n                df.session_name], axis=1)\n\n            ui.update_selectize(\"session\",choices=sessions.session_name)\n        else:\n            ui.update_selectize(\"session\",choices=[])\n\n            sessions = None\n            selected_session_key = None\n\n        ui.update_selectize(\"driver\", choices=[])\n        drivers = None\n        car_data = []\n        selected_driver_colour = []            \n        selected_driver_number = []\n        locations = []\n\n    @reactive.effect\n    def update_driver_list_with_session():\n        global sessions\n        global drivers\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global locations\n\n        if len(input.session()) > 0:\n            selected_session_key = sessions.session_key[int(input.session())]\n            \n            response = urlopen('https://api.openf1.org/v1/drivers?session_key='+str(selected_session_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n            if df.shape[0] > 0:\n                try:\n                    global drivers\n\n                    drivers = pd.concat([\n                        df.driver_number,\n                        df.name_acronym,\n                        df.full_name,\n                        df.team_name,\n                        df.team_colour,\n                        df.headshot_url,\n                        df.country_code], axis=1)\n\n                    drivers['team_name'] = drivers['team_name'].fillna('#NA')\n                    ui.update_selectize(\"driver\", choices=drivers.full_name + \" (\" + drivers.team_name + \")\")\n                except:\n                    pass\n            else:\n                ui.update_selectize(\"driver\", choices=[])\n\n                drivers = []\n\n            car_data = []\n            selected_driver_number = []\n            selected_driver_colour = []\n            locations = []\n\n    def format_driver_names(idx_list, driver0_or_1):\n        if len(idx_list) > driver0_or_1:\n            names = get_driver_name(idx_list[driver0_or_1]).split()\n            return '\\n'.join([names[0],' '.join(names[1:])]), get_driver_name_acronym(idx_list[driver0_or_1])\n        else:\n            return 'Driver ' + str(driver0_or_1 + 1), str(driver0_or_1 + 1)\n\n    def plot_names(front_name, back_name):\n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n        ax.text(0, 1, back_name, verticalalignment='top', horizontalalignment='left', color='#aaaaaa', clip_on=False, fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=36, alpha = 0.2)\n        ax.text(1, 1, front_name, verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontstyle='italic', fontfamily='sans-serif', fontsize=13)\n        fig.patch.set_facecolor('#111111')\n        ax.set_facecolor('#111111')\n        ax.axis('off')\n        plt.tight_layout(pad=0)\n        return fig\n\n    @render.plot\n    def driver0():\n        from matplotlib import pyplot as plt\n        front_name, back_name = format_driver_names(input.driver(),0)\n        return plot_names(front_name, back_name)\n\n    @render.plot\n    def driver1():\n        from matplotlib import pyplot as plt\n        front_name, back_name = format_driver_names(input.driver(),1)\n        return plot_names(front_name, back_name)\n\n    @render.text\n    def driver0_num():\n        return get_driver_num(input.driver()[0]) if len(input.driver()) > 0 is not None else ''\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    def update_cardata_with_driver():\n        # helper functions to map speed to car x, y position on track and determine which car is faster (dominant)\n        def get_speed_from_car_data(car_num, time):\n            global car_data\n            before = car_data[car_num].date < time\n            after = car_data[car_num].date >= time \n            speed_before = -1 if len(car_data[car_num][before].speed) == 0 else car_data[car_num][before].speed.iloc[-1]\n            speed_after = -1 if len(car_data[car_num][after].speed) == 0 else car_data[car_num][after].speed.iloc[0]\n            return (speed_before + speed_after) / 2\n\n        # return 0 = first car is faster\n        # return 1 = second car is faster\n        # return -1 = same speed\n        def calc_dominance(x, y, speed):\n            global locations\n            loc1 = locations[1].copy()\n            loc1['dist'] = abs(loc1.x - x) + abs(loc1.y - y)\n            second_car_speed = loc1[loc1.dist == loc1.dist.min()].speed.iloc[0]\n            if speed > second_car_speed:\n                return 0\n            elif speed < second_car_speed:\n                return 1\n            else:\n                return -1\n\n        global car_data\n        global locations\n        global selected_driver_number\n        global selected_driver_colour\n\n        # print(input.driver())\n        if len(input.driver()) > 0 and len(input.driver()) <= 2:\n\n            fastest_lap_start = None\n            fastest_lap_end = None\n \n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            selected_driver_colour = ['#' + str(drivers.team_colour[int(d)]) if drivers.team_colour[int(d)] is not None else '#ae89c4' for d in input.driver()]\n\n            # if both driver/team colour are missing | if both driver/team colour are the same\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['#1b14e3','#FFFFFF']\n                elif selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour = [f1_red, '#FFFFFF']\n            '''\n            if len(selected_driver_colour) > 1:\n                if selected_driver_colour[0] is None and selected_driver_colour[1] is None:\n                    selected_driver_colour = ['#1b14e3','#FFFFFF']\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n                if selected_driver_colour[1] is None:\n                    selected_driver_colour[1] = '#ae89c4'\n                if selected_driver_colour[0] == selected_driver_colour[1]:\n                    selected_driver_colour[1] = '#ae89c4'\n            elif len(selected_driver_colour) == 1:\n                if selected_driver_colour[0] is None:\n                    selected_driver_colour[0] = '#ae89c4'\n            '''\n                            \n\n            #print(selected_driver_number, selected_driver_colour)\n\n            #responses = [urlopen('https://api.openf1.org/v1/laps?session_key='+str(selected_session_key)+'&driver_number='+str(d)) for d in selected_driver_number]\n            #responses = [pd.DataFrame(json.loads(r.read().decode('utf-8'))) for r in responses]\n            responses = [api_to_df('laps',['session_key='+str(selected_session_key),'driver_number='+str(d)]) for d in selected_driver_number]\n\n            #[print(r.columns) for r in responses]\n            fastest_laps = [\n                r[(r.lap_duration == r.lap_duration.min()) &\n                  -r.duration_sector_3.isna()]\n                for r in responses]\n            #print(fastest_laps)\n\n            car_data = []\n            locations = []\n            for i in range(len(fastest_laps)):\n                fastest_lap_start = fastest_laps[i].iloc[0,:].date_start\n                fastest_lap_duration = fastest_laps[i].iloc[0,:].lap_duration\n                fastest_lap_end = str(pd.to_datetime(fastest_lap_start) + pd.Timedelta(seconds=fastest_lap_duration))\n                fastest_lap_end = re.sub('\\\\s', 'T', fastest_lap_end)\n                #print(selected_driver_number[i])\n\n                car_data_df = api_to_df('car_data',['driver_number='+str(selected_driver_number[i]),'session_key='+str(selected_session_key),'date>='+str(fastest_lap_start),'date<='+str(fastest_lap_end)])\n                car_data_df['date'] = pd.to_datetime(car_data_df.date, format='mixed') - pd.to_datetime(car_data_df.date,format='mixed').min()\n                car_data.append(car_data_df)\n\n                locations_df = api_to_df('location',['driver_number='+str(selected_driver_number[i]),'session_key='+str(selected_session_key),'date>='+str(fastest_lap_start),'date<='+str(fastest_lap_end)])\n                locations_df['date'] = pd.to_datetime(locations_df.date, format='mixed') - pd.to_datetime(locations_df.date,format='mixed').min()\n                start_x = locations_df[locations_df.date == locations_df.date.min()].x.iloc[0]\n                start_y = locations_df[locations_df.date == locations_df.date.min()].y.iloc[0]\n                locations_df['x'] = locations_df.x - start_x\n                locations_df['y'] = locations_df.y - start_y\n                locations.append(locations_df)\n\n                locations[0]['colour'] = selected_driver_colour[0]\n\n            # compare if there are two cars\n            if len(locations) > 1:\n                # map speed (car_data) to x, y position (location)\n                for j in range(len(locations)):\n                    locations[j]['speed'] = -1.0\n                    for i in range(locations[j].shape[0]):\n                        time = locations[j].iloc[i,:].date\n                        #print(pt.x, pt.y, pt.date)\n                        locations[j].loc[i,'speed'] = get_speed_from_car_data(j, time)\n\n                # determine track dominance\n                locations[0]['dominance'] = -99\n                for i in range(locations[0].shape[0]):\n                    x, y, speed = locations[0].iloc[i, :].x, locations[0].iloc[i, :].y, locations[0].iloc[i, :].speed \n                    locations[0].loc[i, 'dominance'] = calc_dominance(x, y, speed)\n\n                # smooth twice\n                smooth = 12\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i+smooth, 'dominance'])[0]\n\n                smooth = 8\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i+smooth, 'dominance'])[0]\n\n\n                for i in range(locations[0].shape[0]):\n                    dominance = locations[0].loc[i, 'dominance']\n                    if dominance == 0:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[0]\n                    elif dominance == 1:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[1]\n                    else:\n                        locations[0].loc[i, 'colour'] = '#00AAAA'\n        else:\n            selected_driver_number = []\n            selected_driver_colour = []\n            car_data = []\n            locations = []\n\n\n        #[print(c.driver_number.unique()) for c in car_data]\n        # print(len(car_data), [c.shape for c in car_data])\n\n    @render_widget\n    def tele_plot():\n        import plotly.express as px\n        import plotly.graph_objects as go\n        \n        fig = go.Figure()\n\n        if input.driver() != '' and len(car_data) > 0:\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = data.date.astype(str)\n                    #data['date'] = (pd.to_datetime(data.date, format='mixed') - pd.to_datetime(data.date,format='mixed').min()).astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace=True)\n                    data['date'] = pd.to_datetime(data.date,format='%M:%S.%f')\n                    data.dropna(inplace=True)\n                    \n                    dr_mask = drivers.driver_number == selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<=.[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n                    \n                    fig.add_trace(go.Scatter(x=data.date, y=data.speed, line=(dict(color=str(selected_driver_colour[i]))) , name=list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template='plotly_dark',\n            plot_bgcolor='black',\n            showlegend=True,\n            legend=dict(yanchor='bottom',y=0.01,xanchor='right',x=0.99,orientation='h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        fig.update_yaxes(title_text='Speed / mph')\n        return fig\n\n    # number = index for driver in drivers\n    def driver_metric(metric_name, num, func, minval, maxval, display_name = None):\n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n\n        if input.driver() != '' and len(car_data) > num:\n            plot_data = car_data.copy()[num]\n\n            #print(plot_data[['throttle']].mean(), selected_driver_colour[num])\n            metric = func(plot_data[[metric_name]]) #plot_data[[metric_name]].mean()\n            ax.barh(0.1, metric, color=str(selected_driver_colour[num]), height = 0.1, align='center')\n            ax.text(maxval, 0.3, str(int(round(metric.iloc[0], 0))), verticalalignment='top', horizontalalignment='right', color='#FFFFFF', fontstyle='oblique', fontweight='bold', fontfamily='sans-serif', fontsize=22)\n            display_name = metric_name if display_name is None else display_name\n            ax.text(0, 0.3, display_name, verticalalignment='top', horizontalalignment='left', color='#FFFFFF', fontstyle='oblique',fontweight='bold', fontfamily='sans-serif', fontsize=14)\n\n\n        #ax.spines['top'].set_visible(False)\n        #ax.spines['left'].set_visible(False)\n        #ax.spines['right'].set_visible(False)\n        #ax.spines['bottom'].set_color('#FFFFFF')\n        ax.axis('off')\n        ax.tick_params(axis='x', colors='#FFFFFF', direction='in')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([])\n        ax.set_xlim(minval, maxval)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor('#111111')\n        fig.patch.set_facecolor('#111111')\n        plt.tight_layout()\n        \n        return fig\n\n    @render.plot\n    def driver0_throttle():\n        return driver_metric('throttle', 0, pd.Series.mean, 0, 100, 'Throttle')\n    \n    @render.plot\n    def driver1_throttle():\n        return driver_metric('throttle', 1, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    def driver0_brake():\n        return driver_metric('brake', 0, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    def driver1_brake():\n        return driver_metric('brake', 1, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    def driver0_topspeed():\n        return driver_metric('speed', 0, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    def driver1_topspeed():\n        return driver_metric('speed', 1, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    def dominance():\n        global locations\n        \n        from matplotlib import pyplot as plt\n        fig, ax = plt.subplots()\n\n        if input.driver() != '' and len(locations) > 0:\n            plot_data = locations.copy()[0]\n            \n            # draw driver0\n            ax.plot(plot_data.x + 70, plot_data.y - 350, c='#FFFFFF', ls='-', lw=10, alpha=0.15)\n            #ax.plot(plot_data.x + 150, plot_data.y - 500, c='#FFFFFF', ls='-', lw=10, alpha=0.2)\n            ax.plot(plot_data.x, plot_data.y, c='#001010', ls='-', lw=6)\n            ax.plot(plot_data.x, plot_data.y, c=selected_driver_colour[0], ls='-', lw=4)\n\n            # work out segments for drawing\n            if len(plot_data.colour.unique()) > 1:\n                current_segment = 0\n                plot_data['segment'] = -1\n                for i in range(plot_data.shape[0]):\n                    plot_data.loc[i, 'segment'] = current_segment\n                    if (i < plot_data.shape[0] - 1) and (plot_data.loc[i, 'dominance'] != plot_data.loc[i+1, 'dominance']):\n                        current_segment += 1\n\n                # only draw driver1 dominant segments\n                plot_data_c = plot_data[plot_data.dominance == 1]\n                for seg in plot_data_c.segment.unique():\n                        plot_segment = plot_data_c[plot_data_c.segment == seg]\n                        if plot_segment.shape[0] > 1:\n                            ax.plot(\n                                plot_segment.x,\n                                plot_segment.y,\n                                c=selected_driver_colour[1],\n                                ls='-',lw=4)\n\n            ax.plot(plot_data.x[0], plot_data.y[0], c='#000000', marker='o', markersize=8)\n            ax.plot(plot_data.x[0], plot_data.y[0], c='#FFFFFF', marker='o', markersize=6)\n\n        ax.axis('off')\n        ax.set_facecolor('#111111')\n        \n        fig.patch.set_facecolor('#111111')\n        return fig\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "backup/f1_telemetry_20240331_2.py", "content": "from shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\nfrom matplotlib import pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom urllib.request import urlopen\nfrom scipy import stats\nimport pandas as pd\nimport json\nimport re\n\n# declare variables\n# lists for drop down selections\nyears: list[str] = ['2023','2024']\nevents: list[str] = None\nsessions: list[str] = None\ndrivers: list[str] = None\n\n# selected from drop down selections\nselected_year: str = None\nselected_meeting_key: str = None\nselected_session_key: str = None\nselected_driver_number: list[str] = []\nselected_driver_colour: list[str] = [None, None]\n\n# telemetry data downloaded retrieved\ncar_data: list[pd.DataFrame] = []\nlocations: list[pd.DataFrame] = []\n\n# colours\nf1_red: str = '#E6002B'\nmain_bg_colour: str = '#111111'\ntext_colour: str = '#FFFFFF'\ntext_grey: str = '#AAAAAA'\ndefault_driver0_colour: str = f1_red # '#1b14e3'\ndefault_driver1_colour: str = text_colour\ndefault_driver_colour: str = '#ae89c4'\ntrack_border_colour: str = '#000000'\ntrack_grey: str = '#001010'\n# tracker_border_colour_driver1: str = text_colour\n\n# action control variables\nrefresh_now: bool = False\n\n# Shiny app layout\napp_ui: ui.page_sidebar = ui.page_sidebar(\n    ui.sidebar(\n        ui.card(\n            ui.input_selectize(\"year\",\"Year: \", choices = years, selected = '2024'),\n            ui.input_selectize(\"event\",\"Event:\", choices = [], selected = 0),\n            ui.input_selectize(\"session\",\"Session:\", choices = []),\n            ui.input_selectize('driver',\"Driver:\", choices = [], multiple = True),\n            ui.input_action_button('refresh','Refresh', class_ = 'btn-success', style = 'color:' + text_colour  + '; background:' + f1_red + 'border: 1px solid ' + text_colour),\n            height = 600,\n            style = 'color:' + text_colour + '; background:' + f1_red,\n        ),\n        ui.output_text('ack'), width = '320px',\n        bg = f1_red,\n        fg = text_colour,\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver0\"),height = 80, style = 'background:' + main_bg_colour)),\n        ui.column(6, ui.output_text(\"header\"),ui.output_text(\"sub_head\"), height = 80, style = 'text-align:center; line-height:2; font-size:1.6em; font-weight:bold; color:' + text_colour + '; background:' + main_bg_colour + '; border: 1px solid ' + f1_red),\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height = 80, style = 'background:' + main_bg_colour))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver0_throttle\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver0_brake\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver0_topspeed\"), height = 100, style = 'background:' + main_bg_colour),\n            height = 400,\n            style = 'background:' + main_bg_colour,\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver1_brake\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver1_topspeed\"), height = 100, style = 'background:' + main_bg_colour),\n            height = 400,\n            style = 'background:' + main_bg_colour\n            )\n        ),\n    ),\n    ui.row(\n        ui.output_plot('dominance'),\n        height = 250,\n    ),\n    style = 'background:' + main_bg_colour\n)\n\ndef server(input, output, session):\n    def get_event_name(idx: int) -> str:\n        return events.event_name[idx]\n\n    def get_driver_name(idx: int) -> str:\n        return drivers.full_name[idx]\n\n    def get_driver_name_acronym(idx: int) -> str:\n        return drivers.name_acronym[idx]\n\n    def get_driver_num(idx: int) -> str:\n        return str(drivers.driver_number[idx])\n\n    def get_session_name(idx: int) -> str:\n        return sessions.session_name[idx]\n\n    def api_to_df(call_type: str, filters: list[str]) -> pd.DataFrame:\n        call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n        for f in filters:\n            if call_str[-1]  ==  '?':\n                call_str  +=  f\n            else:\n                call_str  +=  '&' + f\n\n        response = urlopen(call_str)\n        return pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n    def format_driver_names(driver_idx: int) -> str:\n        names = get_driver_name(driver_idx).split()\n        return '\\n'.join([names[0],' '.join(names[1:])]), get_driver_name_acronym(driver_idx)\n\n    def plot_names(front_name: str, back_name: str) -> plt.figure:\n        fig, ax = plt.subplots()\n        ax.text(0, 1, back_name, verticalalignment = 'top', horizontalalignment = 'left', color = text_grey, clip_on = False, fontstyle = 'oblique', fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 36, alpha = 0.2)\n        ax.text(1, 1, front_name, verticalalignment = 'top', horizontalalignment = 'right', color = text_colour, fontstyle = 'italic', fontfamily = 'sans-serif', fontsize = 13)\n        fig.patch.set_facecolor(main_bg_colour)\n        ax.set_facecolor(main_bg_colour)\n        ax.axis('off')\n        plt.tight_layout(pad = 0)\n        return fig\n\n    # number = index for driver in drivers\n    def driver_metric(metric_name, num, func, minval, maxval, display_name = None) -> plt.figure:\n        fig, ax = plt.subplots()\n\n        if input.driver() !=  '' and len(car_data) > num:\n            plot_data = car_data.copy()[num]\n\n            #print(plot_data[['throttle']].mean(), selected_driver_colour[num])\n            metric = func(plot_data[[metric_name]]) #plot_data[[metric_name]].mean()\n            ax.barh(0.1, metric, color = str(selected_driver_colour[num]), height = 0.1, align = 'center')\n            ax.text(maxval, 0.3, str(int(round(metric.iloc[0], 0))), verticalalignment = 'top', horizontalalignment = 'right', color = text_colour, fontstyle = 'oblique', fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 22)\n            display_name = metric_name if display_name is None else display_name\n            ax.text(0, 0.3, display_name, verticalalignment = 'top', horizontalalignment = 'left', color = text_colour, fontstyle = 'oblique',fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 14)\n\n        ax.axis('off')\n        ax.tick_params(axis = 'x', colors = text_colour, direction = 'in')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([])\n        ax.set_xlim(minval, maxval)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor(main_bg_colour)\n        fig.patch.set_facecolor(main_bg_colour)\n        plt.tight_layout()\n\n        return fig\n\n    \n    @render.text\n    def ack() -> str:\n        return 'Credit to the open-sourced OpenF1.org API (https://openf1.org/) for the Formula One\u00ae telemetry data used in this dashboard'\n\n    @reactive.effect\n    def update_event_list_with_year() -> None:\n        global events\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global location\n\n        selected_year = input.year()\n\n        #response = urlopen('https://api.openf1.org/v1/meetings?year = ' + selected_year)\n        #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n        df = api_to_df('meetings', ['year=' + str(selected_year)])\n\n        if df.shape[0] > 0:\n            try:\n                events = pd.concat([\n                    df.circuit_short_name,\n                    df.location,\n                    df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                    df.meeting_key,],axis = 1)\\\n                    .rename(columns = {'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n                ui.update_selectize(\"event\",choices = events.event_name)\n\n            except:\n                pass\n        else:\n            ui.update_selectize(\"event\",choices = [])\n\n            selected_year = None\n            events = None\n            selected_meeting_key = None\n\n        ui.update_selectize(\"session\",choices = [])\n        ui.update_selectize(\"driver\",choices = [])\n\n        sessions = None\n        selected_session_key = None\n        drivers = []\n        selected_driver_colour = []\n        selected_driver_number = []\n        car_data = []\n        locations = []\n\n    @render.text\n    def header() -> str:\n        if input.event():\n            event_name = get_event_name(int(input.event()))\n            return input.year() + ' ' + event_name if event_name !=  None else input.year()\n\n    @render.text\n    def sub_head() -> str:\n        if input.session():\n            session_name = get_session_name(int(input.session()))\n            return session_name if session_name !=  None else ''\n\n    @reactive.effect\n    def update_session_list_with_event() -> None:\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global car_data\n        global locations\n\n        if input.year() and input.event():\n            selected_meeting_key = events.meeting_key[int(input.event())]\n\n            #response = urlopen('https://api.openf1.org/v1/sessions?year = ' + str(selected_year) + '&meeting_key = ' + str(selected_meeting_key))\n            #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n            df = api_to_df('sessions', ['year=' + str(selected_year),'meeting_key=' + str(selected_meeting_key)])\n\n            sessions = pd.concat([\n                df.session_key,\n                df.date_start,\n                df.session_type,\n                df.session_name], axis = 1)\n\n            ui.update_selectize(\"session\",choices = sessions.session_name)\n        else:\n            ui.update_selectize(\"session\",choices = [])\n\n            sessions = None\n            selected_session_key = None\n\n        ui.update_selectize(\"driver\", choices = [])\n        drivers = None\n        car_data = []\n        selected_driver_colour = []\n        selected_driver_number = []\n        locations = []\n\n    @reactive.effect\n    def update_driver_list_with_session() -> None:\n        global sessions\n        global drivers\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global locations\n\n        if len(input.session()) > 0:\n            selected_session_key = sessions.session_key[int(input.session())]\n\n            response = urlopen('https://api.openf1.org/v1/drivers?session_key=' + str(selected_session_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n            if df.shape[0] > 0:\n                try:\n                    global drivers\n\n                    drivers = pd.concat([\n                        df.driver_number,\n                        df.name_acronym,\n                        df.full_name,\n                        df.team_name,\n                        df.team_colour,\n                        df.headshot_url,\n                        df.country_code], axis = 1)\n\n                    drivers['team_name'] = drivers['team_name'].fillna('#NA')\n                    ui.update_selectize(\"driver\", choices = drivers.full_name + \" (\" + drivers.team_name + \")\")\n                except:\n                    pass\n            else:\n                ui.update_selectize(\"driver\", choices = [])\n\n                drivers = []\n\n            car_data = []\n            selected_driver_number = []\n            selected_driver_colour = []\n            locations = []\n\n    @render.plot\n    #@reactive.event(input.refresh, ignore_none = False)\n    def driver0() -> plt.figure:\n        if input.driver():\n            front_name, back_name = format_driver_names(int(input.driver()[0]))\n            return plot_names(front_name, back_name)\n\n    @render.plot\n    #@reactive.event(input.refresh, ignore_none = False)\n    def driver1() -> plt.figure:\n        if len(input.driver())  ==  2:\n            front_name, back_name = format_driver_names(int(input.driver()[1]))\n            return plot_names(front_name, back_name)\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    @reactive.event(input.refresh, ignore_none = False)\n    def update_cardata_with_driver() -> None:\n        global car_data\n        global locations\n        global selected_driver_number\n        global selected_driver_colour\n\n        if input.driver():\n            print(get_driver_num(int(input.driver()[0])), input.driver(), selected_driver_number)\n\n        # helper functions to map speed to car x, y position on track and determine which car is faster (dominant)\n        def get_speed_from_car_data(idx: int, time: pd._libs.tslibs.timedeltas.Timedelta) -> float:\n            global car_data\n            before = car_data[idx].date < time\n            after = car_data[idx].date >=  time\n            speed_before = -1 if len(car_data[idx][before].speed)  ==  0 else car_data[idx][before].speed.iloc[-1]\n            speed_after = -1 if len(car_data[idx][after].speed)  ==  0 else car_data[idx][after].speed.iloc[0]\n            return (speed_before + speed_after) / 2\n\n        # return 0 = first car is faster\n        # return 1 = second car is faster\n        # return -1 = same speed\n        def calc_dominance(x: int, y: int, speed: float) -> int:\n            global locations\n            loc1 = locations[1].copy()\n            loc1['dist'] = abs(loc1.x - x) + abs(loc1.y - y)\n            second_car_speed = loc1[loc1.dist  ==  loc1.dist.min()].speed.iloc[0]\n            if speed > second_car_speed:\n                return 0\n            elif speed < second_car_speed:\n                return 1\n            else:\n                return -1\n\n        # print(input.driver())\n        if len(input.driver()) > 0 and len(input.driver()) <=  2:\n\n            fastest_lap_start = None\n            fastest_lap_end = None\n\n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            selected_driver_colour = ['#' + str(drivers.team_colour[int(d)]) if drivers.team_colour[int(d)] is not None else default_driver_colour for d in input.driver()]\n\n            # if both driver/team colour are missing | if both driver/team colour are the same\n            if len(selected_driver_colour) > 1:\n                if  (selected_driver_colour[0]  ==  selected_driver_colour[1]): # or (selected_driver_colour[0] is None and selected_driver_colour[1] is None)\n                    selected_driver_colour = [default_driver0_colour, default_driver1_colour]\n\n            #print(selected_driver_number, selected_driver_colour)\n\n            #responses = [urlopen('https://api.openf1.org/v1/laps?session_key = ' + str(selected_session_key) + '&driver_number = ' + str(d)) for d in selected_driver_number]\n            #responses = [pd.DataFrame(json.loads(r.read().decode('utf-8'))) for r in responses]\n            responses = [api_to_df('laps',['session_key=' + str(selected_session_key),'driver_number=' + str(d)]) for d in selected_driver_number]\n\n            #[print(r.columns) for r in responses]\n            fastest_laps = [\n                r[(r.lap_duration  ==  r.lap_duration.min()) &\n                  -r.duration_sector_3.isna()]\n                for r in responses]\n            #print(fastest_laps)\n\n            car_data = []\n            locations = []\n            for i in range(len(fastest_laps)):\n                fastest_lap_start = fastest_laps[i].iloc[0,:].date_start\n                fastest_lap_duration = fastest_laps[i].iloc[0,:].lap_duration\n                fastest_lap_end = str(pd.to_datetime(fastest_lap_start) + pd.Timedelta(seconds = fastest_lap_duration))\n                fastest_lap_end = re.sub('\\\\s', 'T', fastest_lap_end)\n                #print(selected_driver_number[i])\n\n                car_data_df = api_to_df('car_data',['driver_number=' + str(selected_driver_number[i]),'session_key=' + str(selected_session_key),'date>=' + str(fastest_lap_start),'date<=' + str(fastest_lap_end)])\n                car_data_df['date'] = pd.to_datetime(car_data_df.date, format = 'mixed') - pd.to_datetime(car_data_df.date,format = 'mixed').min()\n                car_data.append(car_data_df)\n\n                locations_df = api_to_df('location',['driver_number=' + str(selected_driver_number[i]),'session_key=' + str(selected_session_key),'date>=' + str(fastest_lap_start),'date<=' + str(fastest_lap_end)])\n                locations_df['date'] = pd.to_datetime(locations_df.date, format = 'mixed') - pd.to_datetime(locations_df.date,format = 'mixed').min()\n                start_x = locations_df[locations_df.date  ==  locations_df.date.min()].x.iloc[0]\n                start_y = locations_df[locations_df.date  ==  locations_df.date.min()].y.iloc[0]\n                locations_df['x'] = locations_df.x - start_x\n                locations_df['y'] = locations_df.y - start_y\n                locations.append(locations_df)\n\n                locations[0]['colour'] = selected_driver_colour[0]\n\n            # compare if there are two cars\n            if len(locations) > 1:\n                # map speed (car_data) to x, y position (location)\n                for j in range(len(locations)):\n                    locations[j]['speed'] = -1.0\n                    for i in range(locations[j].shape[0]):\n                        time = locations[j].iloc[i,:].date\n                        #print(pt.x, pt.y, pt.date)\n                        locations[j].loc[i,'speed'] = get_speed_from_car_data(j, time)\n\n                # determine track dominance\n                locations[0]['dominance'] = -99\n                for i in range(locations[0].shape[0]):\n                    x, y, speed = locations[0].iloc[i, :].x, locations[0].iloc[i, :].y, locations[0].iloc[i, :].speed\n                    locations[0].loc[i, 'dominance'] = calc_dominance(x, y, speed)\n\n                # smooth twice\n                smooth = 12\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i + smooth, 'dominance'])[0]\n\n                smooth = 8\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i + smooth, 'dominance'])[0]\n\n\n                for i in range(locations[0].shape[0]):\n                    dominance = locations[0].loc[i, 'dominance']\n                    if dominance  ==  0:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[0]\n                    elif dominance  ==  1:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[1]\n                    else:\n                        locations[0].loc[i, 'colour'] = '#00AAAA'\n        else:\n            selected_driver_number = []\n            selected_driver_colour = []\n            car_data = []\n            locations = []\n\n\n        #[print(c.driver_number.unique()) for c in car_data]\n        # print(len(car_data), [c.shape for c in car_data])\n\n    @render_widget\n    @reactive.event(input.refresh, ignore_none = False)\n    def tele_plot() -> go.Figure:\n        fig = go.Figure()\n\n        if input.driver() !=  '' and len(car_data) > 0:\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = data.date.astype(str)\n                    #data['date'] = (pd.to_datetime(data.date, format = 'mixed') - pd.to_datetime(data.date,format = 'mixed').min()).astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace = True)\n                    data['date'] = pd.to_datetime(data.date,format = '%M:%S.%f')\n                    data.dropna(inplace = True)\n\n                    dr_mask = drivers.driver_number  ==  selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<= .[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n\n                    fig.add_trace(go.Scatter(x = data.date, y = data.speed, line = (dict(color = str(selected_driver_colour[i]))) , name = list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template = 'plotly_dark',\n            plot_bgcolor = 'black',\n            showlegend = True,\n            legend = dict(yanchor = 'bottom',y = 0.01,xanchor = 'right',x = 0.99,orientation = 'h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        fig.update_yaxes(title_text = 'Speed / mph')\n        return fig\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_throttle() -> plt.figure:\n        return driver_metric('throttle', 0, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_throttle() -> plt.figure:\n        return driver_metric('throttle', 1, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_brake() -> plt.figure:\n        return driver_metric('brake', 0, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_brake() -> plt.figure:\n        return driver_metric('brake', 1, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_topspeed() -> plt.figure:\n        return driver_metric('speed', 0, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_topspeed() -> plt.figure:\n        return driver_metric('speed', 1, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def dominance() -> go.Figure:\n        global locations\n\n        fig, ax = plt.subplots()\n\n        if input.driver() !=  '' and len(locations) > 0:\n            plot_data = locations.copy()[0]\n\n            # draw driver0\n            ax.plot(plot_data.x + 70, plot_data.y - 350, c = text_colour, ls = '-', lw = 10, alpha = 0.15)\n            ax.plot(plot_data.x, plot_data.y, c = track_grey, ls = '-', lw = 6)\n            ax.plot(plot_data.x, plot_data.y, c = selected_driver_colour[0], ls = '-', lw = 4)\n\n            # work out segments for drawing\n            if len(plot_data.colour.unique()) > 1:\n                current_segment = 0\n                plot_data['segment'] = -1\n                for i in range(plot_data.shape[0]):\n                    plot_data.loc[i, 'segment'] = current_segment\n                    if (i < plot_data.shape[0] - 1) and (plot_data.loc[i, 'dominance'] !=  plot_data.loc[i + 1, 'dominance']):\n                        current_segment  +=  1\n\n                # only draw driver1 dominant segments\n                plot_data_c = plot_data[plot_data.dominance  ==  1]\n                for seg in plot_data_c.segment.unique():\n                        plot_segment = plot_data_c[plot_data_c.segment  ==  seg]\n                        if plot_segment.shape[0] > 1:\n                            # ax.plot(plot_segment.x, plot_segment.y, c = tracker_border_colour_driver1, ls = '-', lw = 6)\n                            ax.plot(plot_segment.x, plot_segment.y, c = selected_driver_colour[1], ls = '-', lw = 4)\n\n            ax.plot(plot_data.x[0], plot_data.y[0], c = track_border_colour, marker = 'o', markersize = 8)\n            ax.plot(plot_data.x[0], plot_data.y[0], c = text_colour, marker = 'o', markersize = 6)\n\n        ax.axis('off')\n        ax.set_facecolor(main_bg_colour)\n\n        fig.patch.set_facecolor(main_bg_colour)\n        return fig\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "backup/f1_telemetry_20240331_3.py", "content": "from shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\nfrom matplotlib import pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom urllib.request import urlopen\nfrom scipy import stats\nimport pandas as pd\nimport json\nimport re\n\n# declare variables\n# lists for drop down selections\nyears: list[str] = ['2023','2024']\nevents: list[str] = None\nsessions: list[str] = None\ndrivers: list[str] = None\n\n# selected from drop down selections\nselected_year: str = None\nselected_meeting_key: str = None\nselected_session_key: str = None\nselected_driver_number: list[str] = []\nselected_driver_colour: list[str] = [None, None]\n\n# telemetry data downloaded retrieved\ncar_data: list[pd.DataFrame] = []\nlocations: list[pd.DataFrame] = []\n\n# colours\nf1_red: str = '#E6002B'\nmain_bg_colour: str = '#111111'\ntext_colour: str = '#FFFFFF'\ntext_grey: str = '#AAAAAA'\ndefault_driver0_colour: str = f1_red # '#1b14e3'\ndefault_driver1_colour: str = text_colour\ndefault_driver_colour: str = '#ae89c4'\ntrack_border_colour: str = '#000000'\ntrack_grey: str = '#001010'\n# tracker_border_colour_driver1: str = text_colour\n\n# action control variables\nrefresh_now: bool = False\n\n# Shiny app layout\napp_ui: ui.page_sidebar = ui.page_sidebar(\n    ui.sidebar(\n        ui.card(\n            ui.input_selectize(\"year\",\"Year: \", choices = years, selected = '2024'),\n            ui.input_selectize(\"event\",\"Event:\", choices = [], selected = 0),\n            ui.input_selectize(\"session\",\"Session:\", choices = []),\n            ui.input_selectize('driver',\"Driver:\", choices = [], multiple = True),\n            ui.input_action_button('refresh','Refresh', class_ = 'btn-success', style = 'color:' + text_colour  + '; background:' + f1_red + 'border: 1px solid ' + text_colour),\n            height = 600,\n            style = 'color:' + text_colour + '; background:' + f1_red,\n        ),\n        ui.output_text('ack'), width = '320px',\n        bg = f1_red,\n        fg = text_colour,\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver0\"),height = 80, style = 'background:' + main_bg_colour)),\n        ui.column(6, ui.output_text(\"header\"),ui.output_text(\"sub_head\"), height = 80, style = 'text-align:center; line-height:2; font-size:1.6em; font-weight:bold; color:' + text_colour + '; background:' + main_bg_colour + '; border: 1px solid ' + f1_red),\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height = 80, style = 'background:' + main_bg_colour))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver0_throttle\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver0_brake\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver0_topspeed\"), height = 100, style = 'background:' + main_bg_colour),\n            height = 400,\n            style = 'background:' + main_bg_colour,\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver1_brake\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver1_topspeed\"), height = 100, style = 'background:' + main_bg_colour),\n            height = 400,\n            style = 'background:' + main_bg_colour\n            )\n        ),\n    ),\n    ui.row(\n        ui.output_plot('dominance'),\n        height = 250,\n    ),\n    style = 'background:' + main_bg_colour\n)\n\ndef server(input, output, session):\n    def get_event_name(idx: int) -> str:\n        return events.event_name[idx]\n\n    def get_driver_name(idx: int) -> str:\n        return drivers.full_name[idx]\n\n    def get_driver_name_acronym(idx: int) -> str:\n        return drivers.name_acronym[idx]\n\n    def get_driver_num(idx: int) -> str:\n        return str(drivers.driver_number[idx])\n\n    def get_session_name(idx: int) -> str:\n        return sessions.session_name[idx]\n\n    def api_to_df(call_type: str, filters: list[str]) -> pd.DataFrame:\n        call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n        for f in filters:\n            if call_str[-1]  ==  '?':\n                call_str  +=  f\n            else:\n                call_str  +=  '&' + f\n\n        response = urlopen(call_str)\n        return pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n    def format_driver_names(driver_idx: int) -> str:\n        names = get_driver_name(driver_idx).split()\n        return '\\n'.join([names[0],' '.join(names[1:])]), get_driver_name_acronym(driver_idx)\n\n    def plot_names(front_name: str, back_name: str) -> plt.figure:\n        fig, ax = plt.subplots()\n        ax.text(0, 1, back_name, verticalalignment = 'top', horizontalalignment = 'left', color = text_grey, clip_on = False, fontstyle = 'oblique', fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 36, alpha = 0.2)\n        ax.text(1, 1, front_name, verticalalignment = 'top', horizontalalignment = 'right', color = text_colour, fontstyle = 'italic', fontfamily = 'sans-serif', fontsize = 13)\n        fig.patch.set_facecolor(main_bg_colour)\n        ax.set_facecolor(main_bg_colour)\n        ax.axis('off')\n        plt.tight_layout(pad = 0)\n        return fig\n\n    # number = index for driver in drivers\n    def driver_metric(metric_name, idx, func, minval, maxval, display_name = None) -> plt.figure:\n        fig, ax = plt.subplots()\n\n        if input.driver() !=  '' and len(car_data) > idx:\n            plot_data = car_data.copy()[idx]\n\n            #print(plot_data[['throttle']].mean(), selected_driver_colour[num])\n            metric = func(plot_data[[metric_name]]) #plot_data[[metric_name]].mean()\n            ax.barh(0.1, metric, color = str(selected_driver_colour[idx]), height = 0.1, align = 'center')\n            ax.text(maxval, 0.3, str(int(round(metric.iloc[0], 0))), verticalalignment = 'top', horizontalalignment = 'right', color = text_colour, fontstyle = 'oblique', fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 22)\n            display_name = metric_name if display_name is None else display_name\n            ax.text(0, 0.3, display_name, verticalalignment = 'top', horizontalalignment = 'left', color = text_colour, fontstyle = 'oblique',fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 14)\n\n        ax.axis('off')\n        ax.tick_params(axis = 'x', colors = text_colour, direction = 'in')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([])\n        ax.set_xlim(minval, maxval)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor(main_bg_colour)\n        fig.patch.set_facecolor(main_bg_colour)\n        plt.tight_layout()\n\n        return fig\n\n    \n    @render.text\n    def ack() -> str:\n        return 'Credit to the open-sourced OpenF1.org API (https://openf1.org/) for the Formula One\u00ae telemetry data used in this dashboard'\n\n    @reactive.effect\n    def update_event_list_with_year() -> None:\n        global events\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global location\n\n        selected_year = input.year()\n\n        #response = urlopen('https://api.openf1.org/v1/meetings?year = ' + selected_year)\n        #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n        df = api_to_df('meetings', ['year=' + str(selected_year)])\n\n        if df.shape[0] > 0:\n            try:\n                events = pd.concat([\n                    df.circuit_short_name,\n                    df.location,\n                    df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                    df.meeting_key,],axis = 1)\\\n                    .rename(columns = {'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n                ui.update_selectize(\"event\",choices = events.event_name)\n\n            except:\n                pass\n        else:\n            ui.update_selectize(\"event\",choices = [])\n\n            selected_year = None\n            events = None\n            selected_meeting_key = None\n\n        ui.update_selectize(\"session\",choices = [])\n        ui.update_selectize(\"driver\",choices = [])\n\n        sessions = None\n        selected_session_key = None\n        drivers = []\n        selected_driver_colour = []\n        selected_driver_number = []\n        car_data = []\n        locations = []\n\n    @render.text\n    def header() -> str:\n        if input.event():\n            event_name = get_event_name(int(input.event()))\n            return input.year() + ' ' + event_name if event_name !=  None else input.year()\n\n    @render.text\n    def sub_head() -> str:\n        if input.session():\n            session_name = get_session_name(int(input.session()))\n            return session_name if session_name !=  None else ''\n\n    @reactive.effect\n    def update_session_list_with_event() -> None:\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global car_data\n        global locations\n\n        if input.year() and input.event():\n            selected_meeting_key = events.meeting_key[int(input.event())]\n\n            #response = urlopen('https://api.openf1.org/v1/sessions?year = ' + str(selected_year) + '&meeting_key = ' + str(selected_meeting_key))\n            #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n            df = api_to_df('sessions', ['year=' + str(selected_year),'meeting_key=' + str(selected_meeting_key)])\n\n            sessions = pd.concat([\n                df.session_key,\n                df.date_start,\n                df.session_type,\n                df.session_name], axis = 1)\n\n            ui.update_selectize(\"session\",choices = sessions.session_name)\n        else:\n            ui.update_selectize(\"session\",choices = [])\n\n            sessions = None\n            selected_session_key = None\n\n        ui.update_selectize(\"driver\", choices = [])\n        drivers = None\n        car_data = []\n        selected_driver_colour = []\n        selected_driver_number = []\n        locations = []\n\n    @reactive.effect\n    def update_driver_list_with_session() -> None:\n        global sessions\n        global drivers\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global locations\n\n        if len(input.session()) > 0:\n            selected_session_key = sessions.session_key[int(input.session())]\n\n            response = urlopen('https://api.openf1.org/v1/drivers?session_key=' + str(selected_session_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n            if df.shape[0] > 0:\n                try:\n                    global drivers\n\n                    drivers = pd.concat([\n                        df.driver_number,\n                        df.name_acronym,\n                        df.full_name,\n                        df.team_name,\n                        df.team_colour,\n                        df.headshot_url,\n                        df.country_code], axis = 1)\n\n                    drivers['team_name'] = drivers['team_name'].fillna('#NA')\n                    ui.update_selectize(\"driver\", choices = drivers.full_name + \" (\" + drivers.team_name + \")\")\n                except:\n                    pass\n            else:\n                ui.update_selectize(\"driver\", choices = [])\n\n                drivers = []\n\n            car_data = []\n            selected_driver_number = []\n            selected_driver_colour = []\n            locations = []\n\n    @render.plot\n    #@reactive.event(input.refresh, ignore_none = False)\n    def driver0() -> plt.figure:\n        if input.driver():\n            front_name, back_name = format_driver_names(int(input.driver()[0]))\n            return plot_names(front_name, back_name)\n\n    @render.plot\n    #@reactive.event(input.refresh, ignore_none = False)\n    def driver1() -> plt.figure:\n        if len(input.driver())  ==  2:\n            front_name, back_name = format_driver_names(int(input.driver()[1]))\n            return plot_names(front_name, back_name)\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    @reactive.event(input.refresh, ignore_none = False)\n    def update_cardata_with_driver() -> None:\n        global car_data\n        global locations\n        global selected_driver_number\n        global selected_driver_colour\n\n        if input.driver():\n            print(get_driver_num(int(input.driver()[0])), input.driver(), selected_driver_number)\n\n        # helper functions to map speed to car x, y position on track and determine which car is faster (dominant)\n        def get_speed_from_car_data(idx: int, time: pd._libs.tslibs.timedeltas.Timedelta) -> float:\n            global car_data\n            before = car_data[idx].date < time\n            after = car_data[idx].date >=  time\n            speed_before = -1 if len(car_data[idx][before].speed)  ==  0 else car_data[idx][before].speed.iloc[-1]\n            speed_after = -1 if len(car_data[idx][after].speed)  ==  0 else car_data[idx][after].speed.iloc[0]\n            return (speed_before + speed_after) / 2\n\n        # return 0 = first car is faster\n        # return 1 = second car is faster\n        # return -1 = same speed\n        def calc_dominance(x: int, y: int, speed: float) -> int:\n            global locations\n            loc1 = locations[1].copy()\n            loc1['dist'] = abs(loc1.x - x) + abs(loc1.y - y)\n            second_car_speed = loc1[loc1.dist  ==  loc1.dist.min()].speed.iloc[0]\n            if speed > second_car_speed:\n                return 0\n            elif speed < second_car_speed:\n                return 1\n            else:\n                return -1\n\n        # print(input.driver())\n        if len(input.driver()) > 0 and len(input.driver()) <=  2:\n\n            fastest_lap_start = None\n            fastest_lap_end = None\n\n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            selected_driver_colour = ['#' + str(drivers.team_colour[int(d)]) if drivers.team_colour[int(d)] is not None else default_driver_colour for d in input.driver()]\n\n            # if both driver/team colour are missing | if both driver/team colour are the same\n            if len(selected_driver_colour) > 1:\n                if  (selected_driver_colour[0]  ==  selected_driver_colour[1]): # or (selected_driver_colour[0] is None and selected_driver_colour[1] is None)\n                    selected_driver_colour = [default_driver0_colour, default_driver1_colour]\n\n            responses = [api_to_df('laps',['session_key=' + str(selected_session_key),'driver_number=' + str(d)]) for d in selected_driver_number]\n\n            fastest_laps = [\n                r[(r.lap_duration  ==  r.lap_duration.min()) &\n                  -r.duration_sector_3.isna()]\n                for r in responses]\n\n            car_data = []\n            locations = []\n            for i in range(len(fastest_laps)):\n                fastest_lap_start = fastest_laps[i].iloc[0,:].date_start\n                fastest_lap_duration = fastest_laps[i].iloc[0,:].lap_duration\n                fastest_lap_end = str(pd.to_datetime(fastest_lap_start) + pd.Timedelta(seconds = fastest_lap_duration))\n                fastest_lap_end = re.sub('\\\\s', 'T', fastest_lap_end)\n\n                car_data_df = api_to_df('car_data',['driver_number=' + str(selected_driver_number[i]),'session_key=' + str(selected_session_key),'date>=' + str(fastest_lap_start),'date<=' + str(fastest_lap_end)])\n                car_data_df['date'] = pd.to_datetime(car_data_df.date, format = 'mixed') - pd.to_datetime(car_data_df.date,format = 'mixed').min()\n                car_data.append(car_data_df)\n\n                locations_df = api_to_df('location',['driver_number=' + str(selected_driver_number[i]),'session_key=' + str(selected_session_key),'date>=' + str(fastest_lap_start),'date<=' + str(fastest_lap_end)])\n                locations_df['date'] = pd.to_datetime(locations_df.date, format = 'mixed') - pd.to_datetime(locations_df.date,format = 'mixed').min()\n                start_x = locations_df[locations_df.date  ==  locations_df.date.min()].x.iloc[0]\n                start_y = locations_df[locations_df.date  ==  locations_df.date.min()].y.iloc[0]\n                locations_df['x'] = locations_df.x - start_x\n                locations_df['y'] = locations_df.y - start_y\n                locations.append(locations_df)\n\n                locations[0]['colour'] = selected_driver_colour[0]\n\n            # compare if there are two cars\n            if len(locations) > 1:\n                # map speed (car_data) to x, y position (location)\n                for j in range(len(locations)):\n                    locations[j]['speed'] = -1.0\n                    for i in range(locations[j].shape[0]):\n                        time = locations[j].iloc[i,:].date\n                        #print(pt.x, pt.y, pt.date)\n                        locations[j].loc[i,'speed'] = get_speed_from_car_data(j, time)\n\n                # determine track dominance\n                locations[0]['dominance'] = -99\n                for i in range(locations[0].shape[0]):\n                    x, y, speed = locations[0].iloc[i, :].x, locations[0].iloc[i, :].y, locations[0].iloc[i, :].speed\n                    locations[0].loc[i, 'dominance'] = calc_dominance(x, y, speed)\n\n                # smooth twice\n                smooth = 12\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i + smooth, 'dominance'])[0]\n\n                smooth = 8\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i + smooth, 'dominance'])[0]\n\n\n                for i in range(locations[0].shape[0]):\n                    dominance = locations[0].loc[i, 'dominance']\n                    if dominance  ==  0:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[0]\n                    elif dominance  ==  1:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[1]\n                    else:\n                        locations[0].loc[i, 'colour'] = '#00AAAA'\n        else:\n            selected_driver_number = []\n            selected_driver_colour = []\n            car_data = []\n            locations = []\n\n\n        #[print(c.driver_number.unique()) for c in car_data]\n        # print(len(car_data), [c.shape for c in car_data])\n\n    @render_widget\n    @reactive.event(input.refresh, ignore_none = False)\n    def tele_plot() -> go.Figure:\n        fig = go.Figure()\n\n        if input.driver() !=  '' and len(car_data) > 0:\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = data.date.astype(str)\n                    #data['date'] = (pd.to_datetime(data.date, format = 'mixed') - pd.to_datetime(data.date,format = 'mixed').min()).astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace = True)\n                    data['date'] = pd.to_datetime(data.date,format = '%M:%S.%f')\n                    data.dropna(inplace = True)\n\n                    dr_mask = drivers.driver_number  ==  selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<= .[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n\n                    fig.add_trace(go.Scatter(x = data.date, y = data.speed, line = (dict(color = str(selected_driver_colour[i]))) , name = list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template = 'plotly_dark',\n            plot_bgcolor = 'black',\n            showlegend = True,\n            legend = dict(yanchor = 'bottom',y = 0.01,xanchor = 'right',x = 0.99,orientation = 'h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        fig.update_yaxes(title_text = 'Speed / mph')\n        return fig\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_throttle() -> plt.figure:\n        return driver_metric('throttle', 0, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_throttle() -> plt.figure:\n        return driver_metric('throttle', 1, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_brake() -> plt.figure:\n        return driver_metric('brake', 0, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_brake() -> plt.figure:\n        return driver_metric('brake', 1, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_topspeed() -> plt.figure:\n        return driver_metric('speed', 0, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_topspeed() -> plt.figure:\n        return driver_metric('speed', 1, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def dominance() -> go.Figure:\n        global locations\n\n        fig, ax = plt.subplots()\n\n        if input.driver() !=  '' and len(locations) > 0:\n            plot_data = locations.copy()[0]\n\n            # draw driver0\n            ax.plot(plot_data.x + 70, plot_data.y - 350, c = text_colour, ls = '-', lw = 10, alpha = 0.15)\n            ax.plot(plot_data.x, plot_data.y, c = track_grey, ls = '-', lw = 6)\n            ax.plot(plot_data.x, plot_data.y, c = selected_driver_colour[0], ls = '-', lw = 4)\n\n            # work out segments for drawing\n            if len(plot_data.colour.unique()) > 1:\n                current_segment = 0\n                plot_data['segment'] = -1\n                for i in range(plot_data.shape[0]):\n                    plot_data.loc[i, 'segment'] = current_segment\n                    if (i < plot_data.shape[0] - 1) and (plot_data.loc[i, 'dominance'] !=  plot_data.loc[i + 1, 'dominance']):\n                        current_segment  +=  1\n\n                # only draw driver1 dominant segments\n                plot_data_c = plot_data[plot_data.dominance  ==  1]\n                for seg in plot_data_c.segment.unique():\n                        plot_segment = plot_data_c[plot_data_c.segment  ==  seg]\n                        if plot_segment.shape[0] > 1:\n                            # ax.plot(plot_segment.x, plot_segment.y, c = tracker_border_colour_driver1, ls = '-', lw = 6)\n                            ax.plot(plot_segment.x, plot_segment.y, c = selected_driver_colour[1], ls = '-', lw = 4)\n\n            ax.plot(plot_data.x[0], plot_data.y[0], c = track_border_colour, marker = 'o', markersize = 8)\n            ax.plot(plot_data.x[0], plot_data.y[0], c = text_colour, marker = 'o', markersize = 6)\n\n        ax.axis('off')\n        ax.set_facecolor(main_bg_colour)\n\n        fig.patch.set_facecolor(main_bg_colour)\n        return fig\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "backup/f1_telemetry_20240331_4.py", "content": "from shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\nfrom matplotlib import pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom urllib.request import urlopen\nfrom scipy import stats\nimport pandas as pd\nimport json\nimport re\n\n# declare variables\n# lists for drop down selections\nyears: list[str] = ['2023','2024']\nevents: list[str] = None\nsessions: list[str] = None\ndrivers: list[str] = None\n\n# selected from drop down selections\nselected_year: str = None\nselected_meeting_key: str = None\nselected_session_key: str = None\nselected_driver_number: list[str] = []\nselected_driver_colour: list[str] = [None, None]\n\n# telemetry data downloaded retrieved\ncar_data: list[pd.DataFrame] = []\nlocations: list[pd.DataFrame] = []\n\n# colours\nf1_red: str = '#E6002B'\nmain_bg_colour: str = '#111111'\ntext_colour: str = '#FFFFFF'\ntext_grey: str = '#AAAAAA'\ndefault_driver0_colour: str = f1_red # '#1b14e3'\ndefault_driver1_colour: str = text_colour\ndefault_driver_colour: str = '#ae89c4'\ntrack_border_colour: str = '#000000'\ntrack_grey: str = '#001010'\n# tracker_border_colour_driver1: str = text_colour\n\n# action control variables\nrefresh_now: bool = False\n\n# Shiny app layout\napp_ui: ui.page_sidebar = ui.page_sidebar(\n    ui.sidebar(\n        ui.card(\n            ui.input_selectize(\"year\",\"Year: \", choices = years, selected = '2024'),\n            ui.input_selectize(\"event\",\"Event:\", choices = [], selected = 0),\n            ui.input_selectize(\"session\",\"Session:\", choices = []),\n            ui.input_selectize('driver',\"Driver:\", choices = [], multiple = True),\n            ui.input_action_button('refresh','Refresh', class_ = 'btn-success', style = 'color:' + text_colour  + '; background:' + f1_red + 'border: 1px solid ' + text_colour),\n            height = 600,\n            style = 'color:' + text_colour + '; background:' + f1_red,\n        ),\n        ui.output_text('ack'), width = '320px',\n        bg = f1_red,\n        fg = text_colour,\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver0\"),height = 80, style = 'background:' + main_bg_colour)),\n        ui.column(6, ui.output_text(\"header\"),ui.output_text(\"sub_head\"), height = 80, style = 'text-align:center; line-height:2; font-size:1.6em; font-weight:bold; color:' + text_colour + '; background:' + main_bg_colour + '; border: 1px solid ' + f1_red),\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height = 80, style = 'background:' + main_bg_colour))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver0_throttle\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver0_brake\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver0_topspeed\"), height = 100, style = 'background:' + main_bg_colour),\n            height = 400,\n            style = 'background:' + main_bg_colour,\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver1_brake\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver1_topspeed\"), height = 100, style = 'background:' + main_bg_colour),\n            height = 400,\n            style = 'background:' + main_bg_colour\n            )\n        ),\n    ),\n    ui.row(\n        ui.output_plot('track_dominance_plot'),\n        height = 250,\n    ),\n    style = 'background:' + main_bg_colour\n)\n\ndef server(input, output, session):\n    def get_event_name(idx: int) -> str:\n        return events.event_name[idx]\n\n    def get_driver_name(idx: int) -> str:\n        return drivers.full_name[idx]\n\n    def get_driver_name_acronym(idx: int) -> str:\n        return drivers.name_acronym[idx]\n\n    def get_driver_num(idx: int) -> str:\n        return str(drivers.driver_number[idx])\n\n    def get_session_name(idx: int) -> str:\n        return sessions.session_name[idx]\n\n    def api_call(call_type: str, filters: list[str]) -> pd.DataFrame:\n        call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n        for f in filters:\n            if call_str[-1]  ==  '?':\n                call_str  +=  f\n            else:\n                call_str  +=  '&' + f\n\n        response = urlopen(call_str)\n        return pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n    def format_driver_names(driver_idx: int) -> str:\n        names = get_driver_name(driver_idx).split()\n        return '\\n'.join([names[0],' '.join(names[1:])]), get_driver_name_acronym(driver_idx)\n\n    def plot_names(front_name: str, back_name: str) -> plt.figure:\n        fig, ax = plt.subplots()\n        ax.text(0, 1, back_name, verticalalignment = 'top', horizontalalignment = 'left', color = text_grey, clip_on = False, fontstyle = 'oblique', fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 36, alpha = 0.2)\n        ax.text(1, 1, front_name, verticalalignment = 'top', horizontalalignment = 'right', color = text_colour, fontstyle = 'italic', fontfamily = 'sans-serif', fontsize = 13)\n        fig.patch.set_facecolor(main_bg_colour)\n        ax.set_facecolor(main_bg_colour)\n        ax.axis('off')\n        plt.tight_layout(pad = 0)\n        return fig\n\n    # number = index for driver in drivers\n    def driver_metric(metric_name, idx, func, minval, maxval, display_name = None) -> plt.figure:\n        fig, ax = plt.subplots()\n\n        if input.driver() !=  '' and len(car_data) > idx:\n            plot_data = car_data.copy()[idx]\n\n            #print(plot_data[['throttle']].mean(), selected_driver_colour[num])\n            metric = func(plot_data[[metric_name]]) #plot_data[[metric_name]].mean()\n            ax.barh(0.1, metric, color = str(selected_driver_colour[idx]), height = 0.1, align = 'center')\n            ax.text(maxval, 0.3, str(int(round(metric.iloc[0], 0))), verticalalignment = 'top', horizontalalignment = 'right', color = text_colour, fontstyle = 'oblique', fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 22)\n            display_name = metric_name if display_name is None else display_name\n            ax.text(0, 0.3, display_name, verticalalignment = 'top', horizontalalignment = 'left', color = text_colour, fontstyle = 'oblique',fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 14)\n\n        ax.axis('off')\n        ax.tick_params(axis = 'x', colors = text_colour, direction = 'in')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([])\n        ax.set_xlim(minval, maxval)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor(main_bg_colour)\n        fig.patch.set_facecolor(main_bg_colour)\n        plt.tight_layout()\n\n        return fig\n\n    \n    @render.text\n    def ack() -> str:\n        return 'Credit to the open-sourced OpenF1.org API (https://openf1.org/) for the Formula One\u00ae telemetry data used in this dashboard'\n\n    @reactive.effect\n    def update_event_list_with_year() -> None:\n        global events\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global location\n\n        selected_year = input.year()\n\n        #response = urlopen('https://api.openf1.org/v1/meetings?year = ' + selected_year)\n        #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n        df = api_call('meetings', ['year=' + str(selected_year)])\n\n        if df.shape[0] > 0:\n            try:\n                events = pd.concat([\n                    df.circuit_short_name,\n                    df.location,\n                    df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                    df.meeting_key,],axis = 1)\\\n                    .rename(columns = {'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n                ui.update_selectize(\"event\",choices = events.event_name)\n\n            except:\n                pass\n        else:\n            ui.update_selectize(\"event\",choices = [])\n\n            selected_year = None\n            events = None\n            selected_meeting_key = None\n\n        ui.update_selectize(\"session\",choices = [])\n        ui.update_selectize(\"driver\",choices = [])\n\n        sessions = None\n        selected_session_key = None\n        drivers = []\n        selected_driver_colour = []\n        selected_driver_number = []\n        car_data = []\n        locations = []\n\n    @render.text\n    def header() -> str:\n        if input.event():\n            event_name = get_event_name(int(input.event()))\n            return input.year() + ' ' + event_name if event_name !=  None else input.year()\n\n    @render.text\n    def sub_head() -> str:\n        if input.session():\n            session_name = get_session_name(int(input.session()))\n            return session_name if session_name !=  None else ''\n\n    @reactive.effect\n    def update_session_list_with_event() -> None:\n        global sessions\n        global drivers\n        global fastest_lap_start\n        global fastest_lap_end\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global car_data\n        global locations\n\n        if input.year() and input.event():\n            selected_meeting_key = events.meeting_key[int(input.event())]\n\n            #response = urlopen('https://api.openf1.org/v1/sessions?year = ' + str(selected_year) + '&meeting_key = ' + str(selected_meeting_key))\n            #df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n            df = api_call('sessions', ['year=' + str(selected_year),'meeting_key=' + str(selected_meeting_key)])\n\n            sessions = pd.concat([\n                df.session_key,\n                df.date_start,\n                df.session_type,\n                df.session_name], axis = 1)\n\n            ui.update_selectize(\"session\",choices = sessions.session_name)\n        else:\n            ui.update_selectize(\"session\",choices = [])\n\n            sessions = None\n            selected_session_key = None\n\n        ui.update_selectize(\"driver\", choices = [])\n        drivers = None\n        car_data = []\n        selected_driver_colour = []\n        selected_driver_number = []\n        locations = []\n\n    @reactive.effect\n    def update_driver_list_with_session() -> None:\n        global sessions\n        global drivers\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global locations\n\n        if len(input.session()) > 0:\n            selected_session_key = sessions.session_key[int(input.session())]\n\n            response = urlopen('https://api.openf1.org/v1/drivers?session_key=' + str(selected_session_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n            if df.shape[0] > 0:\n                try:\n                    global drivers\n\n                    drivers = pd.concat([\n                        df.driver_number,\n                        df.name_acronym,\n                        df.full_name,\n                        df.team_name,\n                        df.team_colour,\n                        df.headshot_url,\n                        df.country_code], axis = 1)\n\n                    drivers['team_name'] = drivers['team_name'].fillna('#NA')\n                    ui.update_selectize(\"driver\", choices = drivers.full_name + \" (\" + drivers.team_name + \")\")\n                except:\n                    pass\n            else:\n                ui.update_selectize(\"driver\", choices = [])\n\n                drivers = []\n\n            car_data = []\n            selected_driver_number = []\n            selected_driver_colour = []\n            locations = []\n\n    @render.plot\n    #@reactive.event(input.refresh, ignore_none = False)\n    def driver0() -> plt.figure:\n        if input.driver():\n            front_name, back_name = format_driver_names(int(input.driver()[0]))\n            return plot_names(front_name, back_name)\n\n    @render.plot\n    #@reactive.event(input.refresh, ignore_none = False)\n    def driver1() -> plt.figure:\n        if len(input.driver())  ==  2:\n            front_name, back_name = format_driver_names(int(input.driver()[1]))\n            return plot_names(front_name, back_name)\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    @reactive.event(input.refresh, ignore_none = False)\n    def update_cardata_with_driver() -> None:\n        global car_data\n        global locations\n        global selected_driver_number\n        global selected_driver_colour\n\n        if input.driver():\n            print(get_driver_num(int(input.driver()[0])), input.driver(), selected_driver_number)\n\n        # helper functions to map speed to car x, y position on track and determine which car is faster (dominant)\n        def get_speed_from_car_data(idx: int, time: pd._libs.tslibs.timedeltas.Timedelta) -> float:\n            global car_data\n            before = car_data[idx].date < time\n            after = car_data[idx].date >=  time\n            speed_before = -1 if len(car_data[idx][before].speed)  ==  0 else car_data[idx][before].speed.iloc[-1]\n            speed_after = -1 if len(car_data[idx][after].speed)  ==  0 else car_data[idx][after].speed.iloc[0]\n            return (speed_before + speed_after) / 2\n\n        # return 0 = first car is faster\n        # return 1 = second car is faster\n        # return -1 = same speed\n        def calc_dominance(x: int, y: int, speed: float) -> int:\n            global locations\n            loc1 = locations[1].copy()\n            loc1['dist'] = abs(loc1.x - x) + abs(loc1.y - y)\n            second_car_speed = loc1[loc1.dist  ==  loc1.dist.min()].speed.iloc[0]\n            if speed > second_car_speed:\n                return 0\n            elif speed < second_car_speed:\n                return 1\n            else:\n                return -1\n\n        # print(input.driver())\n        if len(input.driver()) > 0 and len(input.driver()) <=  2:\n\n            fastest_lap_start = None\n            fastest_lap_end = None\n\n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            selected_driver_colour = ['#' + str(drivers.team_colour[int(d)]) if drivers.team_colour[int(d)] is not None else default_driver_colour for d in input.driver()]\n\n            # if both driver/team colour are missing | if both driver/team colour are the same\n            if len(input.driver()) > 1:\n                if  (selected_driver_colour[0]  ==  selected_driver_colour[1]): # or (selected_driver_colour[0] is None and selected_driver_colour[1] is None)\n                    selected_driver_colour = [default_driver0_colour, default_driver1_colour]\n\n            api_result_dfs = [api_call('laps',['session_key=' + str(selected_session_key),'driver_number=' + str(d)]) for d in selected_driver_number]\n\n            fastest_laps = [\n                df[(df.lap_duration  ==  df.lap_duration.min()) &\n                  -df.duration_sector_3.isna()]\n                for df in api_result_dfs]\n\n            car_data = []\n            locations = []\n            for i in range(len(fastest_laps)):\n                fastest_lap_start = fastest_laps[i].iloc[0,:].date_start\n                fastest_lap_duration = fastest_laps[i].iloc[0,:].lap_duration\n                fastest_lap_end = str(pd.to_datetime(fastest_lap_start) + pd.Timedelta(seconds = fastest_lap_duration))\n                fastest_lap_end = re.sub('\\\\s', 'T', fastest_lap_end)\n\n                car_data_df = api_call('car_data',['driver_number=' + str(selected_driver_number[i]),'session_key=' + str(selected_session_key),'date>=' + str(fastest_lap_start),'date<=' + str(fastest_lap_end)])\n                car_data_df['date'] = pd.to_datetime(car_data_df.date, format = 'mixed') - pd.to_datetime(car_data_df.date,format = 'mixed').min()\n                car_data.append(car_data_df)\n\n                locations_df = api_call('location',['driver_number=' + str(selected_driver_number[i]),'session_key=' + str(selected_session_key),'date>=' + str(fastest_lap_start),'date<=' + str(fastest_lap_end)])\n                locations_df['date'] = pd.to_datetime(locations_df.date, format = 'mixed') - pd.to_datetime(locations_df.date,format = 'mixed').min()\n                start_x = locations_df[locations_df.date  ==  locations_df.date.min()].x.iloc[0]\n                start_y = locations_df[locations_df.date  ==  locations_df.date.min()].y.iloc[0]\n                locations_df['x'] = locations_df.x - start_x\n                locations_df['y'] = locations_df.y - start_y\n                locations.append(locations_df)\n\n                locations[0]['colour'] = selected_driver_colour[0]\n\n            # compare if there are two cars\n            if len(locations) > 1:\n                # map speed (car_data) to x, y position (location)\n                for j in range(len(locations)):\n                    locations[j]['speed'] = -1.0\n                    for i in range(locations[j].shape[0]):\n                        time = locations[j].iloc[i,:].date\n                        #print(pt.x, pt.y, pt.date)\n                        locations[j].loc[i,'speed'] = get_speed_from_car_data(j, time)\n\n                # determine track dominance\n                locations[0]['dominance'] = -99\n                for i in range(locations[0].shape[0]):\n                    x, y, speed = locations[0].iloc[i, :].x, locations[0].iloc[i, :].y, locations[0].iloc[i, :].speed\n                    locations[0].loc[i, 'dominance'] = calc_dominance(x, y, speed)\n\n                # smooth twice\n                smooth = 12\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i + smooth, 'dominance'])[0]\n\n                smooth = 8\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i + smooth, 'dominance'])[0]\n\n\n                for i in range(locations[0].shape[0]):\n                    dominance = locations[0].loc[i, 'dominance']\n                    if dominance  ==  0:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[0]\n                    elif dominance  ==  1:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[1]\n                    else:\n                        locations[0].loc[i, 'colour'] = '#00AAAA'\n        else:\n            selected_driver_number = []\n            selected_driver_colour = []\n            car_data = []\n            locations = []\n\n\n        #[print(c.driver_number.unique()) for c in car_data]\n        # print(len(car_data), [c.shape for c in car_data])\n\n    @render_widget\n    @reactive.event(input.refresh, ignore_none = False)\n    def tele_plot() -> go.Figure:\n        fig = go.Figure()\n\n        if input.driver() !=  '':\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = data.date.astype(str)\n                    #data['date'] = (pd.to_datetime(data.date, format = 'mixed') - pd.to_datetime(data.date,format = 'mixed').min()).astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace = True)\n                    data['date'] = pd.to_datetime(data.date,format = '%M:%S.%f')\n                    data.dropna(inplace = True)\n\n                    dr_mask = drivers.driver_number  ==  selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<= .[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n\n                    fig.add_trace(go.Scatter(x = data.date, y = data.speed, line = (dict(color = str(selected_driver_colour[i]))) , name = list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template = 'plotly_dark',\n            plot_bgcolor = 'black',\n            showlegend = True,\n            legend = dict(yanchor = 'bottom',y = 0.01,xanchor = 'right',x = 0.99,orientation = 'h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        fig.update_yaxes(title_text = 'Speed / mph')\n        return fig\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_throttle() -> plt.figure:\n        return driver_metric('throttle', 0, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_throttle() -> plt.figure:\n        return driver_metric('throttle', 1, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_brake() -> plt.figure:\n        return driver_metric('brake', 0, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_brake() -> plt.figure:\n        return driver_metric('brake', 1, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_topspeed() -> plt.figure:\n        return driver_metric('speed', 0, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_topspeed() -> plt.figure:\n        return driver_metric('speed', 1, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def track_dominance_plot() -> go.Figure:\n        global locations\n\n        fig, ax = plt.subplots()\n\n        if input.driver() !=  '' and len(locations) > 0:\n            plot_data = locations.copy()[0]\n\n            # draw driver0\n            ax.plot(plot_data.x + 70, plot_data.y - 350, c = text_colour, ls = '-', lw = 10, alpha = 0.15)\n            ax.plot(plot_data.x, plot_data.y, c = track_grey, ls = '-', lw = 6)\n            ax.plot(plot_data.x, plot_data.y, c = selected_driver_colour[0], ls = '-', lw = 4)\n\n            # work out segments for drawing\n            if len(plot_data.colour.unique()) > 1:\n                current_segment = 0\n                plot_data['segment'] = -1\n                for i in range(plot_data.shape[0]):\n                    plot_data.loc[i, 'segment'] = current_segment\n                    if (i < plot_data.shape[0] - 1) and (plot_data.loc[i, 'dominance'] !=  plot_data.loc[i + 1, 'dominance']):\n                        current_segment  +=  1\n\n                # only draw driver1 dominant segments\n                plot_data_c = plot_data[plot_data.dominance  ==  1]\n                for seg in plot_data_c.segment.unique():\n                        plot_segment = plot_data_c[plot_data_c.segment  ==  seg]\n                        if plot_segment.shape[0] > 1:\n                            # ax.plot(plot_segment.x, plot_segment.y, c = tracker_border_colour_driver1, ls = '-', lw = 6)\n                            ax.plot(plot_segment.x, plot_segment.y, c = selected_driver_colour[1], ls = '-', lw = 4)\n\n            ax.plot(plot_data.x[0], plot_data.y[0], c = track_border_colour, marker = 'o', markersize = 8)\n            ax.plot(plot_data.x[0], plot_data.y[0], c = text_colour, marker = 'o', markersize = 6)\n\n        ax.axis('off')\n        ax.set_facecolor(main_bg_colour)\n\n        fig.patch.set_facecolor(main_bg_colour)\n        return fig\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "backup/f1_telemetry_20240331_5.py", "content": "from shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\nfrom matplotlib import pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom urllib.request import urlopen\nfrom scipy import stats\nimport pandas as pd\nimport json\nimport re\n\n# declare variables\n# colours\nf1_red: str = '#E6002B'\nmain_bg_colour: str = '#111111'\ntext_colour: str = '#FFFFFF'\ntext_grey: str = '#AAAAAA'\ndefault_driver0_colour: str = f1_red # '#1b14e3'\ndefault_driver1_colour: str = text_colour\ndefault_driver_colour: str = '#ae89c4'\ntrack_border_colour: str = '#000000'\ntrack_grey: str = '#001010'\n# tracker_border_colour_driver1: str = text_colour\n\n# lists for drop down selections\nyears: list[str] = ['2023','2024']\nevents: list[str] = []\nsessions: list[str] = []\ndrivers: list[str] = []\n\n# selected from drop down selections\nselected_year: str = None\nselected_meeting_key: str = None\nselected_session_key: str = None\nselected_driver_number: list[str] = []\nselected_driver_colour: list[str] = []\n\n# telemetry data downloaded retrieved\ncar_data: list[pd.DataFrame] = []\nlocations: list[pd.DataFrame] = []\n\n\n# Shiny app layout\napp_ui: ui.page_sidebar = ui.page_sidebar(\n    ui.sidebar(\n        ui.card(\n            ui.input_selectize(\"year\",\"Year: \", choices = years, selected = '2024'),\n            ui.input_selectize(\"event\",\"Event:\", choices = [], selected = 0),\n            ui.input_selectize(\"session\",\"Session:\", choices = []),\n            ui.input_selectize('driver',\"Driver:\", choices = [], multiple = True),\n            ui.input_action_button('refresh','Refresh', class_ = 'btn-success', style = 'color:' + text_colour  + '; background:' + f1_red + 'border: 1px solid ' + text_colour),\n            height = 600,\n            style = 'color:' + text_colour + '; background:' + f1_red,\n        ),\n        ui.output_text('ack'), width = '320px',\n        bg = f1_red,\n        fg = text_colour,\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver0\"),height = 80, style = 'background:' + main_bg_colour)),\n        ui.column(6, ui.output_text(\"header\"),ui.output_text(\"sub_head\"), height = 80, style = 'text-align:center; line-height:2; font-size:1.6em; font-weight:bold; color:' + text_colour + '; background:' + main_bg_colour + '; border: 1px solid ' + f1_red),\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height = 80, style = 'background:' + main_bg_colour))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver0_throttle\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver0_brake\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver0_topspeed\"), height = 100, style = 'background:' + main_bg_colour),\n            height = 400,\n            style = 'background:' + main_bg_colour,\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver1_brake\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver1_topspeed\"), height = 100, style = 'background:' + main_bg_colour),\n            height = 400,\n            style = 'background:' + main_bg_colour\n            )\n        ),\n    ),\n    ui.row(\n        ui.output_plot('track_dominance_plot'),\n        height = 250,\n    ),\n    style = 'background:' + main_bg_colour\n)\n\ndef server(input, output, session):\n    def reset_variables(\n        reset_events: bool = False,\n        reset_sessions: bool = False,\n        reset_drivers: bool = False,\n        reset_selected_year:bool = False,\n        reset_selected_meeting_key:bool = False,\n        reset_selected_session_key: bool = False,\n        reset_selected_driver_number: bool = False,\n        reset_selected_driver_colour: bool = False,\n        reset_car_data:bool = False,\n        reset_locations:bool = False\n    ):\n        global events\n        global sessions\n        global drivers\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global locations\n        \n        events = [] if reset_events else events\n        sessions = [] if reset_sessions else sessions\n        drivers = [] if reset_drivers else drivers\n\n        selected_year = None if reset_selected_year else selected_year\n        selected_meeting_key = None if reset_selected_meeting_key else selected_meeting_key\n        selected_session_key = None if reset_selected_session_key else selected_session_key\n        selected_driver_number = [] if reset_selected_driver_number else selected_driver_number\n        selected_driver_colour = [] if reset_selected_driver_colour else selected_driver_colour\n\n        car_data = [] if reset_car_data else car_data\n        locations = [] if reset_locations else locations\n\n    def get_event_name(idx: int) -> str:\n        return events.event_name[idx]\n\n    def get_driver_name(idx: int) -> str:\n        return drivers.full_name[idx]\n\n    def get_driver_name_acronym(idx: int) -> str:\n        return drivers.name_acronym[idx]\n\n    def get_driver_num(idx: int) -> str:\n        return str(drivers.driver_number[idx])\n\n    def get_session_name(idx: int) -> str:\n        return sessions.session_name[idx]\n\n    def api_call(call_type: str, filters: list[str]) -> pd.DataFrame:\n        call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n        for f in filters:\n            if call_str[-1]  ==  '?':\n                call_str  +=  f\n            else:\n                call_str  +=  '&' + f\n\n        response = urlopen(call_str)\n        df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n        assert df.shape[0] > 0 and df.shape[1] > 0, \"result pd.DataFrame is empty\"\n\n        return df \n\n    def format_driver_names(driver_idx: int) -> str:\n        names = get_driver_name(driver_idx).split()\n        return '\\n'.join([names[0],' '.join(names[1:])]), get_driver_name_acronym(driver_idx)\n\n    def plot_names(front_name: str, back_name: str) -> plt.figure:\n        fig, ax = plt.subplots()\n        ax.text(0, 1, back_name, verticalalignment = 'top', horizontalalignment = 'left', color = text_grey, clip_on = False, fontstyle = 'oblique', fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 36, alpha = 0.2)\n        ax.text(1, 1, front_name, verticalalignment = 'top', horizontalalignment = 'right', color = text_colour, fontstyle = 'italic', fontfamily = 'sans-serif', fontsize = 13)\n        fig.patch.set_facecolor(main_bg_colour)\n        ax.set_facecolor(main_bg_colour)\n        ax.axis('off')\n        plt.tight_layout(pad = 0)\n        return fig\n    \n    # number = index for driver in drivers\n    def driver_metric(metric_name, idx, func, minval, maxval, display_name = None) -> plt.figure:\n        fig, ax = plt.subplots()\n\n        if len(input.driver()) > 0 and len(car_data) > idx:\n            plot_data = car_data.copy()[idx]\n\n            #print(plot_data[['throttle']].mean(), selected_driver_colour[num])\n            metric = func(plot_data[[metric_name]]) #plot_data[[metric_name]].mean()\n            ax.barh(0.1, metric, color = str(selected_driver_colour[idx]), height = 0.1, align = 'center')\n            ax.text(maxval, 0.3, str(int(round(metric.iloc[0], 0))), verticalalignment = 'top', horizontalalignment = 'right', color = text_colour, fontstyle = 'oblique', fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 22)\n            display_name = metric_name if display_name is None else display_name\n            ax.text(0, 0.3, display_name, verticalalignment = 'top', horizontalalignment = 'left', color = text_colour, fontstyle = 'oblique',fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 14)\n\n        ax.axis('off')\n        ax.tick_params(axis = 'x', colors = text_colour, direction = 'in')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([])\n        ax.set_xlim(minval, maxval)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor(main_bg_colour)\n        fig.patch.set_facecolor(main_bg_colour)\n        plt.tight_layout()\n\n        return fig\n\n    @reactive.effect\n    def update_event_list_with_year() -> None:\n        global events\n        global selected_year\n\n        # updatinig event drop-drop lists\n        # reset drop-down lists\n        ui.update_selectize(\"event\",choices = [])\n        ui.update_selectize(\"session\",choices = [])\n        ui.update_selectize(\"driver\",choices = [])\n\n        # reset variables for data and what are selected in drop-down lists\n        reset_variables(reset_selected_year = None, reset_selected_meeting_key = None, reset_events = True, reset_sessions = True, reset_selected_session_key = True, reset_drivers = True, reset_selected_driver_number = True, reset_selected_driver_colour = True, reset_car_data = True, reset_locations = True )\n\n        # get year from drop-down list\n        selected_year = input.year()\n\n        # get events data\n        # update event drop-down list\n        df = api_call('meetings', ['year=' + str(selected_year)])\n        \n        try:\n            events = pd.concat([\n                df.circuit_short_name,\n                df.location,\n                df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                df.meeting_key,],axis = 1)\\\n                .rename(columns = {'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n            ui.update_selectize(\"event\",choices = events.event_name)\n        except:\n            print(f\"Likely to be data error when retrieving event data from api_call: year={str(selected_year)}. Dataframe returned has {df.shape[0]} rows and {df.shape[1]} columns\")\n\n    @reactive.effect\n    def update_session_list_with_event() -> None:\n        global sessions\n        global selected_meeting_key\n\n        # updating session drop-down list\n        # reset drop-down lists except for year and event\n        ui.update_selectize(\"driver\", choices = [])\n        ui.update_selectize(\"session\",choices = [])\n\n        # reset variables\n        reset_variables(reset_selected_meeting_key = True, reset_sessions = True, reset_selected_session_key = True, reset_drivers = True, reset_selected_driver_colour = True, reset_selected_driver_number = True, reset_car_data = True, reset_locations = True)\n\n        # check drop-down lists year and event for values\n        # get session data\n        # update session drop-drop list\n        if len(input.year()) > 0 and len(input.event()) > 0:\n            selected_meeting_key = events.meeting_key[int(input.event())]\n\n            df = api_call('sessions', ['year=' + str(selected_year),'meeting_key=' + str(selected_meeting_key)])\n\n            try:\n                sessions = pd.concat([\n                    df.session_key,\n                    df.date_start,\n                    df.session_type,\n                    df.session_name], axis = 1)\n\n                ui.update_selectize(\"session\",choices = sessions.session_name)\n            except:\n                print(f\"Likely to be data error when retrieving session data from api_call: year={str(selected_year)}&meeting_key={str(selected_meeting_key)}. Dataframe returned has {df.shape[0]} rows and {df.shape[1]} columns\")\n\n    @reactive.effect\n    def update_driver_list_with_session() -> None:\n        global drivers\n        global selected_session_key\n\n        # updating driver drop-down list\n        # reset drop-down lists except for year, event and session\n        ui.update_selectize(\"driver\", choices = [])\n\n        # reset variables\n        reset_variables(reset_drivers = True, reset_selected_driver_number = True, reset_selected_driver_colour = True, reset_car_data = True, reset_locations = True)\n\n        if len(input.year()) > 0 and len(input.event()) and len(input.session()) > 0:\n            selected_session_key = sessions.session_key[int(input.session())]\n\n            response = urlopen('https://api.openf1.org/v1/drivers?session_key=' + str(selected_session_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n            try:\n                drivers = pd.concat([\n                    df.driver_number,\n                    df.name_acronym,\n                    df.full_name,\n                    df.team_name,\n                    df.team_colour,\n                    df.headshot_url,\n                    df.country_code], axis = 1)\n                drivers['team_name'] = drivers['team_name'].fillna('#NA')\n\n                ui.update_selectize(\"driver\", choices = drivers.full_name + \" (\" + drivers.team_name + \")\")\n            except:\n                print(f\"Likely to be data error when retrieving driver data from api_call: session={str(selected_session_key)}. Dataframe returned has {df.shape[0]} rows and {df.shape[1]} columns\")\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    @reactive.event(input.refresh, ignore_none = False)\n    def update_cardata_with_driver() -> None:\n        global car_data\n        global locations\n        global selected_driver_number\n        global selected_driver_colour\n\n        # helper functions to map speed to car x, y position on track and determine track dominance at each trck position\n        # get car speed at specific time\n        def get_speed_from_car_data(idx: int, time: pd._libs.tslibs.timedeltas.Timedelta) -> float:\n            global car_data\n            before = car_data[idx].date - car_data[idx].date.min() < time\n            after = car_data[idx].date - car_data[idx].date.min() >=  time\n            speed_before = -1 if len(car_data[idx][before].speed)  ==  0 else car_data[idx][before].speed.iloc[-1]\n            speed_after = -1 if len(car_data[idx][after].speed)  ==  0 else car_data[idx][after].speed.iloc[0]\n            return (speed_before + speed_after) / 2\n\n        # Work out track dominance at specific position x, y between two cars\n        # return 0 = first car is faster\n        # return 1 = second car is faster\n        # return -1 = same speed\n        # x and y are car0 (driver0) position coordinates\n        # compare with car1's (driver1's) speed at the closest x, y position\n        def calc_dominance(x: int, y: int, speed: float) -> int:\n            global locations\n            loc1 = locations[1].copy()\n            loc1['dist'] = abs(loc1.x - x) + abs(loc1.y - y)\n            second_car_speed = loc1[loc1.dist  ==  loc1.dist.min()].speed.iloc[0]\n            if speed > second_car_speed:\n                return 0\n            elif speed < second_car_speed:\n                return 1\n            else:\n                return -1\n\n        def get_fastest_lap(df: pd.DataFrame) -> pd.DataFrame:\n            # shortest lap time + has a sector 3 time (finished the lap)\n            return df[(df.lap_duration  ==  df.lap_duration.min()) & -df.duration_sector_3.isna()]\n\n        def get_lap_start_time(df: pd.DataFrame) -> str:\n            return df.iloc[0].date_start\n\n        def get_lap_end_time(df:pd.DataFrame) -> str:\n            lap_start = get_lap_start_time(df)\n            lap_duration = df.iloc[0,:].lap_duration\n            lap_end = str(pd.to_datetime(lap_start) + pd.Timedelta(seconds = lap_duration))\n            return re.sub('\\\\s', 'T', lap_end)\n\n        # smooth dominance data that are stored in locations[0] (driver0's location data\n        def smooth_dominance(smooth: int) -> None:\n            global locations\n            for i in range(locations[0].shape[0]):\n                if i + smooth < locations[0].shape[0]:\n                    locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i + smooth, 'dominance'])[0]\n\n        # Only update if 1 or 2 drivers are chosen\n        if len(input.driver()) > 0 and len(input.driver()) <=  2:\n\n            fastest_lap_start = None\n            fastest_lap_end = None\n\n            # store previously selected drivers\n            old_selected_driver_number = selected_driver_number\n\n            # update selected driver variables\n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            # assign team colour to driver or use default colour if team/team colour is none\n            selected_driver_colour = ['#' + str(drivers.team_colour[int(d)]) if drivers.team_colour[int(d)] is not None else default_driver_colour for d in input.driver()]\n\n            # if there are more than one driver and driver/team colour assigned are the same\n            # assigned driver colours to be default driver0 and driver1 colours\n            if len(input.driver()) > 1 and (selected_driver_colour[0]  ==  selected_driver_colour[1]):\n                selected_driver_colour = [default_driver0_colour, default_driver1_colour]\n\n            # get car_data and location_data\n            temp_car_data = []\n            temp_locations = []\n            for i, d in enumerate(selected_driver_number):\n                if old_selected_driver_number == [] or selected_driver_number[i] not in old_selected_driver_number:\n                    api_result_df = api_call('laps',['session_key=' + str(selected_session_key),'driver_number=' + str(selected_driver_number[i])])\n\n                    fastest_lap = get_fastest_lap(api_result_df)\n                    fastest_lap_start = get_lap_start_time(fastest_lap)\n                    fastest_lap_end = get_lap_end_time(fastest_lap)\n\n                    car_data_df = api_call('car_data',['driver_number=' + str(selected_driver_number[i]),'session_key=' + str(selected_session_key),'date>=' + str(fastest_lap_start),'date<=' + str(fastest_lap_end)])\n                    car_data_df['date'] = pd.to_datetime(car_data_df.date, format = 'mixed') - pd.to_datetime(car_data_df.date,format = 'mixed').min()\n                    temp_car_data.append(car_data_df)\n\n                    locations_df = api_call('location',['driver_number=' + str(selected_driver_number[i]),'session_key=' + str(selected_session_key),'date>=' + str(fastest_lap_start),'date<=' + str(fastest_lap_end)])\n                    locations_df['date'] = pd.to_datetime(locations_df.date, format = 'mixed') - pd.to_datetime(locations_df.date,format = 'mixed').min()\n                    start_x = locations_df[locations_df.date  ==  locations_df.date.min()].x.iloc[0]\n                    start_y = locations_df[locations_df.date  ==  locations_df.date.min()].y.iloc[0]\n                    locations_df['x'] = locations_df.x - start_x\n                    locations_df['y'] = locations_df.y - start_y\n                    temp_locations.append(locations_df)\n                else:\n                    temp_car_data.append(car_data.copy()[old_selected_driver_number.index(selected_driver_number[i])])\n                    temp_locations.append(locations.copy()[old_selected_driver_number.index(selected_driver_number[i])])\n                    print('copy old into temp data')\n\n            car_data = temp_car_data.copy()\n            locations = temp_locations.copy()\n\n            # initialize colour attribute in locations[0] for track dominance plotting\n            # stored track dominance information only in locations[0] (driver0's location table) plotting\n            locations[0]['colour'] = selected_driver_colour[0]\n\n            # compare if there are two cars\n            if len(locations) > 1:\n                # map speed (car_data) to x, y position (location)\n                for j in range(len(locations)):\n                    locations[j]['speed'] = -1.0\n                    for i in range(locations[j].shape[0]):\n                        time = locations[j].iloc[i,:].date\n                        #print(pt.x, pt.y, pt.date)\n                        locations[j].loc[i,'speed'] = get_speed_from_car_data(j, time)\n\n                # determine track dominance\n                locations[0]['dominance'] = -99\n                for i in range(locations[0].shape[0]):\n                    x, y, speed = locations[0].iloc[i, :].x, locations[0].iloc[i, :].y, locations[0].iloc[i, :].speed\n                    locations[0].loc[i, 'dominance'] = calc_dominance(x, y, speed)\n\n                # smooth dominance result twice\n                '''smooth = 12\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i + smooth, 'dominance'])[0]'''\n                smooth_dominance(smooth = 12)\n\n                '''smooth = 8\n                for i in range(locations[0].shape[0]):\n                    if i + smooth < locations[0].shape[0]:\n                        locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i + smooth, 'dominance'])[0]'''\n                smooth_dominance(smooth = 8)\n\n                # assign driver colour to locations on track to represent track dominance\n                for i in range(locations[0].shape[0]):\n                    dominance = locations[0].loc[i, 'dominance']\n                    if dominance  ==  0:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[0]\n                    elif dominance  ==  1:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[1]\n                    else:\n                        locations[0].loc[i, 'colour'] = '#00AAAA'\n\n    # header elements\n    @render.text\n    def header() -> str:\n        if input.event():\n            event_name = get_event_name(int(input.event()))\n            return input.year() + ' ' + event_name if event_name !=  None else input.year()\n\n    @render.text\n    def sub_head() -> str:\n        if input.session():\n            session_name = get_session_name(int(input.session()))\n            return session_name if session_name !=  None else ''\n\n    @render.plot\n    def driver0() -> plt.figure:\n        if input.driver():\n            front_name, back_name = format_driver_names(int(input.driver()[0]))\n            return plot_names(front_name, back_name)\n\n    @render.plot\n    def driver1() -> plt.figure:\n        if len(input.driver())  ==  2:\n            front_name, back_name = format_driver_names(int(input.driver()[1]))\n            return plot_names(front_name, back_name)\n\n    # telemetry plot\n    @render_widget\n    @reactive.event(input.refresh, ignore_none = False)\n    def tele_plot() -> go.Figure:\n        fig = go.Figure()\n\n        if input.driver() !=  '':\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = data.date.astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace = True)\n                    data['date'] = pd.to_datetime(data.date,format = '%M:%S.%f')\n                    data.dropna(inplace = True)\n\n                    dr_mask = drivers.driver_number  ==  selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<= .[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n\n                    fig.add_trace(go.Scatter(x = data.date, y = data.speed, line = (dict(color = str(selected_driver_colour[i]))) , name = list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template = 'plotly_dark',\n            plot_bgcolor = 'black',\n            showlegend = True,\n            legend = dict(yanchor = 'bottom',y = 0.01,xanchor = 'right',x = 0.99,orientation = 'h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        fig.update_yaxes(title_text = 'Speed / mph')\n        return fig\n\n    # driver metrics\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_throttle() -> plt.figure:\n        return driver_metric('throttle', 0, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_throttle() -> plt.figure:\n        return driver_metric('throttle', 1, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_brake() -> plt.figure:\n        return driver_metric('brake', 0, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_brake() -> plt.figure:\n        return driver_metric('brake', 1, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_topspeed() -> plt.figure:\n        return driver_metric('speed', 0, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_topspeed() -> plt.figure:\n        return driver_metric('speed', 1, pd.Series.max, 0, 350, 'Top speed')\n\n    # track dominance\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def track_dominance_plot() -> go.Figure:\n        global locations\n\n        fig, ax = plt.subplots()\n\n        if len(input.driver()) > 0 and len(locations) > 0:\n            plot_data = locations.copy()[0]\n\n            # draw driver0\n            ax.plot(plot_data.x + 50, plot_data.y - 250, c = text_colour, ls = '-', lw = 10, alpha = 0.15)\n            ax.plot(plot_data.x, plot_data.y, c = track_grey, ls = '-', lw = 6)\n            ax.plot(plot_data.x, plot_data.y, c = selected_driver_colour[0], ls = '-', lw = 4)\n\n            # work out segments for drawing driver1 dominant parts\n            if len(plot_data.colour.unique()) > 1:\n                current_segment = 0\n                plot_data['segment'] = -1\n                for i in range(plot_data.shape[0]):\n                    plot_data.loc[i, 'segment'] = current_segment\n                    if (i < plot_data.shape[0] - 1) and (plot_data.loc[i, 'dominance'] !=  plot_data.loc[i + 1, 'dominance']):\n                        current_segment  +=  1\n\n                # only draw driver1 dominant segments\n                plot_data_c = plot_data[plot_data.dominance  ==  1]\n                for seg in plot_data_c.segment.unique():\n                        plot_segment = plot_data_c[plot_data_c.segment  ==  seg]\n                        if plot_segment.shape[0] > 1:\n                            # ax.plot(plot_segment.x, plot_segment.y, c = tracker_border_colour_driver1, ls = '-', lw = 6)\n                            ax.plot(plot_segment.x, plot_segment.y, c = selected_driver_colour[1], ls = '-', lw = 4)\n\n            ax.plot(plot_data.x[0], plot_data.y[0], c = track_border_colour, marker = 'o', markersize = 8)\n            ax.plot(plot_data.x[0], plot_data.y[0], c = text_colour, marker = 'o', markersize = 6)\n\n        ax.axis('off')\n        ax.set_facecolor(main_bg_colour)\n\n        fig.patch.set_facecolor(main_bg_colour)\n        return fig\n    \n    @render.text\n    def ack() -> str:\n        return 'Credit to the open-sourced OpenF1.org API (https://openf1.org/) for the Formula One\u00ae telemetry data used in this dashboard'\n\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "backup/f1_telemetry_20240405_1.py", "content": "from shiny import App, reactive, render, ui\nfrom shinywidgets import render_widget, output_widget\nfrom matplotlib import pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom urllib.request import urlopen\nfrom scipy import stats\nimport pandas as pd\nimport json\nimport re\n\n# declare variables\n# colours\nf1_red: str = '#E6002B'\nmain_bg_colour: str = '#111111'\ntext_colour: str = '#FFFFFF'\ntext_grey: str = '#AAAAAA'\ndefault_driver0_colour: str = f1_red # '#1b14e3'\ndefault_driver1_colour: str = text_colour\ndefault_driver_colour: str = '#ae89c4'\ntrack_border_colour: str = '#000000'\ntrack_grey: str = '#001010'\n# tracker_border_colour_driver1: str = text_colour\n\n# lists for drop down selections\nyears: list[str] = ['2023','2024']\nevents: list[str] = []\nsessions: list[str] = []\ndrivers: list[str] = []\n\n# selected from drop down selections\nselected_year: str = None\nselected_meeting_key: str = None\nselected_session_key: str = None\nselected_driver_number: list[str] = []\nselected_driver_colour: list[str] = []\n\n# telemetry data downloaded retrieved\ncar_data: list[pd.DataFrame] = []\nlocations: list[pd.DataFrame] = []\n\n\n# Shiny app layout\napp_ui: ui.page_sidebar = ui.page_sidebar(\n    ui.sidebar(\n        ui.card(\n            ui.input_selectize(\"year\",\"Year: \", choices = years, selected = '2024'),\n            ui.input_selectize(\"event\",\"Event:\", choices = [], selected = 0),\n            ui.input_selectize(\"session\",\"Session:\", choices = []),\n            ui.input_selectize('driver',\"Driver:\", choices = [], multiple = True),\n            ui.input_action_button('refresh','Refresh', class_ = 'btn-success', style = 'color:' + text_colour  + '; background:' + f1_red + 'border: 1px solid ' + text_colour),\n            height = 600,\n            style = 'color:' + text_colour + '; background:' + f1_red,\n        ),\n        ui.output_text('ack'), width = '320px',\n        bg = f1_red,\n        fg = text_colour,\n    ),\n    ui.row(\n        ui.column(3, ui.card(ui.output_plot(\"driver0\"),height = 80, style = 'background:' + main_bg_colour)),\n        ui.column(6, ui.output_text(\"header\"),ui.output_text(\"sub_head\"), height = 80, style = 'text-align:center; line-height:2; font-size:1.6em; font-weight:bold; color:' + text_colour + '; background:' + main_bg_colour + '; border: 1px solid ' + f1_red),\n        ui.column(3, ui.card(ui.output_plot(\"driver1\"),height = 80, style = 'background:' + main_bg_colour))\n    ),\n    ui.row(\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver0_throttle\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver0_brake\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver0_topspeed\"), height = 100, style = 'background:' + main_bg_colour),\n            height = 400,\n            style = 'background:' + main_bg_colour,\n            )\n        ),\n        ui.column(6, output_widget(\"tele_plot\")),\n        ui.column(\n            3,\n            ui.card(\n                ui.card(ui.output_plot(\"driver1_throttle\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver1_brake\"), height = 100, style = 'background:' + main_bg_colour),\n                ui.card(ui.output_plot(\"driver1_topspeed\"), height = 100, style = 'background:' + main_bg_colour),\n            height = 400,\n            style = 'background:' + main_bg_colour\n            )\n        ),\n    ),\n    ui.row(\n        ui.output_plot('track_dominance_plot'),\n        height = 250,\n    ),\n    style = 'background:' + main_bg_colour\n)\n\ndef server(input, output, session):\n    def reset_variables(\n        reset_events: bool = False,\n        reset_sessions: bool = False,\n        reset_drivers: bool = False,\n        reset_selected_year:bool = False,\n        reset_selected_meeting_key:bool = False,\n        reset_selected_session_key: bool = False,\n        reset_selected_driver_number: bool = False,\n        reset_selected_driver_colour: bool = False,\n        reset_car_data:bool = False,\n        reset_locations:bool = False\n    ):\n        global events\n        global sessions\n        global drivers\n        global selected_year\n        global selected_meeting_key\n        global selected_session_key\n        global selected_driver_number\n        global selected_driver_colour\n        global car_data\n        global locations\n        \n        events = [] if reset_events else events\n        sessions = [] if reset_sessions else sessions\n        drivers = [] if reset_drivers else drivers\n\n        selected_year = None if reset_selected_year else selected_year\n        selected_meeting_key = None if reset_selected_meeting_key else selected_meeting_key\n        selected_session_key = None if reset_selected_session_key else selected_session_key\n        selected_driver_number = [] if reset_selected_driver_number else selected_driver_number\n        selected_driver_colour = [] if reset_selected_driver_colour else selected_driver_colour\n\n        car_data = [] if reset_car_data else car_data\n        locations = [] if reset_locations else locations\n\n    def get_event_name(idx: int) -> str:\n        return events.event_name[idx]\n\n    def get_driver_name(idx: int) -> str:\n        return drivers.full_name[idx]\n\n    def get_driver_name_acronym(idx: int) -> str:\n        return drivers.name_acronym[idx]\n\n    def get_driver_num(idx: int) -> str:\n        return str(drivers.driver_number[idx])\n\n    def get_session_name(idx: int) -> str:\n        return sessions.session_name[idx]\n\n    def api_call(call_type: str, filters: list[str]) -> pd.DataFrame:\n        call_str = 'https://api.openf1.org/v1/' + call_type + '?'\n\n        for f in filters:\n            if call_str[-1]  ==  '?':\n                call_str  +=  f\n            else:\n                call_str  +=  '&' + f\n\n        response = urlopen(call_str)\n        df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n        assert df.shape[0] > 0 and df.shape[1] > 0, \"result pd.DataFrame is empty\"\n\n        return df \n\n    def format_driver_names(driver_idx: int) -> str:\n        names = get_driver_name(driver_idx).split()\n        return '\\n'.join([names[0],' '.join(names[1:])]), get_driver_name_acronym(driver_idx)\n\n    def plot_names(front_name: str, back_name: str) -> plt.figure:\n        fig, ax = plt.subplots()\n        ax.text(0, 1, back_name, verticalalignment = 'top', horizontalalignment = 'left', color = text_grey, clip_on = False, fontstyle = 'oblique', fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 36, alpha = 0.2)\n        ax.text(1, 1, front_name, verticalalignment = 'top', horizontalalignment = 'right', color = text_colour, fontstyle = 'italic', fontfamily = 'sans-serif', fontsize = 13)\n        fig.patch.set_facecolor(main_bg_colour)\n        ax.set_facecolor(main_bg_colour)\n        ax.axis('off')\n        plt.tight_layout(pad = 0)\n        return fig\n    \n    # number = index for driver in drivers\n    def driver_metric(metric_name, idx, func, minval, maxval, display_name = None) -> plt.figure:\n        fig, ax = plt.subplots()\n\n        if len(input.driver()) > 0 and len(car_data) > idx:\n            plot_data = car_data.copy()[idx]\n\n            #print(plot_data[['throttle']].mean(), selected_driver_colour[num])\n            metric = func(plot_data[[metric_name]]) #plot_data[[metric_name]].mean()\n            ax.barh(0.1, metric, color = str(selected_driver_colour[idx]), height = 0.1, align = 'center')\n            ax.text(maxval, 0.3, str(int(round(metric.iloc[0], 0))), verticalalignment = 'top', horizontalalignment = 'right', color = text_colour, fontstyle = 'oblique', fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 22)\n            display_name = metric_name if display_name is None else display_name\n            ax.text(0, 0.3, display_name, verticalalignment = 'top', horizontalalignment = 'left', color = text_colour, fontstyle = 'oblique',fontweight = 'bold', fontfamily = 'sans-serif', fontsize = 14)\n\n        ax.axis('off')\n        ax.tick_params(axis = 'x', colors = text_colour, direction = 'in')\n        ax.yaxis.set_visible(False)\n        ax.set_xticks([])\n        ax.set_xlim(minval, maxval)\n        ax.set_ylim(0,0.3)\n        ax.set_facecolor(main_bg_colour)\n        fig.patch.set_facecolor(main_bg_colour)\n        plt.tight_layout()\n\n        return fig\n\n    @reactive.effect\n    def update_event_list_with_year() -> None:\n        global events\n        global selected_year\n\n        # updatinig event drop-drop lists\n        # reset drop-down lists\n        ui.update_selectize(\"event\",choices = [])\n        ui.update_selectize(\"session\",choices = [])\n        ui.update_selectize(\"driver\",choices = [])\n\n        # reset variables for data and what are selected in drop-down lists\n        reset_variables(reset_selected_year = None, reset_selected_meeting_key = None, reset_events = True, reset_sessions = True, reset_selected_session_key = True, reset_drivers = True, reset_selected_driver_number = True, reset_selected_driver_colour = True, reset_car_data = True, reset_locations = True )\n\n        # get year from drop-down list\n        selected_year = input.year()\n\n        # get events data\n        # update event drop-down list\n        df = api_call('meetings', ['year=' + str(selected_year)])\n        \n        try:\n            events = pd.concat([\n                df.circuit_short_name,\n                df.location,\n                df.meeting_official_name.str.extract('FORMULA 1 (.*) 202.'),\n                df.meeting_key,],axis = 1)\\\n                .rename(columns = {'circuit_short_name':'circuit_name','location':'location_name',0:'event_name'})\n\n            ui.update_selectize(\"event\",choices = events.event_name)\n        except:\n            print(f\"Likely to be data error when retrieving event data from api_call: year={str(selected_year)}. Dataframe returned has {df.shape[0]} rows and {df.shape[1]} columns\")\n\n    @reactive.effect\n    def update_session_list_with_event() -> None:\n        global sessions\n        global selected_meeting_key\n\n        # updating session drop-down list\n        # reset drop-down lists except for year and event\n        ui.update_selectize(\"driver\", choices = [])\n        ui.update_selectize(\"session\",choices = [])\n\n        # reset variables\n        reset_variables(reset_selected_meeting_key = True, reset_sessions = True, reset_selected_session_key = True, reset_drivers = True, reset_selected_driver_colour = True, reset_selected_driver_number = True, reset_car_data = True, reset_locations = True)\n\n        # check drop-down lists year and event for values\n        # get session data\n        # update session drop-drop list\n        if len(input.year()) > 0 and len(input.event()) > 0:\n            selected_meeting_key = events.meeting_key[int(input.event())]\n\n            df = api_call('sessions', ['year=' + str(selected_year),'meeting_key=' + str(selected_meeting_key)])\n\n            try:\n                sessions = pd.concat([\n                    df.session_key,\n                    df.date_start,\n                    df.session_type,\n                    df.session_name], axis = 1)\n\n                ui.update_selectize(\"session\",choices = sessions.session_name)\n            except:\n                print(f\"Likely to be data error when retrieving session data from api_call: year={str(selected_year)}&meeting_key={str(selected_meeting_key)}. Dataframe returned has {df.shape[0]} rows and {df.shape[1]} columns\")\n\n    @reactive.effect\n    def update_driver_list_with_session() -> None:\n        global drivers\n        global selected_session_key\n\n        # updating driver drop-down list\n        # reset drop-down lists except for year, event and session\n        ui.update_selectize(\"driver\", choices = [])\n\n        # reset variables\n        reset_variables(reset_drivers = True, reset_selected_driver_number = True, reset_selected_driver_colour = True, reset_car_data = True, reset_locations = True)\n\n        if len(input.year()) > 0 and len(input.event()) and len(input.session()) > 0:\n            selected_session_key = sessions.session_key[int(input.session())]\n\n            response = urlopen('https://api.openf1.org/v1/drivers?session_key=' + str(selected_session_key))\n            df = pd.DataFrame(json.loads(response.read().decode('utf-8')))\n\n            try:\n                drivers = pd.concat([\n                    df.driver_number,\n                    df.name_acronym,\n                    df.full_name,\n                    df.team_name,\n                    df.team_colour,\n                    df.headshot_url,\n                    df.country_code], axis = 1)\n                drivers['team_name'] = drivers['team_name'].fillna('#NA')\n\n                ui.update_selectize(\"driver\", choices = drivers.full_name + \" (\" + drivers.team_name + \")\")\n            except:\n                print(f\"Likely to be data error when retrieving driver data from api_call: session={str(selected_session_key)}. Dataframe returned has {df.shape[0]} rows and {df.shape[1]} columns\")\n\n    # get car_data for fastest lap for selected driver\n    @reactive.effect\n    @reactive.event(input.refresh, ignore_none = False)\n    def update_cardata_with_driver() -> None:\n        global car_data\n        global locations\n        global selected_driver_number\n        global selected_driver_colour\n\n        # helper functions to map speed to car x, y position on track and determine track dominance at each trck position\n        # get numerical attribute at specific time, e.g. speed\n        def get_attr_from_car_data_datetime(car_data: pd.DataFrame, time: pd._libs.tslibs.timedeltas.Timedelta, attr:str) -> float:\n            assert car_data[attr].dtypes in ['int64', 'float64']\n            \n            before = car_data.date - car_data.date.min() < time\n            after = car_data.date - car_data.date.min() >=  time\n            speed_before = -1 if len(car_data[before][attr])  ==  0 else car_data[before][attr].iloc[-1]\n            speed_after = -1 if len(car_data[after][attr])  ==  0 else car_data[after][attr].iloc[0]\n            return (speed_before + speed_after) / 2\n\n        # Work out track dominance at specific position x, y between two cars\n        # return 0 = first car is faster\n        # return 1 = second car is faster\n        # return -1 = same speed\n        # x and y are car0 (driver0) position coordinates\n        # compare with car1's (driver1's) speed at the closest x, y position\n        def calc_dominance(x: int, y: int, speed: float) -> int:\n            global locations\n            loc1 = locations[1].copy()\n            loc1['dist'] = abs(loc1.x - x) + abs(loc1.y - y)\n            second_car_speed = loc1[loc1.dist  ==  loc1.dist.min()].speed.iloc[0]\n            if speed > second_car_speed:\n                return 0\n            elif speed < second_car_speed:\n                return 1\n            else:\n                return -1\n\n        def get_fastest_lap(laps: pd.DataFrame) -> pd.DataFrame:\n            # shortest lap time + has a sector 3 time (finished the lap)\n            return laps[(laps.lap_duration  ==  laps.lap_duration.min()) & -laps.duration_sector_3.isna()]\n\n        def get_lap_start_time(lap: pd.DataFrame) -> str:\n            return lap.iloc[0].date_start\n\n        def get_lap_end_time(lap:pd.DataFrame) -> str:\n            lap_start = get_lap_start_time(lap)\n            lap_duration = lap.iloc[0,:].lap_duration\n            lap_end = str(pd.to_datetime(lap_start) + pd.Timedelta(seconds = lap_duration))\n            return re.sub('\\\\s', 'T', lap_end)\n\n        def map_car_data_attr_to_location_xy(location:pd.DataFrame, car_data:pd.DataFrame, attr:str) -> pd.DataFrame:\n            location[attr] = -1.0\n            for i in range(location.shape[0]):\n                time = location.iloc[i,:].date\n                location.loc[i,attr] = get_attr_from_car_data_datetime(car_data, time, 'speed')\n            return location\n\n        # smooth dominance data that are stored in locations[0] (driver0's location data\n        def smooth_dominance(smooth: int) -> None:\n            global locations\n            for i in range(locations[0].shape[0]):\n                if i + smooth < locations[0].shape[0]:\n                    locations[0].loc[i, 'dominance'] = stats.mode(locations[0].loc[i:i + smooth, 'dominance'])[0]\n\n        # Only update if 1 or 2 drivers are chosen\n        if len(input.driver()) > 0 and len(input.driver()) <=  2:\n\n            fastest_lap_start = None\n            fastest_lap_end = None\n\n            # store previously selected drivers\n            old_selected_driver_number = selected_driver_number\n\n            # update selected driver variables\n            selected_driver_number = [drivers.driver_number[int(d)] for d in input.driver()]\n            # assign team colour to driver or use default colour if team/team colour is none\n            selected_driver_colour = ['#' + str(drivers.team_colour[int(d)]) if drivers.team_colour[int(d)] is not None else default_driver_colour for d in input.driver()]\n\n            # if there are more than one driver and driver/team colour assigned are the same\n            # assigned driver colours to be default driver0 and driver1 colours\n            if len(input.driver()) > 1 and (selected_driver_colour[0]  ==  selected_driver_colour[1]):\n                selected_driver_colour = [default_driver0_colour, default_driver1_colour]\n\n            # get car_data and location_data\n            temp_car_data = []\n            temp_locations = []\n            for i, d in enumerate(selected_driver_number):\n                if old_selected_driver_number == [] or selected_driver_number[i] not in old_selected_driver_number:\n                    api_result_df = api_call('laps',['session_key=' + str(selected_session_key),'driver_number=' + str(selected_driver_number[i])])\n\n                    fastest_lap = get_fastest_lap(api_result_df)\n                    fastest_lap_start = get_lap_start_time(fastest_lap)\n                    fastest_lap_end = get_lap_end_time(fastest_lap)\n\n                    car_data_df = api_call('car_data',['driver_number=' + str(selected_driver_number[i]),'session_key=' + str(selected_session_key),'date>=' + str(fastest_lap_start),'date<=' + str(fastest_lap_end)])\n                    car_data_df['date'] = pd.to_datetime(car_data_df.date, format = 'mixed') - pd.to_datetime(car_data_df.date,format = 'mixed').min()\n                    temp_car_data.append(car_data_df)\n\n                    locations_df = api_call('location',['driver_number=' + str(selected_driver_number[i]),'session_key=' + str(selected_session_key),'date>=' + str(fastest_lap_start),'date<=' + str(fastest_lap_end)])\n                    locations_df['date'] = pd.to_datetime(locations_df.date, format = 'mixed') - pd.to_datetime(locations_df.date,format = 'mixed').min()\n                    start_x = locations_df[locations_df.date  ==  locations_df.date.min()].x.iloc[0]\n                    start_y = locations_df[locations_df.date  ==  locations_df.date.min()].y.iloc[0]\n                    locations_df['x'] = locations_df.x - start_x\n                    locations_df['y'] = locations_df.y - start_y\n                    temp_locations.append(locations_df)\n                else:\n                    temp_car_data.append(car_data.copy()[old_selected_driver_number.index(selected_driver_number[i])])\n                    temp_locations.append(locations.copy()[old_selected_driver_number.index(selected_driver_number[i])])\n\n            car_data = temp_car_data.copy()\n            locations = temp_locations.copy()\n\n            # initialize colour attribute in locations[0] for track dominance plotting\n            # stored track dominance information only in locations[0] (driver0's location table) plotting\n            locations[0]['colour'] = selected_driver_colour[0]\n\n            # compare if there are two cars\n            if len(locations) > 1:\n                # map speed (car_data) to x, y position (location)\n                for j in range(len(locations)):\n                    locations[j] = map_car_data_attr_to_location_xy(locations[j],car_data[j], 'speed')\n                    '''locations[j]['speed'] = -1.0\n                    for i in range(locations[j].shape[0]):\n                        time = locations[j].iloc[i,:].date\n                        locations[j].loc[i,'speed'] = get_speed_from_car_data_datetime(car_data[j], time)'''\n\n                # determine track dominance\n                locations[0]['dominance'] = -99\n                for i in range(locations[0].shape[0]):\n                    x, y, speed = locations[0].iloc[i, :].x, locations[0].iloc[i, :].y, locations[0].iloc[i, :].speed\n                    locations[0].loc[i, 'dominance'] = calc_dominance(x, y, speed)\n\n                # smooth dominance result twice\n                smooth_dominance(smooth = 12)\n                smooth_dominance(smooth = 8)\n\n                # assign driver colour to locations on track to represent track dominance\n                for i in range(locations[0].shape[0]):\n                    dominance = locations[0].loc[i, 'dominance']\n                    if dominance  ==  0:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[0]\n                    elif dominance  ==  1:\n                        locations[0].loc[i, 'colour'] = selected_driver_colour[1]\n                    else:\n                        locations[0].loc[i, 'colour'] = '#00AAAA'\n\n        print(selected_meeting_key, selected_session_key)\n\n    # header elements\n    @render.text\n    def header() -> str:\n        if input.event():\n            event_name = get_event_name(int(input.event()))\n            return input.year() + ' ' + event_name if event_name !=  None else input.year()\n\n    @render.text\n    def sub_head() -> str:\n        if input.session():\n            session_name = get_session_name(int(input.session()))\n            return session_name if session_name !=  None else ''\n\n    @render.plot\n    def driver0() -> plt.figure:\n        if input.driver():\n            front_name, back_name = format_driver_names(int(input.driver()[0]))\n            return plot_names(front_name, back_name)\n\n    @render.plot\n    def driver1() -> plt.figure:\n        if len(input.driver())  ==  2:\n            front_name, back_name = format_driver_names(int(input.driver()[1]))\n            return plot_names(front_name, back_name)\n\n    # telemetry plot\n    @render_widget\n    @reactive.event(input.refresh, ignore_none = False)\n    def tele_plot() -> go.Figure:\n        fig = go.Figure()\n\n        if input.driver() !=  '':\n            plot_data = car_data.copy()\n\n            for i, data in enumerate(plot_data):\n                if i < 2:\n                    data['date'] = data.date.astype(str)\n                    data['date'] = data.date.str.extract(r'([0-9]{1}:[0-9]{2}.[0-9]{3})')\n                    data.sort_values('date', inplace = True)\n                    data['date'] = pd.to_datetime(data.date,format = '%M:%S.%f')\n                    data.dropna(inplace = True)\n\n                    dr_mask = drivers.driver_number  ==  selected_driver_number[i]\n\n                    time_str = str(data.date.max() - data.date.min())\n                    time_str = re.sub('[0-9]\\s(days)\\s','',time_str)\n                    time_str = re.sub('(?<= .[0-9]{3})0{2,3}$','',time_str)\n                    time_str = re.search('[0-9]{2}:[0-9]{2}.[0-9]{3}',time_str)\n                    time_str = time_str.group() if time_str is not None else ''\n\n                    fig.add_trace(go.Scatter(x = data.date, y = data.speed, line = (dict(color = str(selected_driver_colour[i]))) , name = list(drivers.loc[dr_mask, 'full_name'])[0] + ' ' + time_str))\n\n        fig.update_layout(\n            template = 'plotly_dark',\n            plot_bgcolor = 'black',\n            showlegend = True,\n            legend = dict(yanchor = 'bottom',y = 0.01,xanchor = 'right',x = 0.99,orientation = 'h'))\n        fig[\"layout\"].update({\"xaxis\": {\"tickformat\": \"%M:%S.%f\"}})\n        fig.update_yaxes(title_text = 'Speed / mph')\n        return fig\n\n    # driver metrics\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_throttle() -> plt.figure:\n        return driver_metric('throttle', 0, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_throttle() -> plt.figure:\n        return driver_metric('throttle', 1, pd.Series.mean, 0, 100, 'Throttle')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_brake() -> plt.figure:\n        return driver_metric('brake', 0, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_brake() -> plt.figure:\n        return driver_metric('brake', 1, pd.Series.mean, 0, 100, 'Brake')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver0_topspeed() -> plt.figure:\n        return driver_metric('speed', 0, pd.Series.max, 0, 350, 'Top speed')\n\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def driver1_topspeed() -> plt.figure:\n        return driver_metric('speed', 1, pd.Series.max, 0, 350, 'Top speed')\n\n    # track dominance\n    @render.plot\n    @reactive.event(input.refresh, ignore_none = False)\n    def track_dominance_plot() -> go.Figure:\n        global locations\n\n        fig, ax = plt.subplots()\n\n        if len(input.driver()) > 0 and len(locations) > 0:\n            plot_data = locations.copy()[0]\n\n            # draw driver0\n            ax.plot(plot_data.x + 50, plot_data.y - 250, c = text_colour, ls = '-', lw = 10, alpha = 0.15)\n            ax.plot(plot_data.x, plot_data.y, c = track_grey, ls = '-', lw = 6)\n            ax.plot(plot_data.x, plot_data.y, c = selected_driver_colour[0], ls = '-', lw = 4)\n\n            # work out segments for drawing driver1 dominant parts\n            if len(plot_data.colour.unique()) > 1:\n                current_segment = 0\n                plot_data['segment'] = -1\n                for i in range(plot_data.shape[0]):\n                    plot_data.loc[i, 'segment'] = current_segment\n                    if (i < plot_data.shape[0] - 1) and (plot_data.loc[i, 'dominance'] !=  plot_data.loc[i + 1, 'dominance']):\n                        current_segment  +=  1\n\n                # only draw driver1 dominant segments\n                plot_data_c = plot_data[plot_data.dominance  ==  1]\n                for seg in plot_data_c.segment.unique():\n                        plot_segment = plot_data_c[plot_data_c.segment  ==  seg]\n                        if plot_segment.shape[0] > 1:\n                            # ax.plot(plot_segment.x, plot_segment.y, c = tracker_border_colour_driver1, ls = '-', lw = 6)\n                            ax.plot(plot_segment.x, plot_segment.y, c = selected_driver_colour[1], ls = '-', lw = 4)\n\n            ax.plot(plot_data.x[0], plot_data.y[0], c = track_border_colour, marker = 'o', markersize = 8)\n            ax.plot(plot_data.x[0], plot_data.y[0], c = text_colour, marker = 'o', markersize = 6)\n\n        ax.axis('off')\n        ax.set_facecolor(main_bg_colour)\n\n        fig.patch.set_facecolor(main_bg_colour)\n        return fig\n    \n    @render.text\n    def ack() -> str:\n        return 'Credit to the open-sourced OpenF1.org API (https://openf1.org/) for the Formula One\u00ae telemetry data used in this dashboard'\n\n\napp = App(app_ui, server)\n", "type": "text"}]